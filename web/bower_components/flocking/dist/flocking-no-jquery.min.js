/*! Flocking 0.2.0, Copyright 2017 Colin Clark | flockingjs.org */


!function(e, t) {
    "object" == typeof exports ? (e.flock = exports, t(exports, require("jquery"))) : "function" == typeof define && define.amd ? define([ "exports", "jquery" ], function(n, r) {
        return e.flock = n, e.flock, t(n, r);
    }) : (e.flock = {}, t(e.flock, jQuery));
}(this, function(e, t) {
    window.jQuery = t;
    var n = n || {}, r = r || n;
    !function(e, t) {
        "use strict";
        function n(e, t, n, r) {
            for (var a = e[n], o = 0; o < r.length - 1; ++o) a = r[o + 1](a, n);
            t[n] = a;
        }
        function r(e, n, r, a) {
            for (var o = 0; o < r; ++o) e = a(e, n[o], o, t.makeArray(n));
            return e;
        }
        function a(e, t, n, a) {
            for (var o = [], i = 0; i < e.length; ++i) {
                var u = r(e[i], t, n, a[i]);
                void 0 !== u && o.push(u);
            }
            return o;
        }
        t.version = "Infusion 3.0.0", t.Error = Error, t.environment = {
            fluid: t
        }, t.global = t.global || "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}, 
        t.invokeLater = function(e) {
            return setTimeout(e, 1);
        }, t.defeatLogging = !0, t.activityTracing = !1, t.activityTrace = [];
        var o = /(%\w+)/g;
        t.renderOneActivity = function(e, t) {
            for (var n = !0 === t ? [] : [ "    while " ], r = e.message, a = o.lastIndex = 0; ;) {
                var i = o.exec(r);
                if (!i) break;
                var u = i[1].substring(1);
                n.push(r.substring(a, i.index)), n.push(e.args[u]), a = o.lastIndex;
            }
            return a < r.length && n.push(r.substring(a)), n;
        }, t.renderActivity = function(e, n) {
            return n = n || t.renderOneActivity, t.transform(e, n);
        }, t.singleThreadLocal = function(e) {
            var t = e();
            return function(e) {
                return void 0 === e ? t : t = e;
            };
        }, t.threadLocal = t.singleThreadLocal, t.globalThreadLocal = t.threadLocal(function() {
            return {};
        }), t.getActivityStack = function() {
            var e = t.globalThreadLocal();
            return e.activityStack || (e.activityStack = []), e.activityStack;
        }, t.describeActivity = t.getActivityStack, t.logActivity = function(e) {
            e = e || t.describeActivity();
            var n = t.renderActivity(e).reverse();
            t.log("Current activity: "), t.each(n, function(e) {
                t.doLog(e);
            });
        }, t.pushActivity = function(e, n, r) {
            var a = {
                type: e,
                message: n,
                args: r,
                time: new Date().getTime()
            };
            t.activityTracing && t.activityTrace.push(a), t.passLogLevel(t.logLevel.TRACE) && t.doLog(t.renderOneActivity(a, !0)), 
            t.getActivityStack().push(a);
        }, t.popActivity = function(e) {
            e = e || 1, t.activityTracing && t.activityTrace.push({
                pop: e
            });
            var n = t.getActivityStack(), r = n.length - e;
            n.length = r < 0 ? 0 : r;
        }, t.FluidError = function() {
            var e = Error.apply(this, arguments);
            this.message = e.message;
            try {
                throw e;
            } catch (e) {
                this.stack = e.stack;
            }
            return this;
        }, t.FluidError.prototype = Object.create(Error.prototype), t.logFailure = function(e, n) {
            t.log.apply(null, [ t.logLevel.FAIL, "ASSERTION FAILED: " ].concat(e)), t.logActivity(n);
        }, t.renderLoggingArg = function(e) {
            return void 0 === e ? "undefined" : t.isPrimitive(e) || !t.isPlainObject(e) ? e : JSON.stringify(e);
        }, t.builtinFail = function(e) {
            var n = t.transform(e, t.renderLoggingArg).join("");
            throw new t.FluidError("Assertion failure - check console for more details: " + n);
        }, t.fail = function() {
            var e = t.makeArray(arguments), n = t.makeArray(t.describeActivity());
            t.popActivity(n.length), t.failureEvent ? t.failureEvent.fire(e, n) : (t.logFailure(e, n), 
            t.builtinFail(e, n));
        }, t.expect = function(e, n, r) {
            t.transform(t.makeArray(r), function(r) {
                void 0 === n[r] && t.fail(e + " missing required parameter " + r);
            });
        }, t.isLogging = function() {
            return i[0].priority > t.logLevel.IMPORTANT.priority;
        }, t.isLogLevel = function(e) {
            return t.isMarker(e) && void 0 !== e.priority;
        }, t.passLogLevel = function(e) {
            return e.priority <= i[0].priority;
        }, t.setLogging = function(e) {
            var n;
            "boolean" == typeof e ? n = t.logLevel[e ? "INFO" : "IMPORTANT"] : t.isLogLevel(e) ? n = e : t.fail("Unrecognised fluid logging level ", e), 
            i.unshift(n), t.defeatLogging = !t.isLogging();
        }, t.setLogLevel = t.setLogging, t.popLogging = function() {
            var e = 1 === i.length ? i[0] : i.shift();
            return t.defeatLogging = !t.isLogging(), e;
        }, t.doLog = function(e) {
            "undefined" != typeof console && (console.debug ? console.debug.apply(console, e) : "function" == typeof console.log && console.log.apply(console, e));
        }, t.log = function() {
            var e = t.makeArray(arguments), n = t.logLevel.INFO;
            if (t.isLogLevel(e[0]) && (n = e.shift()), t.passLogLevel(n)) {
                var r = [ t.renderTimestamp(new Date()) + ":  " ].concat(e);
                t.doLog(r);
            }
        }, t.isValue = function(e) {
            return void 0 !== e && null !== e;
        }, t.isPrimitive = function(e) {
            var t = typeof e;
            return !e || "string" === t || "boolean" === t || "number" === t || "function" === t;
        }, t.isArrayable = function(e) {
            return e && (e.jquery || "[object Array]" === Object.prototype.toString.call(e));
        }, t.isPlainObject = function(e, t) {
            var n = Object.prototype.toString.call(e);
            return "[object Array]" === n ? !t : "[object Object]" === n && (!e.constructor || !e.constructor.prototype || Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"));
        }, t.typeCode = function(e) {
            return t.isPrimitive(e) || !t.isPlainObject(e) ? "primitive" : t.isArrayable(e) ? "array" : "object";
        }, t.isIoCReference = function(e) {
            return "string" == typeof e && "{" === e.charAt(0) && e.indexOf("}") > 0;
        }, t.isDOMNode = function(e) {
            return e && "number" == typeof e.nodeType;
        }, t.isComponent = function(e) {
            return e && e.constructor === t.componentConstructor;
        }, t.isUncopyable = function(e) {
            return t.isPrimitive(e) || !t.isPlainObject(e);
        }, t.isApplicable = function(e) {
            return e.apply && "function" == typeof e.apply;
        }, t.identity = function(e) {
            return e;
        }, t.notImplemented = function() {
            t.fail("This operation is not implemented");
        }, t.firstDefined = function(e, t) {
            return void 0 === e ? t : e;
        }, t.freshContainer = function(e) {
            return t.isArrayable(e) ? [] : {};
        }, t.copyRecurse = function(e, n) {
            return n.length > t.strategyRecursionBailout && t.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + t.strategyRecursionBailout + " via path of " + n.join(".") + "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout"), 
            t.isUncopyable(e) ? e : t.transform(e, function(e, r) {
                n.push(r);
                var a = t.copyRecurse(e, n);
                return n.pop(), a;
            });
        }, t.copy = function(e) {
            return t.copyRecurse(e, []);
        }, t.extend = e.extend, t.makeArray = function(e) {
            var n = [];
            if (null !== e && void 0 !== e) if (t.isPrimitive(e) || t.isPlainObject(e, !0) || "number" != typeof e.length) n.push(e); else for (var r = 0; r < e.length; ++r) n[r] = e[r];
            return n;
        }, t.pushArray = function(e, n, r) {
            var a = e[n] ? e[n] : e[n] = [];
            t.isArrayable(r) ? a.push.apply(a, r) : a.push(r);
        }, t.transform = function(e) {
            if (t.isPrimitive(e)) return e;
            var r = t.freshContainer(e);
            if (t.isArrayable(e)) for (var a = 0; a < e.length; ++a) n(e, r, a, arguments); else for (var o in e) n(e, r, o, arguments);
            return r;
        }, t.each = function(e, n) {
            if (t.isArrayable(e)) for (var r = 0; r < e.length; ++r) n(e[r], r); else for (var a in e) n(e[a], a);
        }, t.make_find = function(e) {
            var n = !e && void 0;
            return function(r, a, o) {
                var i;
                if (t.isArrayable(r)) {
                    for (var u = 0; u < r.length; ++u) if ((i = a(r[u], u)) !== n) return e ? r[u] : i;
                } else for (var s in r) if ((i = a(r[s], s)) !== n) return e ? r[s] : i;
                return o;
            };
        }, t.find = t.make_find(!1), t.find_if = t.make_find(!0), t.accumulate = function(e, t, n) {
            for (var r = 0; r < e.length; ++r) n = t(e[r], n, r);
            return n;
        }, t.add = function(e, t) {
            return e + t;
        }, t.remove_if = function(e, n, r) {
            if (t.isArrayable(e)) for (var a = e.length - 1; a >= 0; --a) n(e[a], a) && (r && r.unshift(e[a]), 
            e.splice(a, 1)); else for (var o in e) n(e[o], o) && (r && (r[o] = e[o]), delete e[o]);
            return r || e;
        }, t.generate = function(e, t, n) {
            for (var r = [], a = 0; a < e; ++a) r[a] = n ? t(a) : t;
            return r;
        }, t.iota = function(e, t) {
            t = t || 0;
            for (var n = [], r = 0; r < e; ++r) n[n.length] = t++;
            return n;
        }, t.getMembers = function(e, n) {
            return t.transform(e, function(e) {
                return t.get(e, n);
            });
        }, t.filterKeys = function(n, r, a) {
            return t.remove_if(e.extend({}, n), function(e, t) {
                return a ^ -1 === r.indexOf(t);
            });
        }, t.censorKeys = function(e, n) {
            return t.filterKeys(e, n, !0);
        }, t.keys = function(e) {
            var t = [];
            for (var n in e) t.push(n);
            return t;
        }, t.values = function(e) {
            var t = [];
            for (var n in e) t.push(e[n]);
            return t;
        }, t.contains = function(e, n) {
            return e ? t.isArrayable(e) ? -1 !== e.indexOf(n) : t.find(e, function(e) {
                if (n === e) return !0;
            }) : void 0;
        }, t.keyForValue = function(e, n) {
            return t.find(e, function(e, t) {
                if (n === e) return t;
            });
        }, t.arrayToHash = function(e) {
            var n = {};
            return t.each(e, function(e) {
                n[e] = !0;
            }), n;
        }, t.stableSort = function(e, t) {
            for (var n = 0; n < e.length; n++) {
                var r, a = e[n];
                for (r = n; r > 0 && t(a, e[r - 1]) < 0; r--) e[r] = e[r - 1];
                e[r] = a;
            }
        }, t.hashToArray = function(n, r, a) {
            var o = [];
            return t.each(n, function(t, n) {
                var i = {};
                i[r] = n, a ? i = a(i, t, n) || i : e.extend(!0, i, t), o.push(i);
            }), o;
        }, t.flatten = function(e) {
            var n = [];
            return t.each(e, function(e) {
                t.isArrayable(e) ? n = n.concat(e) : n.push(e);
            }), n;
        }, t.clear = function(e) {
            if (t.isArrayable(e)) e.length = 0; else for (var n in e) delete e[n];
        }, t.compareStringLength = function(e) {
            return e ? function(e, t) {
                return e.length - t.length;
            } : function(e, t) {
                return t.length - e.length;
            };
        }, t.parseInteger = function(e) {
            return isFinite(e) && e % 1 == 0 ? Number(e) : NaN;
        }, t.roundToDecimal = function(e, t, n) {
            if (t = t && t >= 0 ? Math.round(t) : 0, "ceil" === n || "floor" === n) return Number(Math[n](e + "e" + t) + "e-" + t);
            var r = e >= 0 ? 1 : -1;
            return Number(r * (Math.round(Math.abs(e) + "e" + t) + "e-" + t));
        }, t.debounce = function(e, t, n) {
            var r, a;
            return function() {
                var o = this, i = arguments, u = n && !r;
                return clearTimeout(r), r = setTimeout(function() {
                    r = null, n || (a = e.apply(o, i));
                }, t), u && (a = e.apply(o, i)), a;
            };
        }, t.freezeRecursive = function(e) {
            return t.isPlainObject(e) ? (t.each(e, function(e) {
                t.freezeRecursive(e);
            }), Object.freeze(e)) : e;
        }, t.marker = function() {}, t.makeMarker = function(n, r) {
            var a = Object.create(t.marker.prototype);
            return a.value = n, e.extend(a, r), Object.freeze(a);
        }, t.VALUE = t.makeMarker("VALUE"), t.NO_VALUE = t.makeMarker("NO_VALUE"), t.EXPAND = t.makeMarker("EXPAND"), 
        t.isMarker = function(e, n) {
            return e instanceof t.marker && (!n || e.value === n.value);
        }, t.logLevelsSpec = {
            FATAL: 0,
            FAIL: 5,
            WARN: 10,
            IMPORTANT: 12,
            INFO: 15,
            TRACE: 20
        }, t.logLevel = t.transform(t.logLevelsSpec, function(e, n) {
            return t.makeMarker(n, {
                priority: e
            });
        });
        var i = [ t.logLevel.IMPORTANT ];
        t.model = {}, t.model.copyModel = function(n, r) {
            t.clear(n), e.extend(!0, n, r);
        }, t.model.parseEL = function(e) {
            return "" === e ? [] : String(e).split(".");
        }, t.model.composePath = function(e, t) {
            return "" === e ? t : "" === t ? e : e + "." + t;
        }, t.model.composeSegments = function() {
            return t.makeArray(arguments).join(".");
        }, t.lastDotIndex = function(e) {
            return e.lastIndexOf(".");
        }, t.model.getToTailPath = function(e) {
            var n = t.lastDotIndex(e);
            return -1 === n ? "" : e.substring(0, n);
        }, t.model.getTailPath = function(e) {
            var n = t.lastDotIndex(e);
            return e.substring(n + 1);
        }, t.path = t.model.composeSegments, t.composePath = t.model.composePath, t.requireDataBinding = function() {
            t.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
        }, t.model.setWithStrategy = t.model.getWithStrategy = t.requireDataBinding, t.model.resolvePathSegment = function(e, t, n, r) {
            if (!r && e.resolvePathSegment) {
                var a = e.resolvePathSegment(t);
                if (void 0 !== a) return a;
            }
            return n && void 0 === e[t] ? e[t] = {} : e[t];
        }, t.model.parseToSegments = function(e, n, r) {
            return "number" == typeof e || "string" == typeof e ? n(e) : r ? t.makeArray(e) : e;
        }, t.model.pathToSegments = function(e, n) {
            var r = n && n.parser ? n.parser.parse : t.model.parseEL;
            return t.model.parseToSegments(e, r);
        }, t.model.accessImpl = function(e, n, r, a, o, i, u) {
            var s = t.model.pathToSegments(n, a), l = 0;
            if (o && (l = o.length, s = o.concat(s)), e = u(e, s, l, a, r === t.NO_VALUE ? 0 : 1), 
            r === t.NO_VALUE || r === t.VALUE) return i ? {
                root: e,
                segs: s
            } : e;
            e[s[s.length - 1]] = r;
        }, t.model.accessSimple = function(e, n, r, a, o, i) {
            return t.model.accessImpl(e, n, r, a, o, i, t.model.traverseSimple);
        }, t.model.traverseSimple = function(e, n, r, a, o) {
            for (var i = a, u = n.length - o, s = 0; s < u; ++s) {
                if (!e) return;
                var l = n[s];
                e = a && a[l] ? a[l] : t.model.resolvePathSegment(e, l, 1 === o, i), a = null;
            }
            return e;
        }, t.model.setSimple = function(e, n, r, a, o) {
            t.model.accessSimple(e, n, r, a, o, !1);
        }, t.model.getSimple = function(e, n, r, a) {
            return null === n || void 0 === n || 0 === n.length ? e : t.model.accessSimple(e, n, t.NO_VALUE, r, a, !1);
        }, t.getImmediate = function(e, t, n) {
            for (var r = void 0 === n ? t.length : n + 1, a = 0; a < r; ++a) e = e ? e[t[a]] : void 0;
            return e;
        }, t.decodeAccessorArg = function(e) {
            return e && e !== t.model.defaultGetConfig && e !== t.model.defaultSetConfig ? "environment" === e.type ? e.value : void 0 : null;
        }, t.set = function(e, n, r, a, o) {
            var i = t.decodeAccessorArg(a);
            void 0 === i ? t.model.setWithStrategy(e, n, r, a, o) : t.model.setSimple(e, n, r, i, o);
        }, t.get = function(e, n, r, a) {
            var o = t.decodeAccessorArg(r);
            return void 0 === o ? t.model.getWithStrategy(e, n, r, a) : t.model.accessImpl(e, n, t.NO_VALUE, o, null, !1, t.model.traverseSimple);
        }, t.getGlobalValue = function(e, n) {
            if (e) return n = n || t.environment, t.get(t.global, e, {
                type: "environment",
                value: n
            });
        }, t.bind = function(e, n, r) {
            return e[n].apply(e, t.makeArray(r));
        }, t.invokeGlobalFunction = function(e, n, r) {
            var a = t.getGlobalValue(e, r);
            if (a) return a.apply(null, t.isArrayable(n) ? n : t.makeArray(n));
            t.fail("Error invoking global function: " + e + " could not be located");
        }, t.registerGlobalFunction = function(e, n, r) {
            r = r || t.environment, t.set(t.global, e, n, {
                type: "environment",
                value: r
            });
        }, t.setGlobalValue = t.registerGlobalFunction, t.registerNamespace = function(e, n) {
            n = n || t.environment;
            var r = t.getGlobalValue(e, n);
            return r || (r = {}, t.setGlobalValue(e, r, n)), r;
        }, t.dumpEl = t.identity, t.renderTimestamp = t.identity, t.generateUniquePrefix = function() {
            return Math.floor(1e12 * Math.random()).toString(36) + "-";
        };
        var u = t.generateUniquePrefix();
        t.fluidInstance = u;
        var s = 1;
        t.allocateGuid = function() {
            return u + s++;
        }, t.registerNamespace("fluid.event"), t.extremePriority = 4e9, t.priorityTypes = {
            first: -1,
            last: 1,
            before: 0,
            after: 0
        }, t.extremalPriorities = {
            none: 0,
            testing: 10,
            authoring: 20
        }, t.parsePriorityConstraint = function(e, n, r) {
            var a = e.split(":"), o = a[0], i = t.priorityTypes[o];
            return void 0 === i && t.fail("Invalid constraint type in priority field " + e + ": the only supported values are " + t.keys(t.priorityTypes).join(", ") + " or numeric"), 
            n && 0 === i && t.fail("Constraint type in priority field " + e + " is not supported in a " + r + " record - you must use either a numeric value or first, last"), 
            {
                type: a[0],
                target: a[1]
            };
        }, t.parsePriority = function(e, n, r, a) {
            e = e || 0;
            var o = {
                count: n || 0,
                fixed: null,
                constraint: null,
                site: a
            };
            "number" == typeof e ? o.fixed = -e : o.constraint = t.parsePriorityConstraint(e, r, a);
            var i = o.constraint ? t.priorityTypes[o.constraint.type] : 0;
            if (0 !== i) {
                var u = o.constraint.target || "none", s = t.extremalPriorities[u];
                void 0 === s && t.fail("Unrecognised extremal priority target " + u + ": the currently supported values are " + t.keys(t.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities"), 
                o.fixed = i * (t.extremePriority + s);
            }
            return null !== o.fixed && (o.fixed += o.count / 1024), o;
        }, t.renderPriority = function(e) {
            return e.constraint ? e.constraint.target ? e.constraint.type + ":" + e.constraint.target : e.constraint.type : Math.floor(e.fixed);
        }, t.compareByPriority = function(e, t) {
            return null !== e.priority.fixed && null !== t.priority.fixed ? e.priority.fixed - t.priority.fixed : (null === e.priority.fixed) - (null === t.priority.fixed);
        }, t.honourConstraint = function(e, n, r) {
            var a = e[r].priority.constraint, o = t.find(e, function(e, t) {
                return e.namespace === a.target ? t : void 0;
            }, -1);
            if (-1 === o) return !0;
            if (o >= n) return !1;
            for (var i = o + ("after" === a.type ? 1 : 0), u = e[r], s = r; s >= i; --s) e[s] = e[s - 1];
            return e[i] = u, !0;
        }, t.sortByPriority = function(e) {
            t.stableSort(e, t.compareByPriority);
            for (var n = t.find(e, function(e, n) {
                return e.priority.constraint && 0 === t.priorityTypes[e.priority.constraint.type] ? n : void 0;
            }, e.length); ;) {
                if (n === e.length) return e;
                for (var r = n, a = n; a < e.length; ++a) t.honourConstraint(e, n, a) && ++n;
                if (n === r) {
                    var o = e.slice(n);
                    t.fail("Could not find targets for any constraints in " + o[0].priority.site + " ", o, ": none of the targets (" + t.getMembers(o, "priority.constraint.target").join(", ") + ") matched any namespaces of the elements in (", e.slice(0, n), ") - this is caused by either an invalid or circular reference");
                }
            }
        }, t.parsePriorityRecords = function(n, r) {
            var a = t.hashToArray(n, "namespace", function(n, a, o) {
                e.extend(n, a), n.priority = t.parsePriority(a.priority, o, !1, r);
            });
            return t.sortByPriority(a), a;
        }, t.event.identifyListener = function(e, n) {
            return "string" == typeof e || e.$$fluid_guid || n || (e.$$fluid_guid = t.allocateGuid()), 
            e.$$fluid_guid;
        }, t.event.impersonateListener = function(e, n) {
            t.event.identifyListener(e), n.$$fluid_guid = e.$$fluid_guid;
        }, t.event.sortListeners = function(e) {
            var n = [];
            return t.each(e, function(e) {
                for (var t, r = 0; r < e.length; ++r) {
                    var a = e[r];
                    a.softNamespace || t || (t = a);
                }
                t ? n.push(t) : n = n.concat(e);
            }), t.sortByPriority(n);
        }, t.event.resolveListener = function(e) {
            var n = e.globalName || ("string" == typeof e ? e : null);
            if (n) {
                var r = t.getGlobalValue(n);
                r ? e = r : t.fail("Unable to look up name " + n + " as a global function");
            }
            return e;
        }, t.nameComponent = function(e) {
            return e ? "component with typename " + e.typeName + " and id " + e.id : "[unknown component]";
        }, t.event.nameEvent = function(e, n) {
            return n + " of " + t.nameComponent(e);
        }, t.makeEventFirer = function(n) {
            var r, a = (n = n || {}).name || "<anonymous>", o = function() {
                r.listeners = {}, r.byId = {}, r.sortedListeners = [], r.addListener = function(n, a, o, i, u) {
                    var s;
                    if (r.destroyed && t.fail("Cannot add listener to destroyed event firer " + r.name), 
                    n) {
                        t.isPlainObject(n, !0) && !t.isApplicable(n) && (n = (s = n).listener, a = s.namespace, 
                        o = s.priority, i = s.softNamespace, u = s.listenerId), "string" == typeof n && (n = {
                            globalName: n
                        });
                        var l = u || t.event.identifyListener(n);
                        a = a || l, s = e.extend(s || {}, {
                            namespace: a,
                            listener: n,
                            softNamespace: i,
                            listenerId: u,
                            priority: t.parsePriority(o, r.sortedListeners.length, !1, "listeners")
                        }), r.byId[l] = s, (r.listeners[a] = t.makeArray(r.listeners[a]))[i ? "push" : "unshift"](s), 
                        r.sortedListeners = t.event.sortListeners(r.listeners);
                    }
                }, r.addListener.apply(null, arguments);
            };
            return r = {
                eventId: t.allocateGuid(),
                name: a,
                ownerId: n.ownerId,
                typeName: "fluid.event.firer",
                destroy: function() {
                    r.destroyed = !0;
                },
                addListener: function() {
                    o.apply(null, arguments);
                },
                removeListener: function(e) {
                    if (r.listeners) {
                        var n, a, o;
                        "string" == typeof e ? (n = e, (o = r.listeners[n]) || (a = n, n = null)) : "function" == typeof e && ((a = t.event.identifyListener(e, !0)) || t.fail("Cannot remove unregistered listener function ", e, " from event " + r.name));
                        var i = r.byId[a], u = i && i.softNamespace;
                        n = n || i && i.namespace || a, delete r.byId[a], (o = r.listeners[n]) && (u ? t.remove_if(o, function(e) {
                            return e.listener.$$fluid_guid === a || e.listenerId === a;
                        }) : o.shift(), 0 === o.length && delete r.listeners[n]), r.sortedListeners = t.event.sortListeners(r.listeners);
                    }
                },
                fire: function() {
                    var e = r.sortedListeners;
                    if (e && !r.destroyed) {
                        t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Firing event " + a + " to list of " + e.length + " listeners");
                        for (var o = 0; o < e.length; ++o) {
                            var i = e[o];
                            i.listener = t.event.resolveListener(i.listener);
                            var u, s = i.listener.apply(null, arguments);
                            if ((n.preventable && !1 === s || r.destroyed) && (u = !1), void 0 !== u) return u;
                        }
                    }
                }
            };
        }, t.fireEvent = function(e, n, r) {
            var a = e.events[n];
            a && a.fire.apply(null, t.makeArray(r));
        }, t.event.addListenerToFirer = function(e, n, r, a) {
            if (a = a || t.identity, t.isArrayable(n)) for (var o = 0; o < n.length; ++o) t.event.addListenerToFirer(e, n[o], r, a); else "function" == typeof n || "string" == typeof n ? a(e).addListener(n, r) : n && "object" == typeof n && a(e).addListener(n.listener, r || n.namespace, n.priority, n.softNamespace, n.listenerId);
        }, t.event.resolveListenerRecord = function(e) {
            return {
                records: e
            };
        }, t.expandImmediate = function(e) {
            t.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + e);
        }, t.mergeListeners = function(e, n, r) {
            t.each(r, function(r, a) {
                var o, i;
                if (t.isIoCReference(a)) (o = t.expandImmediate(a, e)) || t.fail("Error in listener record: key " + a + ' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?'); else {
                    var u = a.indexOf(".");
                    -1 !== u && (i = a.substring(u + 1), a = a.substring(0, u)), n[a] || t.fail("Listener registered for event " + a + " which is not defined for this component"), 
                    o = n[a];
                }
                var s = t.event.resolveListenerRecord(r, e, a, i, !0);
                t.event.addListenerToFirer(o, s.records, i, s.adderWrapper);
            });
        }, t.eventFromRecord = function(e, n, r) {
            var a;
            return e && ("string" != typeof e || t.isIoCReference(e)) ? t.event.resolveEvent ? a = t.event.resolveEvent(r, n, e) : t.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", e) : a = t.makeEventFirer({
                name: t.event.nameEvent(r, n),
                preventable: "preventable" === e,
                ownerId: r.id
            }), a;
        }, t.instantiateFirers = function(e, n) {
            t.each(n.events, function(n, r) {
                e.events[r] = t.eventFromRecord(n, r, e);
            });
        }, t.mergeListenerPolicy = function(e, n, r) {
            return "string" != typeof r && t.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + r + " from ", n), 
            !t.isIoCReference(r) && -1 !== r.indexOf(".") ? n || e : t.arrayConcatPolicy(e, n);
        }, t.makeMergeListenersPolicy = function(e, n) {
            return function(r, a) {
                return r = r || {}, n && (t.isArrayable(a) || "string" == typeof a.target) ? r[""] = e(r[""], a, "") : t.each(a, function(t, n) {
                    r[n] = e(r[n], t, n);
                }), r;
            };
        }, t.validateListenersImplemented = function(e) {
            var n = [];
            return t.each(e.events, function(r, a) {
                t.each(r.sortedListeners, function(r) {
                    r.listener !== t.notImplemented && "fluid.notImplemented" !== r.listener.globalName || n.push({
                        name: a,
                        namespace: r.namespace,
                        componentSource: t.model.getSimple(e.options.listeners, [ a + "." + r.namespace, 0, "componentSource" ])
                    });
                });
            }), n;
        }, t.unique = function(e) {
            return t.remove_if(e, function(t, n) {
                return !t || n > 0 && t === e[n - 1];
            });
        }, t.arrayConcatPolicy = function(e, n) {
            return t.makeArray(e).concat(t.makeArray(n));
        }, t.failureEvent = t.makeEventFirer({
            name: "failure event"
        }), t.failureEvent.addListener(t.builtinFail, "fail"), t.failureEvent.addListener(t.logFailure, "log", "before:fail"), 
        t.pushSoftFailure = function(e) {
            "function" == typeof e ? t.failureEvent.addListener(e, "fail") : -1 === e ? t.failureEvent.removeListener("fail") : "boolean" == typeof e && t.fail("pushSoftFailure with boolean value is no longer supported");
        }, t.componentConstructor = function() {}, t.typeTag = function(e) {
            var n = Object.create(t.componentConstructor.prototype);
            return n.typeName = e, n.id = t.allocateGuid(), n;
        };
        var l = 1, c = {};
        t.defaultsStore = {}, t.resolveGradesImpl = function(e, n) {
            for (var r = (n = t.makeArray(n)).length - 1; r >= 0; --r) {
                var a = n[r];
                if (a && !e.gradeHash[a]) {
                    var o = (t.isIoCReference(a) ? null : t.rawDefaults(a)) || {}, i = c[a] || l - 1;
                    e.lastTick = Math.max(e.lastTick, i), e.gradeHash[a] = !0, e.gradeChain.push(a);
                    for (var u = t.makeArray(o.gradeNames), s = u.length - 1; s >= 0; --s) t.resolveGradesImpl(e, u[s]);
                }
            }
            return e;
        }, t.resolveGradeStructure = function(e, n) {
            var r = {
                lastTick: 0,
                gradeChain: [],
                gradeHash: {}
            };
            return t.resolveGradesImpl(r, [ e ].concat(t.makeArray(n))), r.gradeChain.reverse(), 
            r;
        }, t.hasGrade = function(e, n) {
            return !(!e || !e.gradeNames) && t.contains(e.gradeNames, n);
        }, t.resolveGrade = function(n, r, a) {
            var o = t.resolveGradeStructure(r, a), i = t.transform(o.gradeChain, t.rawDefaults, t.copy);
            t.remove_if(i, function(e) {
                return !e;
            });
            for (var u = {}, s = 0; s < i.length; ++s) i[s] && i[s].mergePolicy && (u = e.extend(!0, u, i[s].mergePolicy));
            i = [ u, {} ].concat(i);
            var l = t.merge.apply(null, i);
            return l.gradeNames = o.gradeChain, t.freezeRecursive(l), {
                defaults: l,
                lastTick: o.lastTick
            };
        }, t.mergedDefaultsCache = {}, t.gradeNamesToKey = function(e, t) {
            return e + "|" + t.join("|");
        }, t.getMergedDefaults = function(e, n) {
            n = t.makeArray(n);
            var r = t.gradeNamesToKey(e, n), a = t.mergedDefaultsCache[r];
            if (a) {
                for (var o = 0, i = a.defaults.gradeNames || [], u = 0; u < i.length; ++u) o = Math.max(o, c[i[u]] || 0);
                o > a.lastTick && (t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Clearing cache for component " + e + " with gradeNames ", i), 
                a = null);
            }
            if (!a) {
                var s = t.rawDefaults(e);
                if (!s) return s;
                a = t.mergedDefaultsCache[r] = t.resolveGrade(s, e, n);
            }
            return a.defaults;
        }, t.upgradePrimitiveFunc = function(e, n) {
            if (e && t.isPrimitive(e)) {
                var r = {};
                return r[n || ("string" == typeof e && "{" !== e.charAt(0) ? "funcName" : "func")] = e, 
                r.args = t.NO_VALUE, r;
            }
            return e;
        }, t.annotateListeners = function(e, n) {
            n.listeners = t.transform(n.listeners, function(n) {
                var r = t.makeArray(n);
                return t.transform(r, function(n) {
                    return n = t.upgradePrimitiveFunc(n, "listener"), n.componentSource = e, n;
                });
            }), n.invokers = t.transform(n.invokers, function(n) {
                return (n = t.upgradePrimitiveFunc(n)) && (n.componentSource = e), n;
            });
        }, t.rawDefaults = function(e) {
            var n = t.defaultsStore[e];
            return n && n.options;
        }, t.registerRawDefaults = function(e, n) {
            t.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options", {
                componentName: e,
                options: n
            });
            var r = t.expandCompact ? t.expandCompact(n) : t.copy(n);
            t.annotateListeners(e, r);
            var a = t.getCallerInfo && t.getCallerInfo(6);
            t.defaultsStore[e] = {
                options: r,
                callerInfo: a
            }, c[e] = l++, t.popActivity();
        }, t.doIndexDefaults = function(e, n, r, a) {
            for (var o = t.makeArray(a.gradeNames), i = 0; i < o.length; ++i) if (!t.hasGrade(n, o[i])) return;
            for (var u = ("function" == typeof a.indexFunc ? a.indexFunc : t.getGlobalValue(a.indexFunc))(n) || [], s = 0; s < u.length; ++s) t.pushArray(r, u[s], e);
        }, t.indexDefaults = function(e, n) {
            var r = {};
            for (var a in t.defaultsStore) {
                var o = t.getMergedDefaults(a);
                t.doIndexDefaults(a, o, r, n);
            }
            return r;
        }, t.defaults = function(e, n) {
            if (void 0 === n) return t.getMergedDefaults(e);
            n && n.options && t.fail("Probable error in options structure for " + e + ' with option named "options" - perhaps you meant to write these options at top level in fluid.defaults? - ', n), 
            t.registerRawDefaults(e, n);
            var r = t.getMergedDefaults(e);
            t.hasGrade(r, "fluid.function") || t.makeComponentCreator(e);
        }, t.makeComponentCreator = function(n) {
            var r = function() {
                var e = t.getMergedDefaults(n);
                if (e.gradeNames && 0 !== e.gradeNames.length) {
                    if (e.initFunction) return t.initComponent(n, arguments);
                    for (var r = [], a = 0; a < e.gradeNames.length; ++a) {
                        var o = e.gradeNames[a];
                        t.rawDefaults(o) || r.push(o);
                    }
                    0 === r.length ? t.fail("Cannot make component creator for type " + n + " which does not have an initFunction defined") : t.fail("The grade hierarchy of component with type " + n + " is incomplete - it inherits from the following grade(s): " + r.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these grades and ensure they are readable and have been loaded by this instance of Infusion");
                } else t.fail("Cannot make component creator for type " + n + " which does not have any gradeNames defined");
            }, a = t.getGlobalValue(n);
            a && e.extend(r, a), t.setGlobalValue(n, r);
        }, t.emptyPolicy = t.freezeRecursive({}), t.derefMergePolicy = function(e) {
            return (e ? e["*"] : t.emptyPolicy) || t.emptyPolicy;
        }, t.compileMergePolicy = function(e) {
            var n = {}, r = {}, a = {
                builtins: n,
                defaultValues: r
            };
            return e ? (t.each(e, function(e, o) {
                var i = {}, u = !0;
                if ("function" == typeof e) i.func = e; else if ("object" == typeof e) i = e; else if (t.isDefaultValueMergePolicy(e)) t.set(r, o, "{that}.options." + e), 
                a.hasDefaults = !0, u = !1; else for (var s = e.split(/\s*,\s*/), l = 0; l < s.length; ++l) i[s[l]] = !0;
                u && t.set(n, t.composePath(o, "*"), i);
            }), a) : a;
        }, t.isDefaultValueMergePolicy = function(e) {
            return "string" == typeof e && -1 === e.indexOf(",") && !/replace|nomerge|noexpand/.test(e);
        }, t.mergeOneImpl = function(e, n, r, a, o, i, u) {
            var s = e, l = t.isPrimitive(e);
            return void 0 !== n && (o.func || null === n || !t.isPlainObject(n) || o.nomerge ? (a[r] = void 0, 
            s = o.func ? o.func.call(null, e, n, u[i - 1], u, i) : n) : l && (s = e = t.freshContainer(n))), 
            s;
        }, t.fetchMergeChildren = function(e, n, r, a, o, i) {
            for (var u = t.derefMergePolicy(o), s = a.length - 1; s >= 0; --s) {
                var l = a[s];
                if (void 0 !== l && (t.each(l, function(u, s) {
                    var l = t.concreteTrundler(o, s);
                    s in e && (!i.evaluateFully || void 0 !== l || t.isPrimitive(e[s])) || (r[n] = s, 
                    i.strategy(e, s, n + 1, r, a, o));
                }), u.replace)) break;
            }
            return e;
        }, t.inEvaluationMarker = Object.freeze({
            __CURRENTLY_IN_EVALUATION__: !0
        }), t.strategyRecursionBailout = 50, t.makeMergeStrategy = function(e) {
            var n = function(n, o, i, u, s, l) {
                if (i > t.strategyRecursionBailout && t.fail("Overflow/circularity in options merging, current path is ", u, " at depth ", i, ' - please protect components from merging using the "nomerge" merge policy'), 
                !t.isPrimitive(n)) {
                    t.isTracing && t.tracing.pathCount.push(t.path(u.slice(0, i)));
                    var c;
                    if (o in n) {
                        if (c = n[o], !e.evaluateFully) return c;
                    } else n !== t.inEvaluationMarker && (n[o] = t.inEvaluationMarker);
                    void 0 === s && (u = t.makeArray(u), s = a(e.sources, u, i - 1, e.sourceStrategies), 
                    l = r(e.mergePolicy, u, i - 1, t.concreteTrundler));
                    var d, f, p, m = t.concreteTrundler(l, o), g = t.derefMergePolicy(m);
                    g.replace ? (d = 1 - s.length, f = 0, p = -1) : (d = 0, f = s.length - 1, p = 1);
                    for (var h, v = [], y = d; y <= f; ++y) {
                        var b = p * y, k = e.sourceStrategies[b](s[b], o, i, u);
                        if (void 0 !== k && (t.isPrimitive(k) || (v[b] = k), void 0 === c)) {
                            if (-1 === p) {
                                h = n[o] = k;
                                break;
                            }
                            h = t.mergeOneImpl(h, k, y, v, g, i, u, e), n !== t.inEvaluationMarker && (n[o] = h);
                        }
                    }
                    return void 0 !== c && (h = c), v.length > 0 && t.isPlainObject(h) && t.fetchMergeChildren(h, i, u, v, m, e), 
                    void 0 === c && 0 === v.length && delete n[o], h;
                }
            };
            return e.strategy = n, n;
        }, t.driveStrategy = function(e, n, r) {
            n = t.makeArray(n);
            for (var a = 0; a < n.length; ++a) {
                if (!e) return;
                e = r(e, n[a], a + 1, n);
            }
            return e;
        }, t.concreteTrundler = function(e, t) {
            return e ? e[t] : void 0;
        }, t.merge = function(e) {
            var n = Array.prototype.slice.call(arguments, 1), r = t.compileMergePolicy(e).builtins, a = t.makeMergeOptions(r, n, {});
            return a.initter(), a.target;
        }, t.simpleGingerBlock = function(e, n) {
            return {
                target: e,
                simple: !0,
                strategy: t.concreteTrundler,
                initter: t.identity,
                recordType: n,
                priority: t.mergeRecordTypes[n]
            };
        }, t.makeMergeOptions = function(n, r, a) {
            var o = {
                mergePolicy: n,
                sources: r
            };
            return o = e.extend(o, a), o.target = o.target || t.freshContainer(o.sources[0]), 
            o.sourceStrategies = o.sourceStrategies || t.generate(o.sources.length, t.concreteTrundler), 
            o.initter = function() {
                o.evaluateFully = !0, t.fetchMergeChildren(o.target, 0, [], o.sources, o.mergePolicy, o);
            }, t.makeMergeStrategy(o), o;
        }, t.transformOptions = function(e, n) {
            return t.expect("Options transformation record", n, [ "transformer", "config" ]), 
            t.getGlobalValue(n.transformer).call(null, e, n.config);
        }, t.findMergeBlocks = function(e, n) {
            return t.remove_if(t.makeArray(e), function(e) {
                return e.recordType !== n;
            });
        }, t.transformOptionsBlocks = function(e, n, r) {
            t.each(r, function(r) {
                var a = t.findMergeBlocks(e, r);
                t.each(a, function(e) {
                    var r = e.source ? "source" : "target";
                    e[e.simple || "target" === r ? "target" : "source"] = t.transformOptions(e[r], n);
                });
            });
        }, t.dedupeDistributionNamespaces = function(e) {
            var n = {};
            t.remove_if(e, function(e) {
                var t = e.namespace;
                if (t) {
                    if (n[t] && n[t] !== e.contextThat.id) return !0;
                    n[t] = e.contextThat.id;
                }
            });
        }, t.deliverOptionsStrategy = t.identity, t.computeComponentAccessor = t.identity, 
        t.computeDynamicComponents = t.identity, t.mergeRecordTypes = {
            defaults: 1e3,
            defaultValueMerge: 900,
            subcomponentRecord: 800,
            user: 700,
            distribution: 100
        }, t.model.applyChangeRequest = function(n, r) {
            var a = r.segs;
            if (0 === a.length) "ADD" === r.type ? e.extend(!0, n, r.value) : t.clear(n); else if ("ADD" === r.type) t.model.setSimple(n, r.segs, r.value); else {
                for (var o = 0; o < a.length - 1; ++o) if (!(n = n[a[o]])) return;
                delete n[a[a.length - 1]];
            }
        }, t.destroyValue = function(e, n) {
            e && t.model.applyChangeRequest(e, {
                type: "DELETE",
                segs: n
            });
        }, t.mergeComponentOptions = function(n, r, a, o) {
            function i() {
                y = t.driveStrategy(d, "mergePolicy", h.strategy), y = e.extend({}, t.rootMergePolicy, y), 
                v = t.compileMergePolicy(y), e.extend(!0, l, v.builtins);
            }
            var u = t.rawDefaults(r), s = t.getMergedDefaults(r, u && u.gradeNames ? null : o.gradeNames), l = {}, c = [];
            c = t.expandComponentOptions ? c.concat(t.expandComponentOptions(l, s, a, n)) : c.concat([ t.simpleGingerBlock(s, "defaults"), t.simpleGingerBlock(a, "user") ]);
            var d = {}, f = [], p = [], m = {
                target: d,
                sourceStrategies: f
            }, g = function() {
                t.each(c, function(e) {
                    t.isPrimitive(e.priority) && (e.priority = t.parsePriority(e.priority, 0, !1, "options distribution"));
                }), t.sortByPriority(c), t.dedupeDistributionNamespaces(c), f.length = 0, p.length = 0, 
                t.each(c, function(e) {
                    f.push(e.strategy), p.push(e.target);
                });
            };
            g();
            var h = t.makeMergeOptions(l, p, m);
            h.mergeBlocks = c, h.updateBlocks = g, h.destroyValue = function(e) {
                for (var n = 0; n < c.length; ++n) c[n].immutableTarget || t.destroyValue(c[n].target, e);
                t.destroyValue(m.target, e);
            };
            var v, y;
            i(), h.computeMergePolicy = i, v.hasDefaults && (t.generateExpandBlock ? (c.push(t.generateExpandBlock({
                options: v.defaultValues,
                recordType: "defaultValueMerge",
                priority: t.mergeRecordTypes.defaultValueMerge
            }, n, {})), g()) : t.fail("Cannot operate mergePolicy ", y, " for component ", n, " without including FluidIoC.js")), 
            n.options = d, t.driveStrategy(d, "gradeNames", h.strategy), t.deliverOptionsStrategy(n, d, h), 
            t.computeComponentAccessor(n, a && a.localRecord);
            var b = t.driveStrategy(d, "transformOptions", h.strategy);
            return b && (t.transformOptionsBlocks(c, b, [ "user", "subcomponentRecord" ]), g()), 
            m.target.mergePolicy || i(), h;
        }, t.defaults("fluid.function", {}), t.invokeGradedFunction = function(e, n) {
            var r = t.defaults(e);
            r && r.argumentMap && t.hasGrade(r, "fluid.function") || t.fail("Cannot look up name " + e + " to a function with registered argumentMap - got defaults ", r);
            var a = [];
            return t.each(r.argumentMap, function(e, t) {
                a[e] = n[t];
            }), t.invokeGlobalFunction(e, a);
        }, t.noNamespaceDistributionPrefix = "no-namespace-distribution-", t.mergeOneDistribution = function(n, r, a) {
            var o = r.namespace || a || t.noNamespaceDistributionPrefix + t.allocateGuid();
            r.namespace = o, n[o] = e.extend(!0, {}, n[o], r);
        }, t.distributeOptionsPolicy = function(e, n) {
            if (e = e || {}, t.isArrayable(n)) for (var r = 0; r < n.length; ++r) t.mergeOneDistribution(e, n[r]); else "string" == typeof n.target ? t.mergeOneDistribution(e, n) : t.each(n, function(n, r) {
                t.mergeOneDistribution(e, n, r);
            });
            return e;
        }, t.mergingArray = function() {}, t.mergingArray.prototype = [], t.membersMergePolicy = function(e, n) {
            return e = e || {}, t.each(n, function(n, r) {
                e[r] || (e[r] = new t.mergingArray()), n instanceof t.mergingArray ? e[r].push.apply(e[r], n) : void 0 !== n && e[r].push(n);
            }), e;
        }, t.invokerStrategies = t.arrayToHash([ "func", "funcName", "listener", "this", "method", "changePath", "value" ]), 
        t.invokersMergePolicy = function(n, r) {
            return n = n || {}, t.each(r, function(r, a) {
                if (r) {
                    r = t.upgradePrimitiveFunc(r);
                    var o = n[a];
                    o || (o = n[a] = {});
                    for (var i in t.invokerStrategies) if (i in r) for (var u in t.invokerStrategies) o[u] = void 0;
                    e.extend(o, r);
                } else n[a] = r;
            }), n;
        }, t.rootMergePolicy = {
            gradeNames: t.arrayConcatPolicy,
            distributeOptions: t.distributeOptionsPolicy,
            members: {
                noexpand: !0,
                func: t.membersMergePolicy
            },
            invokers: {
                noexpand: !0,
                func: t.invokersMergePolicy
            },
            transformOptions: "replace",
            listeners: t.makeMergeListenersPolicy(t.mergeListenerPolicy)
        }, t.defaults("fluid.component", {
            initFunction: "fluid.initLittleComponent",
            mergePolicy: t.rootMergePolicy,
            argumentMap: {
                options: 0
            },
            events: {
                onCreate: null,
                onDestroy: null,
                afterDestroy: null
            }
        }), t.defaults("fluid.emptySubcomponent", {
            gradeNames: [ "fluid.component" ]
        }), t.computeNickName = function(e) {
            var n = t.model.parseEL(e);
            return n[n.length - 1];
        }, t.defaults("fluid.typeFount", {
            gradeNames: [ "fluid.component" ]
        }), t.initLittleComponent = function(e, n, r, a) {
            var o = t.typeTag(e);
            o.lifecycleStatus = "constructing", r = r || {
                gradeNames: "fluid.component"
            }, o.destroy = t.makeRootDestroy(o);
            var i = t.mergeComponentOptions(o, e, n, r);
            i.exceptions = {
                members: {
                    model: !0,
                    modelRelay: !0
                }
            };
            var u = o.options;
            o.events = {}, (a || t.identity)(o, u, i.strategy), t.computeDynamicComponents(o, i);
            for (var s = 0; s < i.mergeBlocks.length; ++s) i.mergeBlocks[s].initter();
            return i.initter(), delete u.mergePolicy, t.instantiateFirers(o, u), t.mergeListeners(o, o.events, u.listeners), 
            o;
        }, t.diagnoseFailedView = t.identity, t.makeRootDestroy = function(e) {
            return function() {
                t.doDestroy(e), t.fireEvent(e, "afterDestroy", [ e, "", null ]);
            };
        }, t.isDestroyed = function(e) {
            return "destroyed" === e.lifecycleStatus;
        }, t.doDestroy = function(e, n, r) {
            t.fireEvent(e, "onDestroy", [ e, n || "", r ]), e.lifecycleStatus = "destroyed";
            for (var a in e.events) "afterDestroy" !== a && "function" == typeof e.events[a].destroy && e.events[a].destroy();
            e.applier && e.applier.destroy();
        }, t.initComponent = function(e, n) {
            var r = t.defaults(e);
            r.gradeNames || t.fail("Cannot initialise component " + e + " which has no gradeName registered");
            var a, o = [ e ].concat(t.makeArray(n));
            t.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs", {
                componentName: e,
                initArgs: n
            }), a = t.invokeGlobalFunction(r.initFunction, o), t.diagnoseFailedView(e, a, r, o), 
            t.initDependents && t.initDependents(a);
            var i = t.validateListenersImplemented(a);
            return i.length > 0 && t.fail(t.transform(i, function(e) {
                return [ "Error constructing component ", a, " - the listener for event " + e.name + " with namespace " + e.namespace + (e.componentSource ? " which was defined in grade " + e.componentSource : "") + " needs to be overridden with a concrete implementation" ];
            })).join("\n"), "constructing" === a.lifecycleStatus && (a.lifecycleStatus = "constructed"), 
            a.events.onCreate.fire(a), t.popActivity(), a;
        }, t.initSubcomponentImpl = function(e, n, r) {
            var a;
            if ("function" != typeof n) {
                var o = "string" == typeof n ? n : n.type;
                a = "fluid.emptySubcomponent" === o ? null : t.invokeGlobalFunction(o, r);
            } else a = n.apply(null, r);
            return a;
        };
        t.simpleCSSMatcher = {
            regexp: new RegExp("([#.]?)((?:[\\w\\u00c0-\\uFFFF*_-]|\\\\.)+)", "g"),
            charToTag: {
                "": "tag",
                "#": "id",
                ".": "clazz"
            }
        }, t.IoCSSMatcher = {
            regexp: new RegExp("([&#]?)((?:[\\w\\u00c0-\\uFFFF*_-]|\\.|\\/)+)", "g"),
            charToTag: {
                "": "context",
                "&": "context",
                "#": "id"
            }
        };
        var d = new RegExp("\\s*(>)?\\s*", "g");
        t.parseSelector = function(e, n) {
            var r = [];
            e = e.trim();
            var a = n.regexp;
            a.lastIndex = 0;
            for (var o = 0; ;) {
                for (var i = [], u = !0; ;) {
                    var s = a.exec(e);
                    if (!s) break;
                    if (s.index !== o) {
                        if (!u) break;
                        t.fail("Error in selector string - cannot match child selector expression starting at " + e.substring(o));
                    }
                    var l = {}, c = s[2], f = n.charToTag[s[1]];
                    f && (l[f] = c), i[i.length] = l, o = a.lastIndex, u = !1;
                }
                d.lastIndex = o;
                var p = {
                    predList: i
                }, m = d.exec(e);
                if (m && m.index === o || t.fail("Error in selector string - can not match child selector expression at " + e.substring(o)), 
                ">" === m[1] && (p.child = !0), r[r.length] = p, d.lastIndex >= e.length) break;
                o = d.lastIndex, a.lastIndex = d.lastIndex;
            }
            return r;
        }, t.stringToRegExp = function(e, t) {
            return new RegExp(e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), t);
        }, t.stringTemplate = function(e, n) {
            var r = t.keys(n);
            r = r.sort(t.compareStringLength());
            for (var a = 0; a < r.length; ++a) {
                var o = r[a], i = t.stringToRegExp("%" + o, "g");
                e = e.replace(i, n[o]);
            }
            return e;
        };
    }(t, n);
    var n = n || {}, r = r || n;
    !function(e, t) {
        "use strict";
        function n(e, r, a) {
            function o(e) {
                a.output += e;
            }
            var i = r + a.indentChars, u = "function" == typeof e;
            if (void 0 !== a.maxRenderChars && a.output.length > a.maxRenderChars) return !0;
            if (null === e) o("null"); else if (void 0 === e) o("undefined"); else if (e === t.SYNTHETIC_PROPERTY) o("[Synthetic property]"); else if (t.isPrimitive(e) && !u) o(JSON.stringify(e)); else {
                if (-1 !== a.stack.indexOf(e)) return void o("(CIRCULAR)");
                a.stack.push(e);
                var s;
                if (t.isArrayable(e)) if (0 === e.length) o("[]"); else {
                    for (o("[\n" + i), s = 0; s < e.length; ++s) {
                        if (n(e[s], i, a)) return !0;
                        s !== e.length - 1 && o(",\n" + i);
                    }
                    o("\n" + r + "]");
                } else {
                    o("{" + (u ? " Function" : "") + "\n" + i);
                    var l = t.keys(e);
                    for (s = 0; s < l.length; ++s) {
                        var c = l[s], d = t.getSafeProperty(e, c);
                        if (o(JSON.stringify(c) + ": "), n(d, i, a)) return !0;
                        s !== l.length - 1 && o(",\n" + i);
                    }
                    o("\n" + r + "}");
                }
                a.stack.pop();
            }
        }
        t.renderTimestamp = function(e) {
            var t = function(e, t) {
                t || (t = 2);
                var n = void 0 === e ? "" : e.toString();
                return "00000".substring(5 - t + n.length) + n;
            };
            return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + t(e.getMilliseconds(), 3);
        }, t.isTracing = !1, t.registerNamespace("fluid.tracing"), t.tracing.pathCount = [], 
        t.tracing.summarisePathCount = function(e) {
            e = e || t.tracing.pathCount;
            for (var n = {}, r = 0; r < e.length; ++r) {
                var a = e[r];
                n[a] ? ++n[a] : n[a] = 1;
            }
            var o = [];
            return t.each(n, function(e, t) {
                o.push({
                    path: t,
                    count: e
                });
            }), o.sort(function(e, t) {
                return t.count - e.count;
            }), o;
        }, t.tracing.condensePathCount = function(e, n) {
            e = t.makeArray(e);
            var r = {};
            t.each(e, function(e) {
                r[e] = 0;
            });
            var a = [];
            return t.each(n, function(n) {
                var o = n.path;
                t.find(e, function(e) {
                    if (0 === o.indexOf(e)) return r[e] += n.count, !0;
                }) || a.push(n);
            }), t.each(r, function(e, t) {
                a.unshift({
                    path: t,
                    count: e
                });
            }), a;
        }, t.detectStackStyle = function(e) {
            var t = "other", n = {
                offset: 0
            };
            return e.arguments ? t = "chrome" : "undefined" != typeof window && window.opera && e.stacktrace ? t = "opera10" : e.stack ? (t = "firefox", 
            n.offset = -1 === e.stack.indexOf("Trace exception") ? 1 : 0) : "undefined" == typeof window || !window.opera || "stacktrace" in e || (t = "opera"), 
            n.style = t, n;
        }, t.obtainException = function() {
            try {
                throw new Error("Trace exception");
            } catch (e) {
                return e;
            }
        };
        var r = t.detectStackStyle(t.obtainException());
        t.registerNamespace("fluid.exceptionDecoders"), t.decodeStack = function() {
            if ("firefox" !== r.style) return null;
            var e = t.obtainException();
            return t.exceptionDecoders[r.style](e);
        }, t.exceptionDecoders.firefox = function(e) {
            var n = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
            return t.transform(n, function(e) {
                var t = (e = e.replace(/\)/g, "")).indexOf("at ");
                return -1 === t ? [ e ] : [ e.substring(t + "at ".length), e.substring(0, t) ];
            });
        }, t.getCallerInfo = function(e) {
            e = (e || 3) - r.offset;
            var n = t.decodeStack(), a = n && n[e][0];
            if (a) {
                var o = a.lastIndexOf("/");
                -1 === o && (o = 0);
                var i = a.indexOf(":", o);
                return {
                    path: a.substring(0, o),
                    filename: a.substring(o + 1, i),
                    index: a.substring(i + 1)
                };
            }
            return null;
        }, t.generatePadding = function(e, t) {
            for (var n = "", r = 0; r < t; ++r) n += e;
            return n;
        }, t.SYNTHETIC_PROPERTY = Object.freeze({}), t.getSafeProperty = function(e, n) {
            var r = Object.getOwnPropertyDescriptor(e, n);
            return r && !r.get ? e[n] : t.SYNTHETIC_PROPERTY;
        }, t.prettyPrintJSON = function(r, a) {
            return a = e.extend({
                indent: 4,
                stack: [],
                output: ""
            }, a), a.indentChars = t.generatePadding(" ", a.indent), n(r, "", a), a.output;
        }, t.dumpEl = function(n) {
            var r;
            if (!n) return "null";
            if (3 === n.nodeType || 8 === n.nodeType) return "[data: " + n.data + "]";
            if (9 === n.nodeType) return "[document: location " + n.location + "]";
            if (!n.nodeType && t.isArrayable(n)) {
                r = "[";
                for (var a = 0; a < n.length; ++a) r += t.dumpEl(n[a]), a < n.length - 1 && (r += ", ");
                return r + "]";
            }
            return n = e(n), r = n.get(0).tagName, n.id && (r += "#" + n.id), n.attr("class") && (r += "." + n.attr("class")), 
            r;
        };
    }(t, n), function(e, t) {
        "use strict";
        function n(e, n, r, a) {
            for (var o = 0; o < r; ++o) e = a(e, n[o], o, t.makeArray(n));
            return e;
        }
        t.visitComponentChildren = function(e, n, r, a) {
            a = a || [];
            for (var o in e) {
                var i = e[o];
                if (!(!t.isComponent(i) || r.visited && r.visited[i.id])) {
                    if (a.push(o), r.visited && (r.visited[i.id] = !0), n(i, o, a, a.length - 1)) return !0;
                    r.flat || t.visitComponentChildren(i, n, r, a), a.pop();
                }
            }
        }, t.getContextHash = function(e, t) {
            var n = e.idToShadow[t.id];
            return n && n.contextHash;
        }, t.componentHasGrade = function(e, n) {
            var r = t.getContextHash(t.globalInstantiator, e);
            return !(!r || !r[n]);
        }, t.visitComponentsForMatching = function(n, r, a) {
            var o = t.getInstantiator(n);
            r = e.extend({
                visited: {},
                instantiator: o
            }, r);
            var i = [ n ], u = [ t.getContextHash(o, n) ];
            t.visitComponentChildren(n, function(e, n, r) {
                i.length = 1, u.length = 1;
                for (var s = 0; s < r.length; ++s) {
                    var l = i[s][r[s]];
                    i[s + 1] = l, u[s + 1] = t.getContextHash(o, l) || {};
                }
                return a(e, i, u, r, r.length);
            }, r, []);
        }, t.getMemberNames = function(e, n) {
            if (0 === n.length) return [];
            var r = e.idToPath(n[n.length - 1].id), a = e.parseEL(r);
            return a.unshift.apply(a, t.generate(n.length - a.length, "")), a;
        }, t.visitComponentsForVisibility = function(e, n, r, a) {
            a = a || {
                visited: {},
                flat: !0,
                instantiator: e
            };
            for (var o = t.getMemberNames(e, n), i = n.length - 1; i >= 0; --i) {
                var u = n[i];
                if (a.visited[u.id] = !0, r(u, o[i], o, i)) return;
                if (t.visitComponentChildren(u, r, a, o)) return;
                o.pop();
            }
        }, t.mountStrategy = function(e, t, n) {
            var r = e.length;
            return function(t, a, o, i) {
                if (!(o <= e.length)) {
                    for (var u = 0; u < e.length; ++u) if (i[u] !== e[u]) return;
                    return n(t, a, o - e.length, i.slice(r));
                }
            };
        }, t.invokerFromRecord = function(e, n, r) {
            t.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that", {
                name: n,
                record: e,
                that: r
            });
            var a = e ? t.makeInvoker(r, e, n) : void 0;
            return t.popActivity(), a;
        }, t.memberFromRecord = function(n, r, a) {
            for (var o, i = 0; i < n.length; ++i) {
                var u = t.expandImmediate(n[i], a);
                o = t.isPlainObject(o) ? e.extend(!0, o, u) : u;
            }
            return o;
        }, t.recordStrategy = function(e, n, r, a, o, i, u) {
            return i = i || [], {
                strategy: function(i, u, s) {
                    if (1 === s) {
                        var l = t.driveStrategy(n, [ a, u ], r);
                        if (void 0 !== l) {
                            t.set(i, [ u ], t.inEvaluationMarker);
                            var c = o(l, u, e);
                            return t.set(i, [ u ], c), c;
                        }
                    }
                },
                initter: function() {
                    var o = t.driveStrategy(n, a, r) || {};
                    for (var s in o) u && u[s] || t.getForComponent(e, i.concat([ s ]));
                }
            };
        }, t.instantiateFirers = function(e) {
            var n = t.shadowForComponent(e);
            (t.get(n, [ "eventStrategyBlock", "initter" ]) || t.identity)();
        }, t.makeDistributionRecord = function(n, r, a, o, i, u) {
            u = u || "distribution", t.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {
                sourceRecord: r,
                sourcePath: a,
                targetSegs: o
            });
            var s = t.copy(t.get(r, a));
            t.each(i, function(e) {
                t.model.applyChangeRequest(s, {
                    segs: e,
                    type: "DELETE"
                });
            });
            var l = {
                options: {}
            };
            return t.model.applyChangeRequest(l, {
                segs: o,
                type: "ADD",
                value: s
            }), t.checkComponentRecord(l), t.popActivity(), e.extend(l, {
                contextThat: n,
                recordType: u
            });
        }, t.filterBlocks = function(n, r, a, o, i, u) {
            var s = [];
            return t.each(r, function(r) {
                var l = t.get(r.source, a);
                if (void 0 !== l) {
                    s.push(t.makeDistributionRecord(n, r.source, a, o, i, r.recordType));
                    var c = e.extend({}, l);
                    u && t.model.applyChangeRequest(r.source, {
                        segs: a,
                        type: "DELETE"
                    }), t.each(i, function(e) {
                        var n = t.get(c, e);
                        t.set(r.source, a.concat(e), n);
                    });
                }
            }), s;
        }, t.noteCollectedDistribution = function(e, n, r) {
            t.model.setSimple(e, [ "collectedDistributions", n, r.id ], !0);
        }, t.isCollectedDistribution = function(e, n, r) {
            return t.model.getSimple(e, [ "collectedDistributions", n, r.id ]);
        }, t.clearCollectedDistributions = function(e, n) {
            t.model.applyChangeRequest(e, {
                segs: [ "collectedDistributions", n ],
                type: "DELETE"
            });
        }, t.collectDistributions = function(e, n, r, a, o, i, u) {
            var s = i[i.length - 1];
            !t.isCollectedDistribution(n, s, r) && t.matchIoCSelector(r.selector, a, o, i, u) && (e.push.apply(e, r.blocks), 
            t.noteCollectedDistribution(n, s, r));
        }, t.registerCollectedClearer = function(e, n, r) {
            !e.collectedClearer && n && (e.collectedClearer = function() {
                t.clearCollectedDistributions(n, r);
            });
        }, t.receiveDistributions = function(e, n, r, a) {
            var o = t.getInstantiator(e || a), i = o.getThatStack(e || a);
            i.unshift(t.rootComponent);
            var u = t.getMemberNames(o, i), s = t.transform(i, function(e) {
                return o.idToShadow[e.id];
            }), l = s[s.length - (e ? 1 : 2)], c = t.getMembers(s, "contextHash");
            e ? (u.push(r), c.push(t.gradeNamesToHash(n)), i.push(a)) : t.registerCollectedClearer(s[s.length - 1], l, u[u.length - 1]);
            for (var d = [], f = 0; f < i.length - 1; ++f) t.each(s[f].distributions, function(e) {
                t.collectDistributions(d, l, e, i, c, u, f);
            });
            return d;
        }, t.computeTreeDistance = function(e, t) {
            for (var n = 0; n < e.length && n < t.length && e[n] === t[n]; ) ++n;
            return e.length + t.length - 2 * n;
        }, t.computeDistributionPriority = function(e, n) {
            if (!n.priority) {
                var r = t.getInstantiator(e), a = r.getThatStack(e), o = t.getMemberNames(r, a), i = r.getThatStack(n.contextThat), u = t.getMemberNames(r, i), s = t.computeTreeDistance(o, u);
                n.priority = t.mergeRecordTypes.distribution - s;
            }
            return n;
        }, t.applyDistributions = function(e, n, r) {
            var a = t.transform(n, function(n) {
                return t.generateExpandBlock(n, e, r.mergePolicy);
            }, function(n) {
                return t.computeDistributionPriority(e, n);
            }), o = r.mergeOptions;
            return o.mergeBlocks.push.apply(o.mergeBlocks, a), o.updateBlocks(), a;
        }, t.matchIoCSelector = function(e, t, n, r, a) {
            for (var o = t.length - 1, i = e.length - 1; ;) {
                for (var u = o === t.length - 1 || e[i].child, s = t[o], l = e[i], c = !0, d = 0; d < l.predList.length; ++d) {
                    var f = l.predList[d];
                    if (f.context && !n[o][f.context] && r[o] !== f.context) {
                        c = !1;
                        break;
                    }
                    if (f.id && s.id !== f.id) {
                        c = !1;
                        break;
                    }
                }
                if (0 === i && o > a && u && (c = !1), c) {
                    if (0 === i) return !0;
                    --o, --i;
                } else {
                    if (u) return !1;
                    --o;
                }
                if (o < a) return !1;
            }
        }, t.queryIoCSelector = function(e, n, r) {
            var a = t.parseSelector(n, t.IoCSSMatcher), o = [];
            return t.visitComponentsForMatching(e, {
                flat: r
            }, function(e, n, r, i, u) {
                t.matchIoCSelector(a, n, r, i, u) && o.push(e);
            }), o;
        }, t.isIoCSSSelector = function(e) {
            return -1 !== e.indexOf(" ");
        }, t.pushDistributions = function(e, n, r, a) {
            var o = t.shadowForComponent(e), i = t.allocateGuid(), u = {
                id: i,
                target: r,
                selector: n,
                blocks: a
            };
            return Object.freeze(u), Object.freeze(u.blocks), t.pushArray(o, "distributions", u), 
            i;
        }, t.clearDistribution = function(e, n) {
            var r = t.globalInstantiator.idToShadow[e];
            r && t.remove_if(r.distributions, function(e) {
                return e.id === n;
            });
        }, t.clearDistributions = function(e) {
            t.each(e.outDistributions, function(e) {
                t.clearDistribution(e.targetHeadId, e.distributionId);
            });
        }, t.extractSelectorHead = function(e) {
            var t = e[0].predList, n = t[0].context;
            return t.length = 0, n;
        }, t.parseExpectedOptionsPath = function(e, n) {
            var r = t.model.parseEL(e);
            return "options" !== r[0] && t.fail("Error in options distribution path ", e, " - only " + n + ' paths beginning with "options" are supported'), 
            r.slice(1);
        }, t.replicateProperty = function(e, n, r) {
            void 0 !== e[n] && t.each(r, function(t) {
                t[n] = e[n];
            });
        }, t.undistributableOptions = [ "gradeNames", "distributeOptions", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions" ], 
        t.distributeOptions = function(e, n) {
            var r = t.shadowForComponent(e), a = t.driveStrategy(e.options, "distributeOptions", n);
            t.each(a, function(n) {
                t.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {
                    that: e,
                    record: n
                }), "string" != typeof n.target && t.fail("Error in options distribution record ", n, ' a member named "target" must be supplied holding an IoC reference'), 
                "string" == typeof n.source ^ void 0 === n.record && t.fail("Error in options distribution record ", n, ': must supply either a member "source" holding an IoC reference or a member "record" holding a literal record');
                var a, o, i, u = t.parseContextReference(n.target);
                if (t.isIoCSSSelector(u.context)) {
                    o = t.parseSelector(u.context, t.IoCSSMatcher);
                    var s = t.extractSelectorHead(o);
                    "/" === s ? a = t.rootComponent : i = s;
                } else i = u.context;
                (a = a || t.resolveContext(i, e)) || t.fail("Error in options distribution record ", n, " - could not resolve context {" + i + "} to a head component");
                var l, c = t.model.parseEL(u.path);
                if (void 0 !== n.record) l = [ t.makeDistributionRecord(e, n.record, [], c, []) ]; else {
                    var d = t.parseContextReference(n.source);
                    "that" !== d.context && t.fail("Error in options distribution record ", n, " only a context of {that} is supported");
                    var f = t.parseExpectedOptionsPath(d.path, "source"), p = t.makeArray(n.exclusions).concat(0 === f.length ? t.undistributableOptions : []), m = t.transform(p, function(e) {
                        return t.model.parseEL(e);
                    });
                    l = t.filterBlocks(e, r.mergeOptions.mergeBlocks, f, c, m, n.removeSource), r.mergeOptions.updateBlocks();
                }
                if (t.replicateProperty(n, "priority", l), t.replicateProperty(n, "namespace", l), 
                o) {
                    var g = t.pushDistributions(a, o, n.target, l);
                    r.outDistributions = r.outDistributions || [], r.outDistributions.push({
                        targetHeadId: a.id,
                        distributionId: g
                    });
                } else {
                    var h = t.shadowForComponent(a);
                    t.applyDistributions(e, l, h);
                }
                t.popActivity();
            });
        }, t.gradeNamesToHash = function(e) {
            var n = {};
            return t.each(e, function(e) {
                n[e] = !0, n[t.computeNickName(e)] = !0;
            }), n;
        }, t.cacheShadowGrades = function(e, n) {
            var r = t.gradeNamesToHash(e.options.gradeNames);
            r[n.memberName] || (r[n.memberName] = "memberName"), n.contextHash = r, t.each(r, function(t, r) {
                n.ownScope[r] = e, n.parentShadow && "fluid.rootComponent" !== n.parentShadow.that.type && (n.parentShadow.childrenScope[r] = e);
            });
        }, t.deliverOptionsStrategy = function(e, n, r) {
            var a = t.shadowForComponent(e, a);
            t.cacheShadowGrades(e, a), a.mergeOptions = r;
        }, t.collectDistributedGrades = function(e) {
            var n = t.receiveDistributions(null, null, null, e.that);
            if (n.length > 0) {
                var r = t.applyDistributions(e.that, n, e.shadow), a = t.transform(t.getMembers(r, [ "source", "gradeNames" ]), t.makeArray);
                t.accumulateDynamicGrades(e, t.flatten(a));
            }
        }, t.applyDynamicGrades = function(e) {
            e.oldGradeNames = t.makeArray(e.gradeNames);
            var n = t.copy(t.getMergedDefaults(e.that.typeName, e.gradeNames));
            e.gradeNames.length = 0, e.gradeNames.push.apply(e.gradeNames, n.gradeNames), t.each(e.gradeNames, function(n) {
                t.isIoCReference(n) || (e.seenGrades[n] = !0);
            });
            var r = e.shadow;
            t.cacheShadowGrades(e.that, r), r.mergeOptions.destroyValue([ "mergePolicy" ]), 
            r.mergeOptions.destroyValue([ "components" ]), r.mergeOptions.destroyValue([ "invokers" ]), 
            e.defaultsBlock.source = n, r.mergeOptions.updateBlocks(), r.mergeOptions.computeMergePolicy(), 
            t.accumulateDynamicGrades(e, n.gradeNames);
        }, t.accumulateDynamicGrades = function(e, n) {
            t.each(n, function(n) {
                e.seenGrades[n] || (t.isIoCReference(n) ? (e.rawDynamic.push(n), e.seenGrades[n] = !0) : t.contains(e.oldGradeNames, n) || e.plainDynamic.push(n));
            });
        }, t.computeDynamicGrades = function(e, n, r) {
            delete e.options.gradeNames;
            var a = t.driveStrategy(e.options, "gradeNames", r);
            a.length = 0;
            var o = {
                that: e,
                shadow: n,
                defaultsBlock: t.findMergeBlocks(n.mergeOptions.mergeBlocks, "defaults")[0],
                gradeNames: a,
                seenGrades: {},
                plainDynamic: [],
                rawDynamic: []
            };
            for (t.each(n.mergeOptions.mergeBlocks, function(e) {
                a.push.apply(a, t.makeArray(e.target && e.target.gradeNames)), t.applyDynamicGrades(o);
            }), t.collectDistributedGrades(o); ;) {
                for (;o.plainDynamic.length > 0; ) a.push.apply(a, o.plainDynamic), o.plainDynamic.length = 0, 
                t.applyDynamicGrades(o), t.collectDistributedGrades(o);
                if (!(o.rawDynamic.length > 0)) break;
                var i = t.expandImmediate(o.rawDynamic.shift(), e, n.localDynamic);
                "function" == typeof i && (i = i()), i && (o.plainDynamic = o.plainDynamic.concat(i));
            }
            n.collectedClearer && (n.collectedClearer(), delete n.collectedClearer);
        }, t.computeDynamicComponentKey = function(e, t) {
            return e + (0 === t ? "" : "-" + t);
        }, t.registerDynamicRecord = function(e, n, r, a, o) {
            var i = t.computeDynamicComponentKey(n, r), u = t.copy(a);
            return delete u[o], t.set(e.options, [ "components", i ], u), i;
        }, t.computeDynamicComponents = function(e, n) {
            var r = t.shadowForComponent(e), a = r.subcomponentLocal = {}, o = t.driveStrategy(e.options, "dynamicComponents", n.strategy);
            t.each(o, function(n, o) {
                if (n.sources || n.createOnEvent || t.fail("Cannot process dynamicComponents record ", n, ' without a "sources" or "createOnEvent" entry'), 
                n.sources) {
                    var i = t.expandOptions(n.sources, e);
                    t.each(i, function(r, i) {
                        var u = t.registerDynamicRecord(e, o, i, n, "sources");
                        a[u] = {
                            source: r,
                            sourcePath: i
                        };
                    });
                } else if (n.createOnEvent) {
                    var u = t.event.expandOneEvent(e, n.createOnEvent);
                    t.set(r, [ "dynamicComponentCount", o ], 0);
                    var s = function() {
                        var a = t.registerDynamicRecord(e, o, r.dynamicComponentCount[o]++, n, "createOnEvent"), i = {
                            arguments: t.makeArray(arguments)
                        };
                        t.initDependent(e, a, i);
                    };
                    u.addListener(s), t.recordListener(u, s, r);
                }
            });
        }, t.computeComponentAccessor = function(e, n) {
            var r = t.globalInstantiator, a = t.shadowForComponent(e);
            a.localDynamic = n;
            var o = e.options, i = a.mergeOptions.strategy, u = t.mountStrategy([ "options" ], o, i);
            a.invokerStrategy = t.recordStrategy(e, o, i, "invokers", t.invokerFromRecord), 
            a.eventStrategyBlock = t.recordStrategy(e, o, i, "events", t.eventFromRecord, [ "events" ]);
            var s = t.mountStrategy([ "events" ], e, a.eventStrategyBlock.strategy, [ "events" ]);
            if (a.memberStrategy = t.recordStrategy(e, o, i, "members", t.memberFromRecord, null, {
                model: !0,
                modelRelay: !0
            }), a.getConfig = {
                strategies: [ t.model.funcResolverStrategy, t.makeGingerStrategy(e), u, a.invokerStrategy.strategy, a.memberStrategy.strategy, s ]
            }, t.computeDynamicGrades(e, a, i, a.mergeOptions.mergeBlocks), t.distributeOptions(e, i), 
            a.contextHash["fluid.resolveRoot"]) {
                var l;
                if (a.contextHash["fluid.resolveRootSingle"]) {
                    var c = t.getForComponent(e, [ "options", "singleRootType" ]);
                    c || t.fail("Cannot register object with grades " + Object.keys(a.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType"), 
                    l = t.typeNameToMemberName(c);
                } else l = t.computeGlobalMemberName(e);
                var d = t.resolveRootComponent;
                d[l] && r.clearComponent(d, l), r.recordKnownComponent(d, e, l, !1);
            }
            return a.getConfig;
        }, t.shadowForComponent = function(e) {
            var n = t.getInstantiator(e);
            return n && e ? n.idToShadow[e.id] : null;
        }, t.getForComponent = function(e, n) {
            var r = t.shadowForComponent(e), a = r ? r.getConfig : void 0;
            return t.get(e, n, a);
        }, t.makeGingerStrategy = function(e) {
            var n = t.getInstantiator(e);
            return function(e, r, a, o) {
                var i = e[r];
                if (i === t.inEvaluationMarker && a === o.length && t.fail('Error in component configuration - a circular reference was found during evaluation of path segment "' + r + '": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application'), 
                a > 1) return i;
                if (void 0 === i && e.hasOwnProperty(r)) return t.NO_VALUE;
                if (void 0 === i) {
                    var u = n.idToShadow[e.id].path, s = n.composePath(u, r);
                    i = n.pathToComponent[s];
                }
                if (void 0 === i) {
                    var l = t.getForComponent(e, [ "options", "components", r ]);
                    l && (l.createOnEvent && t.fail('Error resolving path segment "' + r + '" of path ' + o.join(".") + " since component with record ", l, ' has annotation "createOnEvent" - this very likely represents an implementation error. Either alter the reference so it does not  match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves'), 
                    t.initDependent(e, r), i = e[r]);
                }
                return i;
            };
        }, t.frameworkGrades = [ "fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent" ], 
        t.filterBuiltinGrades = function(e) {
            return t.remove_if(t.makeArray(e), function(e) {
                return -1 !== t.frameworkGrades.indexOf(e);
            });
        }, t.dumpGradeNames = function(e) {
            return e.options && e.options.gradeNames ? " gradeNames: " + JSON.stringify(t.filterBuiltinGrades(e.options.gradeNames)) : "";
        }, t.dumpThat = function(e) {
            return '{ typeName: "' + e.typeName + '"' + t.dumpGradeNames(e) + " id: " + e.id + "}";
        }, t.dumpThatStack = function(e, n) {
            return t.transform(e, function(e) {
                var r = n.idToPath(e.id);
                return t.dumpThat(e) + (r ? " - path: " + r : "");
            }).join("\n");
        }, t.dumpComponentPath = function(e) {
            var n = t.pathForComponent(e);
            return n ? t.pathUtil.composeSegments(n) : "** no path registered for component **";
        }, t.resolveContext = function(e, n, r) {
            if ("that" === e) return n;
            if ("object" == typeof e) {
                var a = t.resolveContext(e.context, n, r);
                t.isComponent(a) || t.triggerMismatchedPathError(e.context, n);
                var o = t.getForComponent(a, e.path), i = t.expandOptions(o, n);
                return t.isComponent(i) || t.fail("Unable to resolve recursive context expression " + t.renderContextReference(e) + ": the directly resolved value of " + o + " did not resolve to a component in the scope of component ", n, ": got ", i), 
                i;
            }
            var u, s = t.globalInstantiator;
            if (r) return s.idToShadow[n.id].ownScope[e];
            var l = s.getFullStack(n);
            return t.visitComponentsForVisibility(s, l, function(n, r) {
                var a = t.shadowForComponent(n);
                return e === r || a && a.contextHash && a.contextHash[e] || e === n.typeName ? (u = n, 
                !0) : t.getForComponent(n, [ "options", "components", e ]) && !n[e] ? (u = t.getForComponent(n, e), 
                !0) : void 0;
            }), u;
        }, t.triggerMismatchedPathError = function(e, n) {
            var r = t.renderContextReference(e);
            t.fail("Failed to resolve reference " + r + " - could not match context with name " + e.context + " from component " + t.dumpThat(n) + " at path " + t.dumpComponentPath(n) + " component: ", n);
        }, t.makeStackFetcher = function(e, n, r) {
            return function(a) {
                e && "destroyed" === e.lifecycleStatus && t.fail("Cannot resolve reference " + t.renderContextReference(a) + " from component " + t.dumpThat(e) + " which has been destroyed");
                var o = a.context;
                if (n && o in n) return t.get(n[o], a.path);
                var i = t.resolveContext(o, e, r);
                return i || "" === a.path || t.triggerMismatchedPathError(a, e), t.getForComponent(i, a.path);
            };
        }, t.makeStackResolverOptions = function(n, r, a) {
            return e.extend(t.copy(t.rawDefaults("fluid.makeExpandOptions")), {
                localRecord: r || {},
                fetcher: t.makeStackFetcher(n, r, a),
                contextThat: n,
                exceptions: {
                    members: {
                        model: !0,
                        modelRelay: !0
                    }
                }
            });
        }, t.clearListeners = function(e) {
            t.each(e.listeners, function(e) {
                e.event.removeListener(e.listenerId || e.listener);
            }), delete e.listeners;
        }, t.recordListener = function(e, n, r, a) {
            e.ownerId !== r.that.id && t.pushArray(r, "listeners", {
                event: e,
                listener: n,
                listenerId: a
            });
        }, t.constructScopeObjects = function(e, t, n, r) {
            var a = t ? e.idToShadow[t.id] : null;
            r.childrenScope = a ? Object.create(a.ownScope) : {}, r.ownScope = Object.create(r.childrenScope), 
            r.parentShadow = a;
        }, t.clearChildrenScope = function(e, n, r, a) {
            t.each(a.contextHash, function(e, t) {
                n.childrenScope[t] === r && delete n.childrenScope[t];
            });
        }, t.instantiator = function() {
            function n(e, n, a, o, i) {
                var u;
                if (i) (u = r.idToShadow[n.id] = {}).that = n, u.path = a, u.memberName = o, t.constructScopeObjects(r, e, n, u); else {
                    (u = r.idToShadow[n.id]).injectedPaths = u.injectedPaths || {}, u.injectedPaths[a] = !0;
                    var s = r.idToShadow[e.id], l = t.keys(u.contextHash);
                    t.remove_if(l, function(e) {
                        return u.contextHash && "memberName" === u.contextHash[e];
                    }), l.push(o), t.each(l, function(e) {
                        s.childrenScope[e] || (s.childrenScope[e] = n);
                    });
                }
                r.pathToComponent[a] && t.fail("Error during instantiation - path " + a + " which has just created component " + t.dumpThat(n) + " has already been used for component " + t.dumpThat(r.pathToComponent[a]) + " - this is a circular instantiation or other oversight. Please clear the component using instantiator.clearComponent() before reusing the path."), 
                r.pathToComponent[a] = n;
            }
            var r = t.typeTag("instantiator");
            return e.extend(r, {
                lifecycleStatus: "constructed",
                pathToComponent: {},
                idToShadow: {},
                modelTransactions: {
                    init: {}
                },
                composePath: t.model.composePath,
                composeSegments: t.model.composeSegments,
                parseEL: t.model.parseEL,
                events: {
                    onComponentAttach: t.makeEventFirer({
                        name: "instantiator's onComponentAttach event"
                    }),
                    onComponentClear: t.makeEventFirer({
                        name: "instantiator's onComponentClear event"
                    })
                }
            }), r.idToPath = function(e) {
                var t = r.idToShadow[e];
                return t ? t.path : "";
            }, r.getThatStack = function(e) {
                var t = r.idToShadow[e.id];
                if (t) {
                    for (var n = t.path, a = r.parseEL(n), o = r.pathToComponent[""], i = [], u = 0; u < a.length; ++u) o = o[a[u]], 
                    i.push(o);
                    return i;
                }
                return [];
            }, r.getFullStack = function(e) {
                var n = e ? r.getThatStack(e) : [];
                return n.unshift(t.resolveRootComponent), n;
            }, r.recordRoot = function(e) {
                n(null, e, "", "", !0);
            }, r.recordKnownComponent = function(e, a, o, i) {
                if (e[o] = a, t.isComponent(a) || "instantiator" === a.type) {
                    var u = r.idToShadow[e.id].path, s = r.composePath(u, o);
                    n(e, a, s, o, i), r.events.onComponentAttach.fire(a, s, r, i);
                } else t.fail("Cannot record non-component with value ", a, ' at path "' + o + '" of parent ', e);
            }, r.clearConcreteComponent = function(e) {
                t.each(e.childShadow.injectedPaths, function(n, a) {
                    var o = t.model.getToTailPath(a), i = r.pathToComponent[o];
                    r.clearComponent(i, t.model.getTailPath(a), e.child);
                }), t.clearDistributions(e.childShadow), t.clearListeners(e.childShadow), t.fireEvent(e.child, "afterDestroy", [ e.child, e.name, e.component ]), 
                delete r.idToShadow[e.child.id];
            }, r.clearComponent = function(e, n, a, o, i, u) {
                var s = r.idToShadow[e.id];
                o = o || {
                    flat: !0,
                    instantiator: r,
                    destroyRecs: []
                }, a = a || e[n], void 0 === (u = u || s.path) && t.fail("Cannot clear component " + n + " from component ", e, " which was not created by this instantiator");
                var l = r.composePath(u, n), c = r.idToShadow[a.id];
                if (c) {
                    var d = c.path === l;
                    r.events.onComponentClear.fire(a, l, e, d), d ? (t.visitComponentChildren(a, function(e, t, n, i) {
                        var u = r.composeSegments.apply(null, n.slice(0, i));
                        r.clearComponent(a, t, null, o, !0, u);
                    }, o, r.parseEL(l)), t.doDestroy(a, n, e), o.destroyRecs.push({
                        child: a,
                        childShadow: c,
                        name: n,
                        component: e
                    })) : t.remove_if(c.injectedPaths, function(e, t) {
                        return t === l;
                    }), t.clearChildrenScope(r, s, a, c), delete r.pathToComponent[l], i || (delete e[n], 
                    t.each(o.destroyRecs, r.clearConcreteComponent));
                }
            }, r;
        }, t.globalInstantiator = t.instantiator(), t.getInstantiator = function(e) {
            var n = t.globalInstantiator;
            return e && n.idToShadow[e.id] ? n : null;
        }, t.defaults("fluid.resolveRoot"), t.defaults("fluid.resolveRootSingle", {
            gradeNames: "fluid.resolveRoot"
        }), t.constructRootComponents = function(e) {
            t.rootComponent = e.rootComponent = t.typeTag("fluid.rootComponent"), e.recordRoot(t.rootComponent), 
            t.resolveRootComponent = e.resolveRootComponent = t.typeTag("fluid.resolveRootComponent"), 
            e.recordKnownComponent(t.rootComponent, t.resolveRootComponent, "resolveRootComponent", !0);
            var n = e.idToShadow[t.rootComponent.id];
            n.contextHash = {};
            var r = e.idToShadow[t.resolveRootComponent.id];
            r.ownScope = n.ownScope, r.childrenScope = n.childrenScope, e.recordKnownComponent(t.resolveRootComponent, e, "instantiator", !0), 
            r.childrenScope.instantiator = e;
        }, t.constructRootComponents(t.globalInstantiator), t.expandOptions = function(e, n, r, a, o) {
            if (!e) return e;
            t.pushActivity("expandOptions", "expanding options %args for component %that ", {
                that: n,
                args: e
            });
            var i = t.makeStackResolverOptions(n, a);
            i.mergePolicy = r, i.defer = o && o.defer;
            var u = i.defer ? t.makeExpandOptions(e, i) : t.expand(e, i);
            return t.popActivity(), u;
        }, t.localRecordExpected = t.arrayToHash([ "type", "options", "container", "createOnEvent", "priority", "recordType" ]), 
        t.checkComponentRecord = function(e) {
            t.each(e, function(n, r) {
                t.localRecordExpected[r] || t.fail("Probable error in subcomponent record ", e, ' - key "' + r + '" found, where the only legal options are ' + t.keys(t.localRecordExpected).join(", "));
            });
        }, t.mergeRecordsToList = function(e, n) {
            var r = [];
            return t.each(n, function(n, a) {
                if (n.recordType = a, "distributions" === a) r.push.apply(r, t.transform(n, function(n) {
                    return t.computeDistributionPriority(e, n);
                })); else {
                    if (!n.options) return;
                    n.priority = t.mergeRecordTypes[a], void 0 === n.priority && t.fail("Merge record with unrecognised type " + a + ": ", n), 
                    r.push(n);
                }
            }), r;
        };
        var r = function(e) {
            return t.each([ "gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions" ], function(n) {
                t.set(e, [ n, "*", "noexpand" ], !0);
            }), e;
        };
        t.generateExpandBlock = function(e, n, r, a) {
            var o = t.expandOptions(e.options, e.contextThat || n, r, a, {
                defer: !0
            });
            return o.priority = e.priority, o.namespace = e.namespace, o.recordType = e.recordType, 
            o;
        };
        var a = function(n, a, o, i) {
            var u = t.copy(a);
            r(n), t.shadowForComponent(i).mergePolicy = n;
            var s = {
                defaults: {
                    options: u
                }
            };
            e.extend(s, o.mergeRecords), s.subcomponentRecord && t.checkComponentRecord(s.subcomponentRecord);
            var l = t.mergeRecordsToList(i, s);
            return t.transform(l, function(e) {
                return t.generateExpandBlock(e, i, n, o.localRecord);
            });
        };
        t.fabricateDestroyMethod = function(e, t, n, r) {
            return function() {
                n.clearComponent(e, t, r);
            };
        }, t.computeGlobalMemberName = function(e) {
            return t.computeNickName(e.typeName) + "-" + e.id;
        }, t.typeNameToMemberName = function(e) {
            return e.replace(/\./g, "_");
        }, t.expandComponentOptions = function(e, n, r, o) {
            var i = r, u = r && r.marker === t.EXPAND ? r.instantiator : null;
            t.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that", {
                options: u ? r.mergeRecords.user : r,
                record: i,
                that: o
            }), u || (u = t.globalInstantiator, i = {
                mergeRecords: {
                    user: {
                        options: t.expandCompact(r, !0)
                    }
                },
                memberName: t.computeGlobalMemberName(o),
                instantiator: u,
                parentThat: t.rootComponent
            }), o.destroy = t.fabricateDestroyMethod(i.parentThat, i.memberName, u, o), u.recordKnownComponent(i.parentThat, o, i.memberName, !0);
            var s = a(e, n, i, o);
            return t.popActivity(), s;
        }, t.assembleCreatorArguments = function(n, r, a) {
            var o = t.defaults(r);
            o && o.argumentMap || t.fail("Error in assembleCreatorArguments: cannot look up component type name " + r + " to a component creator grade with an argumentMap");
            var i = {}, u = n ? t.receiveDistributions(n, o.gradeNames, a.memberName, i) : [];
            t.each(u, function(e) {
                t.computeDistributionPriority(n, e), t.isPrimitive(e.priority) && (e.priority = t.parsePriority(e.priority, 0, !1, "options distribution"));
            }), t.sortByPriority(u);
            var s = a.localDynamic, l = e.extend({}, t.censorKeys(a.componentRecord, [ "type" ]), s), c = o.argumentMap, d = Object.keys(c).concat([ "type" ]);
            t.each(d, function(e) {
                for (var t = 0; t < u.length; ++t) void 0 !== u[t][e] && (l[e] = u[t][e]);
            }), r = l.type || r, delete l.type, delete l.options;
            var f = {
                distributions: u
            };
            void 0 !== a.componentRecord && (f.subcomponentRecord = e.extend({}, a.componentRecord));
            var p = [];
            return t.each(c, function(e, r) {
                var o;
                if ("options" === r) o = {
                    marker: t.EXPAND,
                    localRecord: s,
                    mergeRecords: f,
                    instantiator: t.getInstantiator(n),
                    parentThat: n,
                    memberName: a.memberName
                }; else {
                    var i = l[r];
                    o = t.expandImmediate(i, n, l);
                }
                p[e] = o;
            }), {
                args: p,
                funcName: r
            };
        }, t.initDependent = function(e, n, r) {
            if (!e[n]) {
                var a, o = e.options.components[n], i = t.globalInstantiator, u = i.idToShadow[e.id], s = r || u.subcomponentLocal && u.subcomponentLocal[n];
                if (t.pushActivity("initDependent", 'instantiating dependent component at path "%path" with record %record as child of %parent', {
                    path: u.path + "." + n,
                    record: o,
                    parent: e
                }), "string" == typeof o || o.expander) e[n] = t.inEvaluationMarker, (a = t.expandImmediate(o, e)) ? i.recordKnownComponent(e, a, n, !1) : delete e[n]; else if (o.type) {
                    var l = t.expandImmediate(o.type, e, s);
                    l || t.fail("Error in subcomponent record: ", o.type, " could not be resolved to a type for component ", n, " of parent ", e);
                    var c = t.assembleCreatorArguments(e, l, {
                        componentRecord: o,
                        memberName: n,
                        localDynamic: s
                    });
                    a = t.initSubcomponentImpl(e, {
                        type: c.funcName
                    }, c.args);
                } else t.fail("Unrecognised material in place of subcomponent " + n + ' - no "type" field found');
                return t.popActivity(), a;
            }
        }, t.bindDeferredComponent = function(e, n, r) {
            var a = t.makeArray(r.createOnEvent);
            t.each(a, function(a) {
                var o = t.isIoCReference(a) ? t.expandOptions(a, e) : e.events[a];
                o && o.addListener || t.fail("Error instantiating createOnEvent component with name " + n + " of parent ", e, " since event specification " + a + " could not be expanded to an event - got ", o), 
                o.addListener(function() {
                    t.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName", {
                        componentName: n,
                        that: e,
                        eventName: a
                    }), e[n] && t.globalInstantiator.clearComponent(e, n);
                    var r = {
                        arguments: t.makeArray(arguments)
                    };
                    t.initDependent(e, n, r), t.popActivity();
                }, null, r.priority);
            });
        }, t.priorityForComponent = function(e) {
            return e.priority ? e.priority : "fluid.typeFount" === e.type || t.hasGrade(t.defaults(e.type), "fluid.typeFount") ? "first" : void 0;
        }, t.initDependents = function(e) {
            t.pushActivity("initDependents", "instantiating dependent components for component %that", {
                that: e
            });
            var n = t.shadowForComponent(e);
            if (n.memberStrategy.initter(), n.invokerStrategy.initter(), t.getForComponent(e, "modelRelay"), 
            t.getForComponent(e, "model"), !t.isDestroyed(e)) {
                var r = e.options.components || {}, a = [];
                t.each(r, function(n, r) {
                    if (n.createOnEvent) t.bindDeferredComponent(e, r, n); else {
                        var o = t.priorityForComponent(n);
                        a.push({
                            namespace: r,
                            priority: t.parsePriority(o)
                        });
                    }
                }), t.sortByPriority(a), t.each(a, function(n) {
                    t.initDependent(e, n.namespace);
                }), n.subcomponentLocal && t.clear(n.subcomponentLocal), e.lifecycleStatus = "constructed", 
                t.assessTreeConstruction(e, n), t.popActivity();
            }
        }, t.assessTreeConstruction = function(e, n) {
            var r = t.globalInstantiator, a = r.getThatStack(e);
            t.find_if(a, function(e) {
                return "constructing" === e.lifecycleStatus;
            }) ? e.lifecycleStatus = "constructed" : t.markSubtree(r, e, n.path, "treeConstructed");
        }, t.markSubtree = function(e, n, r, a) {
            n.lifecycleStatus = a, t.visitComponentChildren(n, function(n, o) {
                var i = e.composePath(r, o), u = e.idToShadow[n.id];
                u && u.path === i && t.markSubtree(e, n, i, a);
            }, {
                flat: !0
            });
        }, t.pathForComponent = function(e, n) {
            var r = (n = n || t.getInstantiator(e) || t.globalInstantiator).idToShadow[e.id];
            return r ? n.parseEL(r.path) : null;
        }, t.construct = function(e, n, r) {
            var a = t.destroy(e, r);
            return t.set(a.parent, [ "options", "components", a.memberName ], {
                type: n.type,
                options: n
            }), t.initDependent(a.parent, a.memberName);
        }, t.destroy = function(e, n) {
            n = n || t.globalInstantiator;
            var r = t.model.parseToSegments(e, n.parseEL, !0);
            0 === r.length && t.fail("Cannot destroy the root component");
            var a = r.pop(), o = n.composeSegments.apply(null, r), i = n.pathToComponent[o];
            return i || t.fail("Cannot modify component with nonexistent parent at path ", e), 
            i[a] && i[a].destroy(), {
                parent: i,
                memberName: a
            };
        }, t.constructSingle = function(n, r, a) {
            a = a || t.globalInstantiator, n = n || "";
            var o = t.model.parseToSegments(n, a.parseEL, !0);
            "string" == typeof r && (r = {
                type: r
            });
            var i = r.type;
            i || t.fail("Cannot construct singleton object without a type entry");
            var u = (r = e.extend({}, r)).gradeNames = t.makeArray(r.gradeNames);
            u.unshift(i), r.type = "fluid.component", 0 === o.length && u.push("fluid.resolveRoot");
            var s = t.typeNameToMemberName(r.singleRootType || i);
            o.push(s), t.construct(o, r, a);
        }, t.destroySingle = function(e, n, r) {
            r = r || t.globalInstantiator;
            var a = t.model.parseToSegments(e, r.parseEL, !0), o = t.typeNameToMemberName(n);
            a.push(o), t.destroy(a, r);
        }, t.makeGradeLinkage = function(e, n, r) {
            t.defaults(e, {
                gradeNames: "fluid.component",
                distributeOptions: {
                    record: r,
                    target: "{/ " + n.join("&") + "}.options.gradeNames"
                }
            }), t.constructSingle([], e);
        }, t.componentForPath = function(e) {
            return t.globalInstantiator.pathToComponent[t.isArrayable(e) ? e.join(".") : e];
        }, t.debugger = function() {}, t.defaults("fluid.debuggingProbe", {
            gradeNames: [ "fluid.component" ]
        }), t.probeToDistribution = function(e) {
            var n = t.globalInstantiator, r = t.parseContextReference(e.target), a = t.model.parseToSegments(r.path, n.parseEL, !0);
            "options" !== a[0] && a.unshift("options");
            var o = t.parsePriority(e.priority);
            return o.constraint && !o.constraint.target && (o.constraint.target = "authoring"), 
            {
                target: "{/ " + r.context + "}." + n.composeSegments.apply(null, a),
                record: {
                    func: e.func,
                    funcName: e.funcName,
                    args: e.args,
                    priority: t.renderPriority(o)
                }
            };
        }, t.registerProbes = function(e) {
            var n = t.transform(e, t.probeToDistribution), r = "fluid_debuggingProbe_" + t.allocateGuid();
            return t.construct([ r ], {
                type: "fluid.debuggingProbe",
                distributeOptions: n
            }), r;
        }, t.deregisterProbes = function(e) {
            t.destroy([ e ]);
        }, t.thisistToApplicable = function(e, n, r) {
            return {
                apply: function(a, o) {
                    var i = t.expandOptions(n, r);
                    "string" == typeof i && (i = t.getGlobalValue(i)), i || t.fail("Could not resolve reference " + n + " to a value");
                    var u = i[e.method];
                    return "function" != typeof u && t.fail("Object ", i, " at reference " + n + " has no member named " + e.method + " which is a function "), 
                    t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Applying arguments ", o, " to method " + e.method + " of instance ", i), 
                    u.apply(i, o);
                }
            };
        }, t.changeToApplicable = function(e, n) {
            return {
                apply: function(r, a, o, i) {
                    var u = t.parseValidModelReference(n, "changePath listener record", e.changePath), s = t.expandOptions(e.value, n, {}, t.extend(o, {
                        arguments: a
                    })), l = i && i.source && i.source.length ? t.makeArray(e.source).concat(i.source) : e.source;
                    u.applier.change(u.modelSegs, s, e.type, l);
                }
            };
        }, t.recordToApplicable = function(e, n, r) {
            if (void 0 !== e.changePath) return t.changeToApplicable(e, n, r);
            var a = e.this;
            return e.method ^ a && t.fail("Record ", n, ' must contain both entries "method" and "this" if it contains either'), 
            e.method ? t.thisistToApplicable(e, a, n) : null;
        }, t.getGlobalValueNonComponent = function(e, n) {
            var r = t.defaults(e);
            return r && t.hasGrade(r, "fluid.component") && t.fail("Error in function specification - cannot invoke function " + e + " in the context of " + n + ": component creator functions can only be used as subcomponents"), 
            t.getGlobalValue(e);
        }, t.makeInvoker = function(e, n, r) {
            void 0 === (n = t.upgradePrimitiveFunc(n)).args || n.args === t.NO_VALUE || t.isArrayable(n.args) || (n.args = t.makeArray(n.args));
            var a = t.recordToApplicable(n, e), o = t.preExpand(n.args), i = {}, u = t.makeStackResolverOptions(e, i, !0);
            return (a = a || (n.funcName ? t.getGlobalValueNonComponent(n.funcName, "an invoker") : t.expandImmediate(n.func, e))) && a.apply ? a === t.notImplemented && t.fail("Error constructing component ", e, " - the invoker named " + r + " which was defined in grade " + n.componentSource + " needs to be overridden with a concrete implementation") : t.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + a + " from ", n), 
            function() {
                !1 === t.defeatLogging && t.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record from path %path holding component %that", {
                    name: r,
                    record: n,
                    path: t.dumpComponentPath(e),
                    that: e
                });
                var s, l;
                return "destroyed" === e.lifecycleStatus ? t.log(t.logLevel.WARN, "Ignoring call to invoker " + r + " of component ", e, " which has been destroyed") : (i.arguments = arguments, 
                void 0 === n.args || n.args === t.NO_VALUE ? l = arguments : (t.expandImmediateImpl(o, u), 
                l = o.source), s = a.apply(null, l)), !1 === t.defeatLogging && t.popActivity(), 
                s;
            };
        }, t.event.makeTrackedListenerAdder = function(e) {
            var n = t.shadowForComponent(e);
            return function(e) {
                return {
                    addListener: function(r, a, o, i, u) {
                        t.recordListener(e, r, n, u), e.addListener.apply(null, arguments);
                    }
                };
            };
        }, t.event.listenerEngine = function(e, n, r) {
            function a() {
                if (!t.find(e, function(e, t) {
                    if (void 0 === o[t]) return !0;
                })) {
                    var r = o;
                    o = {}, n(r);
                }
            }
            var o = {};
            t.each(e, function(e, n) {
                r(e).addListener(function() {
                    o[n] = t.makeArray(arguments), a();
                });
            });
        }, t.event.dispatchListener = function(e, n, r, a, o) {
            void 0 === a.args || a.args === t.NO_VALUE || t.isArrayable(a.args) || (a.args = t.makeArray(a.args)), 
            n = t.event.resolveListener(n);
            var i = t.preExpand(a.args), u = {}, s = t.makeStackResolverOptions(e, u, !0), l = function() {
                !1 === t.defeatLogging && t.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that", {
                    eventName: r,
                    that: e
                });
                var l, c = o ? arguments[0] : arguments;
                u.arguments = c, void 0 !== a.args && a.args !== t.NO_VALUE ? (t.expandImmediateImpl(i, s), 
                l = i.source) : l = c;
                var d = n.apply(null, l);
                return !1 === t.defeatLogging && t.popActivity(), d;
            };
            return t.event.impersonateListener(n, l), l;
        }, t.event.resolveSoftNamespace = function(e) {
            if ("string" != typeof e) return null;
            var t = Math.max(e.lastIndexOf("."), e.lastIndexOf("}"));
            return e.substring(t + 1);
        }, t.event.resolveListenerRecord = function(e, n, r, a, o) {
            var i = function(e, n) {
                t.fail("Error in listener record - could not resolve reference ", e, ' to a listener or firer. Did you miss out "events." when referring to an event firer?' + n);
            };
            t.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that", {
                eventName: r,
                that: n
            });
            var u = t.makeArray(e), s = {
                records: t.transform(u, function(e) {
                    var u = t.isPrimitive(e) || e.expander ? {
                        listener: e
                    } : t.copy(e), s = t.recordToApplicable(e, n, o);
                    u.listener = s || (u.listener || u.func || u.funcName), u.listener || i(e, ' Listener record must contain a member named "listener", "func", "funcName" or "method"');
                    var l = e.method ? t.event.resolveSoftNamespace(e.this) + "." + e.method : t.event.resolveSoftNamespace(u.listener);
                    u.namespace || a || !l || (u.softNamespace = !0, u.namespace = (e.componentSource ? e.componentSource : n.typeName) + "." + l);
                    var c = u.listener = t.expandOptions(u.listener, n);
                    c || i(e, "");
                    var d = !1;
                    return "fluid.event.firer" === c.typeName && (c = c.fire, d = !0), u.listener = o && (u.args && "fluid.notImplemented" !== c || d) ? t.event.dispatchListener(n, c, r, u) : c, 
                    u.listenerId = t.allocateGuid(), u;
                }),
                adderWrapper: o ? t.event.makeTrackedListenerAdder(n) : null
            };
            return t.popActivity(), s;
        }, t.event.expandOneEvent = function(e, n) {
            var r;
            return (r = "string" == typeof n && "{" !== n.charAt(0) ? t.getForComponent(e, [ "events", n ]) : t.expandOptions(n, e)) && "fluid.event.firer" === r.typeName || t.fail("Error in event specification - could not resolve base event reference ", n, " to an event firer: got ", r), 
            r;
        }, t.event.expandEvents = function(e, n) {
            return "string" == typeof n ? t.event.expandOneEvent(e, n) : t.transform(n, function(n) {
                return t.event.expandOneEvent(e, n);
            });
        }, t.event.resolveEvent = function(e, n, r) {
            t.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that", {
                eventName: n,
                that: e
            });
            var a = t.event.makeTrackedListenerAdder(e);
            "string" == typeof r && (r = {
                event: r
            });
            var o = "fluid.event.firer" === r.typeName ? r : r.event || r.events;
            o || t.fail("Event specification for event with name " + n + " does not include a base event specification: ", r);
            var i, u = "fluid.event.firer" === o.typeName ? o : t.event.expandEvents(e, o), s = "fluid.event.firer" !== u.typeName;
            if (r.args || s) {
                i = t.makeEventFirer({
                    name: " [composite] " + t.event.nameEvent(e, n)
                });
                var l = t.event.dispatchListener(e, i.fire, n, r, s);
                s ? t.event.listenerEngine(u, l, a) : a(u).addListener(l);
            } else (i = {
                typeName: "fluid.event.firer"
            }).fire = function() {
                var e = t.makeArray(arguments);
                t.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {
                    eventName: n
                });
                var r = u.fire.apply(null, e);
                return t.popActivity(), r;
            }, i.addListener = function(o, i, s, l, c) {
                var d = t.event.dispatchListener(e, o, n, r);
                a(u).addListener(d, i, s, l, c);
            }, i.removeListener = function(e) {
                u.removeListener(e);
            };
            return t.popActivity(), i;
        }, t.withEnvironment = function(n, r, a) {
            var o;
            a = a || t.globalThreadLocal();
            try {
                for (o in n) a[o] = n[o];
                return e.extend(a, n), r();
            } finally {
                for (o in n) delete a[o];
            }
        }, t.fetchContextReference = function(e, n, r, a, o) {
            a && (e = a(e, r));
            var i = e.context ? r[e.context] : n;
            return i ? e.noDereference ? e.path : t.get(i, e.path) : o && o(e) || i;
        }, t.makeEnvironmentFetcher = function(e, n, r, a) {
            return r = r || t.globalThreadLocal, function(o) {
                var i = r();
                return t.fetchContextReference(o, e, i, n, a);
            };
        }, t.coerceToPrimitive = function(e) {
            return "false" !== e && ("true" === e || (isFinite(e) ? Number(e) : e));
        }, t.compactStringToRec = function(n, r) {
            var a = n.indexOf("("), o = n.indexOf(")");
            if ((-1 === a ^ -1 === o || a > o) && t.fail("Badly-formed compact " + r + " record without matching parentheses: " + n), 
            -1 !== a && -1 !== o) {
                var i = n.substring(o + 1);
                "" !== e.trim(i) && t.fail("Badly-formed compact " + r + " record " + n + " - unexpected material following close parenthesis: " + i);
                var u = n.substring(0, a), s = e.trim(n.substring(a + 1, o)), l = "" === s ? [] : t.transform(s.split(","), e.trim, t.coerceToPrimitive), c = t.upgradePrimitiveFunc(u, null);
                return c.args = l, c;
            }
            return "expander" === r && t.fail("Badly-formed compact expander record without parentheses: " + n), 
            n;
        }, t.expandPrefix = "@expand:", t.expandCompactString = function(e, n) {
            var r = e;
            if (0 === e.indexOf(t.expandPrefix)) {
                var a = e.substring(t.expandPrefix.length);
                r = {
                    expander: t.compactStringToRec(a, "expander")
                };
            } else n && (r = t.compactStringToRec(e, n));
            return r;
        };
        var o = {
            listeners: "listener",
            modelListeners: "modelListener"
        }, i = e.extend({
            invokers: "invoker"
        }, o);
        t.expandCompactRec = function(e, n, r) {
            t.guardCircularExpansion(e, e.length);
            var a = e.length > 0 ? e[e.length - 1] : "", u = i[a];
            !u && e.length > 1 && (u = o[e[e.length - 2]]), t.each(r, function(r, a) {
                if (t.isPlainObject(r)) return n[a] = t.freshContainer(r), e.push(a), t.expandCompactRec(e, n[a], r), 
                void e.pop();
                "string" == typeof r && (r = t.expandCompactString(r, u)), n[a] = r;
            });
        }, t.expandCompact = function(e) {
            var n = {};
            return t.expandCompactRec([], n, e), n;
        }, t.extractEL = function(e, t) {
            if ("ALL" === t.ELstyle) return e;
            if (1 === t.ELstyle.length) {
                if (e.charAt(0) === t.ELstyle) return e.substring(1);
            } else if ("${}" === t.ELstyle) {
                var n = e.indexOf("${"), r = e.lastIndexOf("}");
                if (0 === n && -1 !== r) return e.substring(2, r);
            }
        }, t.extractELWithContext = function(e, n) {
            var r = t.extractEL(e, n);
            return t.isIoCReference(r) ? t.parseContextReference(r) : r ? {
                path: r
            } : r;
        }, t.parseContextReference = function(e, n, r) {
            n = n || 0;
            var a, o, i, u = "{" === e.charAt(n + 1);
            -1 === (a = u ? (i = t.parseContextReference(e, n + 1, "}")).endpos : e.indexOf("}", n + 1)) && t.fail('Cannot parse context reference "' + e + '": Malformed context reference without }'), 
            o = u ? i : e.substring(n + 1, a);
            var s = r ? e.indexOf(r, a + 1) : e.length, l = e.substring(a + 1, s);
            return "." === l.charAt(0) && (l = l.substring(1)), {
                context: o,
                path: l,
                endpos: s
            };
        }, t.renderContextReference = function(e) {
            var n = e.context;
            return "{" + ("string" == typeof n ? n : t.renderContextReference(n)) + "}" + (e.path ? "." + e.path : "");
        }, t.resolveContextValue = function(e, n) {
            function r(e) {
                t.pushActivity("resolveContextValue", "resolving context value %parsed", {
                    parsed: e
                });
                var r = n.fetcher(e);
                return t.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {
                    parsed: e,
                    value: r
                }), t.popActivity(2), r;
            }
            var a;
            if (n.bareContextRefs && t.isIoCReference(e)) return a = t.parseContextReference(e), 
            r(a);
            if (n.ELstyle && "${}" !== n.ELstyle && (a = t.extractELWithContext(e, n))) return r(a);
            for (;"string" == typeof e; ) {
                var o = e.indexOf("${"), i = e.indexOf("}", o + 2);
                if (-1 === o || -1 === i) break;
                "{" === e.charAt(o + 2) ? i = (a = t.parseContextReference(e, o + 2, "}")).endpos : a = {
                    path: e.substring(o + 2, i)
                };
                var u = r(a), s = 0 === o && i === e.length - 1;
                if (void 0 === u || null === u) return u;
                e = s ? u : e.substring(0, o) + u + e.substring(i + 1);
            }
            return e;
        }, t.fetchExpandChildren = function(n, r, a, o, i, u) {
            if (o.expander) {
                var s = t.expandExpander(n, o, u);
                if (t.isPrimitive(s) || !t.isPlainObject(s) || t.isArrayable(s) ^ t.isArrayable(n)) return s;
                e.extend(!0, n, s);
            }
            return t.each(o, function(e, s) {
                void 0 === e ? n[s] = void 0 : "expander" !== s && (a[r] = s, !0 !== t.getImmediate(u.exceptions, a, r) && u.strategy(n, s, r + 1, a, o, i));
            }), n;
        }, t.isUnexpandable = function(e) {
            return t.isPrimitive(e) || !t.isPlainObject(e);
        }, t.expandSource = function(e, n, r, a, o, i, u, s) {
            var l, c, d = t.derefMergePolicy(u);
            return "string" != typeof i || d.noexpand ? d.noexpand || t.isUnexpandable(i) ? l = i : i.expander ? l = t.expandExpander(o, i, e) : (l = t.freshContainer(i), 
            c = !0) : e.defaultEL && "{" !== i.charAt(0) ? l = i : (t.pushActivity("expandContextValue", "expanding context value %source held at path %path", {
                source: i,
                path: t.path.apply(null, a.slice(0, r))
            }), l = t.resolveContextValue(i, e), t.popActivity(1)), l !== t.NO_VALUE && o(l), 
            c && s(l, i, r, a, u), l;
        }, t.guardCircularExpansion = function(e, n) {
            n > t.strategyRecursionBailout && t.fail("Overflow/circularity in options expansion, current path is ", e, " at depth ", n, ' - please ensure options are not circularly connected, or protect from expansion using the "noexpand" policy or expander');
        }, t.makeExpandStrategy = function(e) {
            var r = function(n, r, a, o, i) {
                return t.fetchExpandChildren(n, a || 0, o || [], r, i, e);
            }, a = function(a, o, i, u, s, l) {
                if (t.guardCircularExpansion(u, i), a) {
                    if (a.hasOwnProperty(o)) return a[o];
                    void 0 === s && (s = n(e.source, u, i - 1, e.sourceStrategy), l = n(e.mergePolicy, u, i - 1, t.concreteTrundler));
                    var c = e.sourceStrategy(s, o, i, u), d = t.concreteTrundler(l, o);
                    return t.expandSource(e, a, i, u, function(e) {
                        a[o] = e;
                    }, c, d, r);
                }
            };
            return e.recurse = r, e.strategy = a, a;
        }, t.defaults("fluid.makeExpandOptions", {
            ELstyle: "${}",
            bareContextRefs: !0,
            target: t.inCreationMarker
        }), t.makeExpandOptions = function(n, r) {
            return r = e.extend({}, t.rawDefaults("fluid.makeExpandOptions"), r), r.defaultEL = "${}" === r.ELStyle && r.bareContextRefs, 
            r.expandSource = function(e) {
                return t.expandSource(r, null, 0, [], t.identity, e, r.mergePolicy, !1);
            }, t.isUnexpandable(n) ? (r.strategy = t.concreteTrundler, r.initter = t.identity, 
            r.target = "string" == typeof n ? (r.defer ? t.copy : t.identity)(r.expandSource(n)) : n, 
            r.immutableTarget = !0) : (r.source = n, r.target = t.freshContainer(n), r.sourceStrategy = r.sourceStrategy || t.concreteTrundler, 
            t.makeExpandStrategy(r), r.initter = function() {
                r.target = t.fetchExpandChildren(r.target, 0, [], r.source, r.mergePolicy, r);
            }), r;
        }, t.expand = function(e, n) {
            var r = t.makeExpandOptions(e, n);
            return r.initter(), r.target;
        }, t.preExpandRecurse = function(e, n, r, a, o) {
            function i(t) {
                e.expanders.push({
                    expander: t,
                    holder: r,
                    member: a
                }), delete r[a];
            }
            if (t.guardCircularExpansion(o, o.length), t.isIoCReference(n)) {
                var u = t.parseContextReference(n), s = t.model.parseEL(u.path);
                i({
                    typeFunc: t.expander.fetch,
                    context: u.context,
                    segs: s
                });
            } else t.isPlainObject(n) && (n.expander ? (n.expander.typeFunc = t.getGlobalValue(n.expander.type || "fluid.invokeFunc"), 
            i(n.expander)) : t.each(n, function(r, a) {
                o.push(a), t.preExpandRecurse(e, r, n, a, o), o.pop();
            }));
        }, t.preExpand = function(e) {
            var n = {
                expanders: [],
                source: t.isUnexpandable(e) ? e : t.copy(e)
            };
            return t.preExpandRecurse(n, n.source, n, "source", []), n;
        }, t.expandImmediate = function(e, n, r) {
            var a = t.makeStackResolverOptions(n, r, !0), o = t.preExpand(e);
            return t.expandImmediateImpl(o, a), o.source;
        }, t.expandImmediateImpl = function(e, t) {
            for (var n = e.expanders, r = 0; r < n.length; ++r) {
                var a = n[r];
                a.holder[a.member] = a.expander.typeFunc(null, a, t);
            }
        }, t.expandExpander = function(e, n, r) {
            var a = t.getGlobalValue(n.expander.type || "fluid.invokeFunc");
            return a || t.fail("Unknown expander with type " + n.expander.type), a(e, n, r);
        }, t.registerNamespace("fluid.expander"), t.expander.fetch = function(e, n, r) {
            var a = r.localRecord, o = n.expander.context, i = n.expander.segs, u = void 0 !== a[o], s = r.contextThat.lifecycleStatus, l = "treeConstructed" === s || "destroyed" === s, c = u ? a[o] : t.resolveContext(o, r.contextThat, l);
            if (c) {
                var d = c;
                if (u || "constructing" !== c.lifecycleStatus) for (var f = 0; f < i.length; ++f) d = d ? d[i[f]] : void 0; else d = t.getForComponent(c, i);
                return void 0 !== d || u || (d = t.getForComponent(c, i)), d;
            }
            i.length > 0 && t.triggerMismatchedPathError(n.expander, r.contextThat);
        }, t.invokeFunc = function(e, n, r) {
            var a = n.expander, o = t.makeArray(a.args);
            a.args = o, o = r.recurse ? r.recurse([], o) : (a = t.expandImmediate(a, r.contextThat, r.localRecord)).args;
            var i = a.func || a.funcName, u = (r.expandSource ? r.expandSource(i) : i) || t.recordToApplicable(a, r.contextThat);
            return "string" == typeof u && (u = t.getGlobalValue(u)), u || t.fail("Error in expander record ", a, ": " + i + " could not be resolved to a function for component ", r.contextThat), 
            u.apply(null, o);
        }, t.noexpand = function(e, t) {
            return t.expander.value ? t.expander.value : t.expander.tree;
        };
    }(t, n = n || {}), function(e, t) {
        "use strict";
        t.model.makeEnvironmentStrategy = function(e) {
            return function(t, n, r) {
                return 0 === r && e[n] ? e[n] : void 0;
            };
        }, t.model.defaultCreatorStrategy = function(e, t) {
            if (void 0 === e[t]) return e[t] = {}, e[t];
        }, t.model.defaultFetchStrategy = function(e, t) {
            return e[t];
        }, t.model.funcResolverStrategy = function(e, t) {
            if (e.resolvePathSegment) return e.resolvePathSegment(t);
        }, t.model.traverseWithStrategy = function(e, n, r, a, o) {
            for (var i = a.strategies, u = n.length - o, s = r; s < u; ++s) {
                if (!e) return e;
                for (var l, c = 0; c < i.length && void 0 === (l = i[c](e, n[s], s + 1, n)); ++c) ;
                l === t.NO_VALUE && (l = void 0), e = l;
            }
            return e;
        }, t.model.getValueAndSegments = function(e, n, r, a) {
            return t.model.accessWithStrategy(e, n, t.NO_VALUE, r, a, !0);
        }, t.model.makeTrundler = function(e) {
            return function(n, r) {
                return t.model.getValueAndSegments(n.root, r, e, n.segs);
            };
        }, t.model.getWithStrategy = function(e, n, r, a) {
            return t.model.accessWithStrategy(e, n, t.NO_VALUE, r, a);
        }, t.model.setWithStrategy = function(e, n, r, a, o) {
            t.model.accessWithStrategy(e, n, r, a, o);
        }, t.model.accessWithStrategy = function(e, n, r, a, o, i) {
            if (t.isPrimitive(n) || t.isArrayable(n)) return t.model.accessImpl(e, n, r, a, o, i, t.model.traverseWithStrategy);
            var u = n.type || "default", s = a.resolvers[u];
            s || t.fail("Unable to find resolver of type " + u);
            var l = t.model.makeTrundler(a), c = {
                root: e,
                segs: o
            };
            return c = s(c, n, l), n.path && c && (c = l(c, n.path)), i ? c : c ? c.root : void 0;
        }, t.registerNamespace("fluid.pathUtil"), t.pathUtil.getPathSegmentImpl = function(e, t, n) {
            var r = null;
            e && (r = "");
            for (var a = !1, o = t.length; n < o; ++n) {
                var i = t.charAt(n);
                if (a) a = !1, null !== r && (r += i); else {
                    if ("." === i) break;
                    "\\" === i ? a = !0 : null !== r && (r += i);
                }
            }
            return null !== r && (e[0] = r), n;
        };
        var n = [];
        t.pathUtil.parseEL = function(e) {
            for (var r = [], a = 0, o = e.length; a < o; ) {
                var i = t.pathUtil.getPathSegmentImpl(n, e, a);
                r.push(n[0]), a = i + 1;
            }
            return r;
        }, t.pathUtil.composeSegment = function(e, t) {
            t = t.toString();
            for (var n = 0; n < t.length; ++n) {
                var r = t.charAt(n);
                "." !== r && "\\" !== r && "}" !== r || (e += "\\"), e += r;
            }
            return e;
        }, t.pathUtil.escapeSegment = function(e) {
            return t.pathUtil.composeSegment("", e);
        }, t.pathUtil.composePath = function(e, n) {
            return 0 !== e.length && (e += "."), t.pathUtil.composeSegment(e, n);
        }, t.pathUtil.composeSegments = function() {
            for (var e = "", n = 0; n < arguments.length; ++n) e = t.pathUtil.composePath(e, arguments[n]);
            return e;
        }, t.pathUtil.matchSegments = function(e, t, n, r) {
            if (r - n !== e.length) return !1;
            for (var a = n; a < r; ++a) if (t[a] !== e[a - n]) return !1;
            return !0;
        }, t.model.unescapedParser = {
            parse: t.model.parseEL,
            compose: t.model.composeSegments
        }, t.model.defaultGetConfig = {
            parser: t.model.unescapedParser,
            strategies: [ t.model.funcResolverStrategy, t.model.defaultFetchStrategy ]
        }, t.model.defaultSetConfig = {
            parser: t.model.unescapedParser,
            strategies: [ t.model.funcResolverStrategy, t.model.defaultFetchStrategy, t.model.defaultCreatorStrategy ]
        }, t.model.escapedParser = {
            parse: t.pathUtil.parseEL,
            compose: t.pathUtil.composeSegments
        }, t.model.escapedGetConfig = {
            parser: t.model.escapedParser,
            strategies: [ t.model.defaultFetchStrategy ]
        }, t.model.escapedSetConfig = {
            parser: t.model.escapedParser,
            strategies: [ t.model.defaultFetchStrategy, t.model.defaultCreatorStrategy ]
        }, t.initRelayModel = function(e) {
            return t.deenlistModelComponent(e), e.model;
        }, t.isModelComplete = function(e) {
            return "model" in e && e.model !== t.inEvaluationMarker;
        }, t.enlistModelComponent = function(e) {
            var n = t.getInstantiator(e), r = n.modelTransactions.init[e.id];
            return r || (r = {
                that: e,
                applier: t.getForComponent(e, "applier"),
                complete: t.isModelComplete(e)
            }, n.modelTransactions.init[e.id] = r), r;
        }, t.clearTransactions = function() {
            var e = t.globalInstantiator;
            t.clear(e.modelTransactions), e.modelTransactions.init = {};
        }, t.failureEvent.addListener(t.clearTransactions, "clearTransactions", "before:fail"), 
        t.clearLinkCounts = function(e, n) {
            t.each(e, function(t, r) {
                "number" == typeof t ? e[r] = 0 : n && t.options && "number" == typeof t.relayCount && (t.relayCount = 0);
            });
        }, t.sortCompleteLast = function(e, t) {
            return (e.completeOnInit ? 1 : 0) - (t.completeOnInit ? 1 : 0);
        }, t.operateInitialTransaction = function(e, n) {
            var r, a = t.allocateGuid(), o = t.getModelTransactionRec(e, a), i = t.transform(n, function(e) {
                return r = e.that.applier.initiate(null, "init", a), o[e.that.applier.applierId] = {
                    transaction: r
                }, r;
            }), u = t.values(n).sort(t.sortCompleteLast);
            t.each(u, function(e) {
                var n = e.that, r = i[n.id];
                e.completeOnInit ? t.initModelEvent(n, n.applier, r, n.applier.listeners.sortedListeners) : t.each(e.initModels, function(e) {
                    r.fireChangeRequest({
                        type: "ADD",
                        segs: [],
                        value: e
                    }), t.clearLinkCounts(o, !0);
                });
                var a = t.shadowForComponent(n);
                a && (a.modelComplete = !0);
            }), r.commit();
        }, t.deenlistModelComponent = function(e) {
            var n = t.getInstantiator(e), r = n.modelTransactions.init;
            if (r[e.id] && (e.model = void 0, r[e.id].complete = !0, !t.find_if(r, function(e) {
                return !0 !== e.complete;
            }))) {
                try {
                    t.operateInitialTransaction(e, r);
                } catch (e) {
                    throw t.clearTransactions(), e;
                }
                n.modelTransactions.init = {};
            }
        }, t.parseModelReference = function(e, n) {
            var r = t.parseContextReference(n);
            return r.segs = e.applier.parseEL(r.path), r;
        }, t.parseValidModelReference = function(e, n, r, a) {
            var o, i = function() {
                var e = [ "Error in " + n + ": ", r ].concat(t.makeArray(arguments));
                t.fail.apply(null, e);
            }, u = function(e) {
                i(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", e);
            };
            if ("string" == typeof r) if (t.isIoCReference(r)) {
                var s = (o = t.parseModelReference(e, r)).segs.indexOf("model");
                -1 === s ? a ? o.nonModel = !0 : i(' must be a reference into a component model via a path including the segment "model"') : (o.modelSegs = o.segs.slice(s + 1), 
                o.contextSegs = o.segs.slice(0, s), delete o.path);
            } else o = {
                path: r,
                modelSegs: e.applier.parseEL(r)
            }; else t.isArrayable(r.segs) || i(' must contain an entry "segs" holding path segments referring a model path within a component'), 
            o = {
                context: r.context,
                modelSegs: t.expandOptions(r.segs, e)
            };
            var l, c;
            return o.context ? ((l = t.resolveContext(o.context, e)) || i(" context must be a reference to an existing component"), 
            c = o.contextSegs ? t.getForComponent(l, o.contextSegs) : l) : c = e, o.nonModel || (t.isComponent(c) || u(c), 
            c.applier || t.getForComponent(c, [ "applier" ]), c.applier || u(c)), o.that = c, 
            o.applier = c && c.applier, o.path || (o.path = c && c.applier.composeSegments.apply(null, o.modelSegs)), 
            o;
        }, t.getModelTransactionRec = function(e, n) {
            var r = t.getInstantiator(e);
            if (n || t.fail("Cannot get transaction record without transaction id"), !r) return null;
            var a = r.modelTransactions[n];
            return a || (a = r.modelTransactions[n] = {
                relays: [],
                sources: {},
                externalChanges: {}
            }), a;
        }, t.recordChangeListener = function(e, n, r, a) {
            var o = t.shadowForComponent(e);
            t.recordListener(n.modelChanged, r, o, a);
        }, t.registerRelayTransaction = function(e, n, r, a, o) {
            var i = n.initiate("relay", null, r), u = e[n.applierId] = {
                transaction: i,
                relayCount: 0,
                namespace: o.namespace,
                priority: o.priority,
                options: a
            };
            return u.priority = t.parsePriority(u.priority, e.relays.length, !1, "model relay"), 
            e.relays.push(u), u;
        }, t.relayRecursionBailout = 100, t.registerDirectChangeRelay = function(e, n, r, a, o, i, u, s) {
            var l = u.targetApplier || e.applier, c = u.sourceApplier || r.applier, d = l.applierId;
            n = t.makeArray(n);
            var f, p = function(r, c, f, p, m, g) {
                var h = m.id, v = t.getModelTransactionRec(e, h);
                g && m && !v[g.applierId] && (v[g.applierId] = {
                    transaction: m
                });
                var y = v[d];
                v[o] = v[o] || 0;
                ++v[o], v[o] > t.relayRecursionBailout && t.fail("Error in model relay specification at component ", e, " - operated more than " + t.relayRecursionBailout + " relays without model value settling - current model contents are ", m.newHolder.model), 
                y || (y = t.registerRelayTransaction(v, l, h, u, s)), i && !u.targetApplier ? i(y.transaction, u.sourceApplier ? void 0 : r, a, n, p) : (!u.noRelayDeletesDirect && p && "DELETE" === p.type && y.transaction.fireChangeRequest({
                    type: "DELETE",
                    segs: n
                }), void 0 !== r && y.transaction.fireChangeRequest({
                    type: "ADD",
                    segs: n,
                    value: r
                }));
            };
            (a = a ? t.makeArray(a) : a) && (f = c.modelChanged.addListener({
                isRelay: !0,
                segs: a,
                transactional: u.transactional
            }, p), t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Adding relay listener with listenerId " + f.listenerId + " to source applier with id " + c.applierId + " from target applier with id " + d + " for target component with id " + e.id)), 
            r && (t.recordChangeListener(r, c, p, f.listenerId), e !== r && t.recordChangeListener(e, c, p, f.listenerId));
        }, t.connectModelRelay = function(e, n, r, a, o) {
            function i(e) {
                var n = t.enlistModelComponent(e);
                n.complete && t.shadowForComponent(e).modelComplete && (n.completeOnInit = !0);
            }
            var u = t.allocateGuid();
            i(r), i(e);
            var s = t.filterKeys(o, [ "namespace", "priority" ]);
            o.update ? o.targetApplier ? t.registerDirectChangeRelay(e, n, r, a, u, null, {
                transactional: !1,
                targetApplier: o.targetApplier,
                update: o.update
            }, s) : t.registerDirectChangeRelay(r, a, e, [], u + "-transform", o.forwardAdapter, {
                transactional: !0,
                sourceApplier: o.forwardApplier
            }, s) : (t.registerDirectChangeRelay(r, a, e, n, u, o.forwardAdapter, {
                transactional: !1
            }, s), n && t.registerDirectChangeRelay(e, n, r, a, u, o.backwardAdapter, {
                transactional: !1
            }, s));
        }, t.parseSourceExclusionSpec = function(e, n) {
            return e.excludeSource = t.arrayToHash(t.makeArray(n.excludeSource || (n.includeSource ? "*" : void 0))), 
            e.includeSource = t.arrayToHash(t.makeArray(n.includeSource)), e;
        }, t.isExcludedChangeSource = function(e, t) {
            if (!t || !t.excludeSource) return !1;
            var n = t.excludeSource["*"];
            for (var r in e.fullSources) t.excludeSource[r] && (n = !0), t.includeSource[r] && (n = !1);
            return n;
        }, t.model.guardedAdapter = function(e, n, r, a) {
            t.isExcludedChangeSource(e, n) || r === t.model.transform.uninvertibleTransform || r.apply(null, a);
        }, t.transformToAdapter = function(e, n) {
            var r = {};
            return r[n] = e, function(e, a, o, i, u) {
                u && "DELETE" === u.type && e.fireChangeRequest({
                    type: "DELETE",
                    path: n
                }), t.model.transformWithRules(a, r, {
                    finalApplier: e
                });
            };
        }, t.makeTransformPackage = function(e, n, r, a, o, i, u, s) {
            var l = {
                forwardHolder: {
                    model: n
                },
                backwardHolder: {
                    model: null
                }
            };
            l.generateAdapters = function(e) {
                if (l.forwardAdapterImpl = t.transformToAdapter(e ? e.newHolder.model : l.forwardHolder.model, a), 
                null !== r) {
                    var o = t.model.transform.invertConfiguration(n);
                    o !== t.model.transform.uninvertibleTransform ? (l.backwardHolder.model = o, l.backwardAdapterImpl = t.transformToAdapter(l.backwardHolder.model, r)) : l.backwardAdapterImpl = o;
                }
            }, l.forwardAdapter = function(e, n) {
                void 0 === n && l.generateAdapters(), t.model.guardedAdapter(e, o, l.forwardAdapterImpl, arguments);
            }, l.runTransform = function(e) {
                e.commit(), e.reset();
            }, l.forwardApplier = t.makeHolderChangeApplier(l.forwardHolder), l.forwardApplier.isRelayApplier = !0, 
            l.invalidator = t.makeEventFirer({
                name: "Invalidator for model relay with applier " + l.forwardApplier.applierId
            }), null !== r && (l.backwardApplier = t.makeHolderChangeApplier(l.backwardHolder), 
            l.backwardAdapter = function(e) {
                t.model.guardedAdapter(e, i, l.backwardAdapterImpl, arguments);
            }), l.update = l.invalidator.fire;
            var c = {
                targetApplier: l.forwardApplier,
                update: l.update,
                namespace: u,
                priority: s,
                refCount: 0
            };
            return l.forwardHolder.model = t.parseImplicitRelay(e, n, [], c), l.refCount = c.refCount, 
            l.namespace = u, l.priority = s, l.generateAdapters(), l.invalidator.addListener(l.generateAdapters), 
            l.invalidator.addListener(l.runTransform), l;
        }, t.singleTransformToFull = function(t) {
            return {
                "": {
                    transform: e.extend(!0, {
                        inputPath: ""
                    }, t)
                }
            };
        }, t.model.relayConditions = {
            initOnly: {
                includeSource: "init"
            },
            liveOnly: {
                excludeSource: "init"
            },
            never: {
                includeSource: []
            },
            always: {}
        }, t.model.parseRelayCondition = function(e) {
            "initOnly" === e ? t.log(t.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'includeSource: "init"\' instead') : "liveOnly" === e && t.log(t.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'excludeSource: "init"\' instead');
            var n;
            return e ? "string" == typeof e ? (n = t.model.relayConditions[e]) || t.fail('Unrecognised model relay condition string "' + e + '": the supported values are "never" or a record with members "includeSource" and/or "excludeSource"') : n = e : n = {}, 
            t.parseSourceExclusionSpec({}, n);
        }, t.parseModelRelay = function(e, n, r) {
            var a = void 0 !== n.source ? t.parseValidModelReference(e, 'modelRelay record member "source"', n.source) : {
                path: null,
                modelSegs: null
            }, o = t.parseValidModelReference(e, 'modelRelay record member "target"', n.target), i = n.namespace || r, u = n.singleTransform ? t.singleTransformToFull(n.singleTransform) : n.transform;
            u || t.fail('Cannot parse modelRelay record without element "singleTransform" or "transform":', n);
            var s = t.model.parseRelayCondition(n.forward), l = t.model.parseRelayCondition(n.backward), c = t.makeTransformPackage(e, u, a.path, o.path, s, l, i, n.priority), d = {
                noRelayDeletesDirect: !0
            };
            0 === c.refCount ? t.connectModelRelay(a.that || e, a.modelSegs, o.that, o.modelSegs, t.filterKeys(c, [ "forwardAdapter", "backwardAdapter", "namespace", "priority" ]), d) : (a.modelSegs && t.fail('Error in model relay definition: If a relay transform has a model dependency, you can not specify a "source" entry - please instead enter this as "input" in the transform specification. Definition was ', n, " for component ", e), 
            t.connectModelRelay(a.that || e, a.modelSegs, o.that, o.modelSegs, c));
        }, t.parseImplicitRelay = function(e, n, r, a) {
            var o;
            if (t.isIoCReference(n)) {
                var i = t.parseValidModelReference(e, "model reference from model (implicit relay)", n, !0);
                i.nonModel ? o = t.getForComponent(i.that, i.segs) : (++a.refCount, t.connectModelRelay(e, r, i.that, i.modelSegs, a));
            } else t.isPrimitive(n) || !t.isPlainObject(n) ? o = n : n.expander && t.isPlainObject(n.expander) ? o = t.expandOptions(n, e) : (o = t.freshContainer(n), 
            t.each(n, function(n, i) {
                r.push(i);
                var u = t.parseImplicitRelay(e, n, r, a);
                void 0 !== u && (o[i] = u), r.pop();
            }));
            return o;
        }, t.model.notifyExternal = function(e) {
            var n = e ? t.values(e.externalChanges) : [];
            t.sortByPriority(n);
            for (var r = 0; r < n.length; ++r) {
                var a = n[r];
                a.args[5].destroyed || a.listener.apply(null, a.args);
            }
            t.clearLinkCounts(e, !0);
        }, t.model.commitRelays = function(e, n) {
            var r = e.modelTransactions[n];
            t.each(r, function(e) {
                e.transaction && (e.transaction.commit("relay"), e.transaction.reset());
            });
        }, t.model.updateRelays = function(e, n) {
            var r = e.modelTransactions[n], a = 0;
            return t.sortByPriority(r.relays), t.each(r.relays, function(e) {
                e.transaction.changeRecord.changes > 0 && e.relayCount < 2 && e.options.update && (e.relayCount++, 
                t.clearLinkCounts(r), e.options.update(e.transaction, r), ++a);
            }), a;
        }, t.establishModelRelay = function(e, n, r, a, o) {
            var i = t.shadowForComponent(e);
            i.modelRelayEstablished ? t.fail("FLUID-5887 failure: Model relay initialised twice on component", e) : i.modelRelayEstablished = !0, 
            t.mergeModelListeners(e, r);
            var u = t.enlistModelComponent(e);
            t.each(a, function(n, r) {
                for (var a = 0; a < n.length; ++a) t.parseModelRelay(e, n[a], r);
            });
            var s = t.transform(n, function(n) {
                return t.parseImplicitRelay(e, n, [], {
                    refCount: 0,
                    priority: "first"
                });
            });
            u.initModels = s;
            var l = t.getInstantiator(e);
            return o.preCommit.addListener(function(e) {
                for (;t.model.updateRelays(l, e.id) > 0; ) ;
            }), o.preCommit.addListener(function(e, n, r) {
                "relay" !== r && t.model.commitRelays(l, e.id);
            }), o.postCommit.addListener(function(e, n, r) {
                "relay" !== r && (t.model.notifyExternal(l.modelTransactions[e.id]), delete l.modelTransactions[e.id]);
            }), null;
        }, t.defaults("fluid.modelComponent", {
            gradeNames: [ "fluid.component" ],
            changeApplierOptions: {
                relayStyle: !0,
                cullUnchanged: !0
            },
            members: {
                model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
                applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
                modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
            },
            mergePolicy: {
                model: {
                    noexpand: !0,
                    func: t.arrayConcatPolicy
                },
                modelListeners: t.makeMergeListenersPolicy(t.arrayConcatPolicy),
                modelRelay: t.makeMergeListenersPolicy(t.arrayConcatPolicy, !0)
            }
        }), t.modelChangedToChange = function(e) {
            return {
                value: e[0],
                oldValue: e[1],
                path: e[2],
                transaction: e[4]
            };
        }, t.event.invokeListener = function(e, n, r, a) {
            return "string" == typeof e && (e = t.event.resolveListener(e)), e.apply(null, n, r, a);
        }, t.resolveModelListener = function(e, n) {
            var r = function() {
                if (!t.isDestroyed(e)) {
                    var r = t.modelChangedToChange(arguments), a = arguments, o = {
                        change: r,
                        arguments: a
                    }, i = {
                        source: Object.keys(r.transaction.sources)
                    };
                    n.args && (a = t.expandOptions(n.args, e, {}, o)), t.event.invokeListener(n.listener, t.makeArray(a), o, i);
                }
            };
            return t.event.impersonateListener(n.listener, r), r;
        }, t.registerModelListeners = function(e, n, r, a) {
            var o = t.resolveModelListener(e, n);
            t.each(n.byTarget, function(r) {
                var i = r[0], u = {
                    listener: o,
                    listenerId: t.allocateGuid(),
                    segsArray: t.getMembers(r, "modelSegs"),
                    pathArray: t.getMembers(r, "path"),
                    includeSource: n.includeSource,
                    excludeSource: n.excludeSource,
                    priority: t.expandOptions(n.priority, e),
                    transactional: !0
                };
                u = i.applier.modelChanged.addListener(u, o, a, n.softNamespace), t.recordChangeListener(e, i.applier, o, u.listenerId), 
                e === i.that || t.isModelComplete(e) || t.getForComponent(e, [ "events", "onCreate" ]).addListener(function() {
                    if (t.isModelComplete(i.that)) {
                        var n = i.applier.initiate(null, "init");
                        t.initModelEvent(e, i.applier, n, [ u ]), n.commit();
                    }
                });
            });
        }, t.mergeModelListeners = function(e, n) {
            t.each(n, function(n, r) {
                "string" == typeof n && (n = {
                    funcName: n
                });
                var a = t.event.resolveListenerRecord(n, e, "modelListeners", null, !1).records;
                t.each(a, function(n) {
                    n.byTarget = {};
                    var a = t.makeArray(void 0 === n.path ? r : n.path);
                    t.each(a, function(r) {
                        var a = t.parseValidModelReference(e, "modelListeners entry", r);
                        t.pushArray(n.byTarget, a.that.id, a);
                    });
                    var o = (n.namespace && !n.softNamespace ? n.namespace : null) || (void 0 !== n.path ? r : null);
                    t.registerModelListeners(e, n, a, o);
                });
            });
        }, t.fireChanges = function(e, t) {
            for (var n = 0; n < t.length; ++n) e.fireChangeRequest(t[n]);
        }, t.model.isChangedPath = function(e, t) {
            for (var n = 0; n <= t.length; ++n) {
                if ("string" == typeof e) return !0;
                n < t.length && e && (e = e[t[n]]);
            }
            return !1;
        }, t.model.setChangedPath = function(e, n, r) {
            var a = function(a) {
                n.unshift(a), t.model.setSimple(e, n, r), n.shift();
            };
            t.model.isChangedPath(e.changeMap, n) || (++e.changes, a("changeMap")), t.model.isChangedPath(e.deltaMap, n) || (++e.deltas, 
            a("deltaMap"));
        }, t.model.fetchChangeChildren = function(e, n, r, a, o) {
            t.each(a, function(a, i) {
                r[n] = i, t.model.applyChangeStrategy(e, i, n, r, a, o), r.length = n;
            });
        }, t.model.isSameValue = function(e, t) {
            return "number" != typeof e || "number" != typeof t ? e === t : e === t || e !== e && t !== t || Math.abs((e - t) / t) < 1e-12;
        }, t.model.applyChangeStrategy = function(e, n, r, a, o, i) {
            var u = e[n], s = t.typeCode(o), l = t.typeCode(u), c = t.NO_VALUE;
            "primitive" === s ? t.model.isSameValue(u, o) || (c = o, ++i.unchanged) : (l !== s || "array" === s && o.length !== u.length) && (c = t.freshContainer(o)), 
            c !== t.NO_VALUE && (e[n] = c, i.changeMap && t.model.setChangedPath(i, a, i.inverse ? "DELETE" : "ADD")), 
            "primitive" !== s && t.model.fetchChangeChildren(e[n], r + 1, a, o, i);
        }, t.model.stepTargetAccess = function(e, n, r, a, o, i) {
            for (var u = a; u < o; ++u) e && e[r[u]] !== (e = t.model.traverseWithStrategy(e, r, u, i["ADD" === n ? "resolverSetConfig" : "resolverGetConfig"], r.length - u - 1)) && i.changeMap && t.model.setChangedPath(i, r.slice(0, u + 1), "ADD");
            return {
                root: e,
                last: r[o]
            };
        }, t.model.defaultAccessorConfig = function(e) {
            return e = e || {}, e.resolverSetConfig = e.resolverSetConfig || t.model.escapedSetConfig, 
            e.resolverGetConfig = e.resolverGetConfig || t.model.escapedGetConfig, e;
        }, t.model.applyHolderChangeRequest = function(e, n, r) {
            (r = t.model.defaultAccessorConfig(r)).deltaMap = r.changeMap ? {} : null, r.deltas = 0;
            var a, o = n.segs.length, i = 0 === o;
            if (i ? a = {
                root: e,
                last: "model"
            } : (e.model || (e.model = {}, t.model.setChangedPath(r, [], r.inverse ? "DELETE" : "ADD")), 
            a = t.model.stepTargetAccess(e.model, n.type, n.segs, 0, o - 1, r)), "ADD" === n.type) {
                var u = n.value, s = t.makeArray(n.segs);
                t.model.applyChangeStrategy(a.root, a.last, o - 1, s, u, r, i);
            } else "DELETE" === n.type ? a.root && void 0 !== a.root[a.last] && (delete a.root[a.last], 
            r.changeMap && t.model.setChangedPath(r, n.segs, "DELETE")) : t.fail("Unrecognised change type of " + n.type);
            return r.deltas ? r.deltaMap : null;
        }, t.model.diff = function(e, n, r) {
            r = r || {
                changes: 0,
                unchanged: 0,
                changeMap: {}
            };
            var a, o = t.typeCode(e), i = t.typeCode(n);
            if ("primitive" === o && "primitive" === i) a = t.model.isSameValue(e, n); else if ("primitive" === o ^ "primitive" === i) a = !1; else {
                var u = {
                    model: t.copy(e)
                };
                t.model.applyHolderChangeRequest(u, {
                    value: n,
                    segs: [],
                    type: "ADD"
                }, r);
                var s = {
                    model: t.copy(n)
                };
                r.inverse = !0, t.model.applyHolderChangeRequest(s, {
                    value: e,
                    segs: [],
                    type: "ADD"
                }, r), a = 0 === r.changes;
            }
            return !1 === a && 0 === r.changes ? (r.changes = 1, r.changeMap = void 0 === n ? "DELETE" : "ADD") : !0 === a && 0 === r.unchanged && (r.unchanged = 1), 
            a;
        }, t.outputMatches = function(e, n, r) {
            t.each(r, function(t, r) {
                e.push(n.concat(r));
            });
        }, t.matchChanges = function(e, n, r, a) {
            for (var o = r.model, i = a.model, u = e, s = [ "model" ], l = !1, c = [], d = 0; d < n.length; ++d) {
                var f = n[d];
                "*" === f ? d === n.length - 1 ? l = !0 : t.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + n.join(".")) : (s.push(f), 
                u = t.isPrimitive(u) ? u : u[f], o = o ? o[f] : void 0, i = i ? i[f] : void 0);
            }
            return u && (l ? "DELETE" === u ? t.outputMatches(c, s, i) : "ADD" === u ? t.outputMatches(c, s, o) : t.outputMatches(c, s, u) : c.push(s)), 
            c;
        }, t.storeExternalChange = function(e, t, n, r, a) {
            var o = t.composeSegments.apply(null, n), i = [ t.holder.id, r.listenerId, r.wildcard ? o : "" ].join("|");
            e.externalChanges[i] = {
                listener: r.listener,
                namespace: r.namespace,
                priority: r.priority,
                args: a
            };
        }, t.notifyModelChanges = function(e, n, r, a, o, i, u, s) {
            if (e) for (var l = i && t.getModelTransactionRec(s, i.id), c = 0; c < e.length; ++c) for (var d = e[c], f = d.segsArray.length > 1, p = 0; p < d.segsArray.length; ++p) for (var m = t.matchChanges(n, d.segsArray[p], r, a), g = 0; g < m.length; ++g) {
                if (u.destroyed) return;
                var h = m[g];
                d.listener = t.event.resolveListener(d.listener);
                var v = [ f ? r.model : t.model.getSimple(r, h), f ? a.model : t.model.getSimple(a, h), f ? [] : h.slice(1), o, i, u ];
                if (!d.isRelay) {
                    if (t.model.diff(v[0], v[1])) continue;
                    if (t.isExcludedChangeSource(i, d)) continue;
                }
                l && !d.isRelay && d.transactional ? t.storeExternalChange(l, u, h, d, v) : d.listener.apply(null, v);
            }
        }, t.bindELMethods = function(e) {
            e.parseEL = function(n) {
                return t.model.pathToSegments(n, e.options.resolverSetConfig);
            }, e.composeSegments = function() {
                return e.options.resolverSetConfig.parser.compose.apply(null, arguments);
            };
        }, t.initModelEvent = function(e, n, r, a) {
            t.notifyModelChanges(a, "ADD", r.oldHolder, t.emptyHolder, null, r, n, e);
        }, t.emptyHolder = t.freezeRecursive({
            model: void 0
        }), t.preFireChangeRequest = function(e, t) {
            t.type || (t.type = "ADD"), t.segs = t.segs || e.parseEL(t.path);
        }, t.bindRequestChange = function(e) {
            e.change = function(t, n, r, a) {
                var o = {
                    path: t,
                    value: n,
                    type: r,
                    source: a
                };
                e.fireChangeRequest(o);
            };
        }, t.isObjectSimple = function(e) {
            return "[object Object]" === Object.prototype.toString.call(e);
        }, t.mergeChangeSources = function(e, n) {
            t.isObjectSimple(n) ? t.extend(e, n) : t.each(t.makeArray(n), function(t) {
                e[t] = !0;
            });
        }, t.ChangeApplier = function() {}, t.makeHolderChangeApplier = function(n, r) {
            r = t.model.defaultAccessorConfig(r);
            var a = t.allocateGuid(), o = new t.ChangeApplier(), i = t.isComponent(n) ? "ChangeApplier for component " + t.dumpThat(n) : "ChangeApplier with id " + a;
            return e.extend(o, {
                applierId: a,
                holder: n,
                listeners: t.makeEventFirer({
                    name: "Internal change listeners for " + i
                }),
                transListeners: t.makeEventFirer({
                    name: "External change listeners for " + i
                }),
                options: r,
                modelChanged: {},
                preCommit: t.makeEventFirer({
                    name: "preCommit event for " + i
                }),
                postCommit: t.makeEventFirer({
                    name: "postCommit event for " + i
                })
            }), o.destroy = function() {
                o.preCommit.destroy(), o.postCommit.destroy(), o.destroyed = !0;
            }, o.modelChanged.addListener = function(e, n, r, a) {
                return (e = "string" == typeof e ? {
                    path: e
                } : t.copy(e)).listenerId = e.listenerId || t.allocateGuid(), e.namespace = r, e.softNamespace = a, 
                "string" == typeof n && (n = {
                    globalName: n
                }), e.listener = n, !1 !== e.transactional && (e.transactional = !0), e.segsArray || (void 0 !== e.path && (e.segs = e.segs || o.parseEL(e.path)), 
                e.segsArray || (e.segsArray = [ e.segs ])), t.parseSourceExclusionSpec(e, e), e.wildcard = t.accumulate(t.transform(e.segsArray, function(e) {
                    return t.contains(e, "*");
                }), t.add, 0), e.wildcard && e.segsArray.length > 1 && t.fail("Error in model listener specification ", e, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched"), 
                o[e.transactional ? "transListeners" : "listeners"].addListener(e), e;
            }, o.modelChanged.removeListener = function(e) {
                o.listeners.removeListener(e), o.transListeners.removeListener(e);
            }, o.fireChangeRequest = function(e) {
                var t = o.initiate("local", e.source);
                t.fireChangeRequest(e), t.commit();
            }, o.initiate = function(e, a, i) {
                var u = "relay" === (e = "init" === a ? null : e || "local"), s = {
                    instanceId: t.allocateGuid(),
                    id: i || t.allocateGuid(),
                    changeRecord: {
                        resolverSetConfig: r.resolverSetConfig,
                        resolverGetConfig: r.resolverGetConfig
                    },
                    reset: function() {
                        s.oldHolder = n, s.newHolder = {
                            model: t.copy(n.model)
                        }, s.changeRecord.changes = 0, s.changeRecord.unchanged = 0, s.changeRecord.changeMap = {};
                    },
                    commit: function(e) {
                        if (o.preCommit.fire(s, o, e), s.changeRecord.changes > 0) {
                            var r = {
                                model: n.model
                            };
                            n.model = s.newHolder.model, t.notifyModelChanges(o.transListeners.sortedListeners, s.changeRecord.changeMap, n, r, null, s, o, n);
                        }
                        u || o.postCommit.fire(s, o, e);
                    },
                    fireChangeRequest: function(e) {
                        t.preFireChangeRequest(o, e), e.transactionId = s.id;
                        var r = t.model.applyHolderChangeRequest(s.newHolder, e, s.changeRecord);
                        t.notifyModelChanges(o.listeners.sortedListeners, r, s.newHolder, n, e, s, o, n);
                    },
                    hasChangeSource: function(e) {
                        return s.fullSources[e];
                    }
                }, l = t.getModelTransactionRec(n, s.id);
                return l && (t.mergeChangeSources(l.sources, a), s.sources = l.sources, s.fullSources = Object.create(l.sources), 
                s.fullSources[e] = !0), s.reset(), t.bindRequestChange(s), s;
            }, t.bindRequestChange(o), t.bindELMethods(o), o;
        }, t.modelPairToChanges = function(e, n, r) {
            r = r || "";
            var a = {
                changes: 0,
                unchanged: 0,
                changeMap: {}
            };
            t.model.diff(n, e, a);
            var o = [];
            return t.modelPairToChangesImpl(e, t.pathUtil.parseEL(r), a.changeMap, [], o), o;
        }, t.modelPairToChangesImpl = function(e, n, r, a, o) {
            "ADD" === r ? o.push({
                path: n,
                value: e,
                type: "ADD"
            }) : "DELETE" === r ? o.push({
                path: n,
                value: null,
                type: "DELETE"
            }) : t.isPlainObject(r, !0) && t.each(r, function(r, i) {
                var u = a.concat([ i ]);
                "ADD" === r ? o.push({
                    path: n.concat(u),
                    value: t.get(e, u),
                    type: "ADD"
                }) : "DELETE" === r ? o.push({
                    path: n.concat(u),
                    value: null,
                    type: "DELETE"
                }) : t.isPlainObject(r, !0) && t.modelPairToChangesImpl(e, n, r, u, o);
            });
        };
    }(t, n = n || {});
    var n = n || {}, r = r || n;
    !function(e, t) {
        "use strict";
        t.registerNamespace("fluid.model.transform"), t.defaults("fluid.transformFunction", {
            gradeNames: "fluid.function"
        }), t.defaults("fluid.standardInputTransformFunction", {
            gradeNames: "fluid.transformFunction"
        }), t.defaults("fluid.standardOutputTransformFunction", {
            gradeNames: "fluid.transformFunction"
        }), t.defaults("fluid.multiInputTransformFunction", {
            gradeNames: "fluid.transformFunction"
        }), t.defaults("fluid.standardTransformFunction", {
            gradeNames: [ "fluid.standardInputTransformFunction", "fluid.standardOutputTransformFunction" ]
        }), t.defaults("fluid.lens", {
            gradeNames: "fluid.transformFunction",
            invertConfiguration: null
        }), t.model.transform.pathToRule = function(e) {
            return {
                transform: {
                    type: "fluid.transforms.value",
                    inputPath: e
                }
            };
        }, t.model.transform.literalValueToRule = function(e) {
            return {
                transform: {
                    type: "fluid.transforms.literalValue",
                    input: e
                }
            };
        }, t.model.composePaths = function(e, t) {
            return e = 0 === e ? "0" : e || "", t = 0 === t ? "0" : t || "", e ? t ? e + "." + t : e : t;
        }, t.model.transform.accumulateInputPath = function(e, n, r) {
            void 0 !== e && r.push(t.model.composePaths(n.inputPrefix, e));
        }, t.model.transform.accumulateStandardInputPath = function(e, n, r, a) {
            t.model.transform.getValue(void 0, n[e], r), t.model.transform.accumulateInputPath(n[e + "Path"], r, a);
        }, t.model.transform.accumulateMultiInputPaths = function(e, n, r, a) {
            t.each(e, function(e, o) {
                t.model.transform.accumulateStandardInputPath(o, n, r, a);
            });
        }, t.model.transform.getValue = function(e, n, r) {
            var a;
            return void 0 !== e && (a = t.get(r.source, t.model.composePaths(r.inputPrefix, e), r.resolverGetConfig)), 
            void 0 === a && (a = t.isPrimitive(n) ? n : "literalValue" in n ? n.literalValue : void 0 === n.transform ? n : r.expand(n)), 
            a;
        }, t.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN = {}, t.model.transform.setValue = function(e, n, r) {
            var a = t.copy(n), o = t.model.composePaths(r.outputPrefix, e);
            return void 0 !== a && r.applier.change(o, a), e ? t.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN : a;
        }, t.model.transform.resolveParam = function(e, n, r, a) {
            var o = t.model.transform.getValue(e[r + "Path"], e[r], n);
            return void 0 !== o ? o : a;
        }, t.model.transform.matchValue = function(e, n, r) {
            var a = {
                changes: 0,
                unchanged: 0,
                changeMap: {}
            };
            return t.model.diff(e, n, a), 0 === a.unchanged ? 0 : r ? 0xffffff000000 - 16777216 * a.changes + a.unchanged : a.changes ? 0 : 0xffffff000000 + a.unchanged;
        }, t.model.transform.invertPaths = function(e, n) {
            var r = t.model.composePaths(n.outputPrefix, e.outputPath);
            return e.outputPath = t.model.composePaths(n.inputPrefix, e.inputPath), e.inputPath = r, 
            e;
        }, t.model.transform.prefixApplier = function(e, t) {
            e.inputPrefix && t.inputPrefixOp.push(e.inputPrefix), e.outputPrefix && t.outputPrefixOp.push(e.outputPrefix), 
            t.expand(e.input), e.inputPrefix && t.inputPrefixOp.pop(), e.outputPrefix && t.outputPrefixOp.pop();
        }, t.defaults("fluid.model.transform.prefixApplier", {
            gradeNames: [ "fluid.transformFunction" ]
        }), t.model.makePathStack = function(e, n) {
            var r = e[n + "Stack"] = [];
            return e[n] = "", {
                push: function(a) {
                    var o = t.model.composePaths(e[n], a);
                    r.push(e[n]), e[n] = o;
                },
                pop: function() {
                    e[n] = r.pop();
                }
            };
        }, t.model.transform.doTransform = function(e, n, r) {
            var a = r.defaults, o = t.getGlobalValue(r.typeName);
            "function" != typeof o && t.fail("Transformation record specifies transformation function with name " + e.type + " which is not a function - ", o), 
            t.hasGrade(a, "fluid.transformFunction") || (a = t.defaults("fluid.standardTransformFunction"));
            var i = [ e, n ];
            if (t.hasGrade(a, "fluid.multiInputTransformFunction")) {
                var u = {};
                t.each(a.inputVariables, function(r, a) {
                    u[a] = function() {
                        var o = t.model.transform.getValue(e[a + "Path"], e[a], n);
                        return o = void 0 === o && null !== r ? r : o;
                    };
                }), i.unshift(u);
            }
            if (t.hasGrade(a, "fluid.standardInputTransformFunction")) {
                "input" in e || "inputPath" in e || t.fail('Error in transform specification. Either "input" or "inputPath" must be specified for a standardInputTransformFunction: received ', e);
                var s = t.model.transform.getValue(e.inputPath, e.input, n);
                if (i.unshift(s), void 0 === s) return;
            }
            var l = o.apply(null, i);
            return t.hasGrade(a, "fluid.standardOutputTransformFunction") && void 0 !== (void 0 !== e.outputPath ? e.outputPath : r.doOutput ? "" : void 0) && void 0 !== l && (t.model.transform.setValue(e.outputPath, l, n), 
            l = void 0), l;
        };
        var n = [];
        t.registerNamespace("fluid.pathUtil"), t.pathUtil.getPathSegment = function(e, r) {
            return t.pathUtil.getPathSegmentImpl(n, e, r), n[0];
        }, t.pathUtil.getHeadPath = function(e) {
            return t.pathUtil.getPathSegment(e, 0);
        }, t.pathUtil.getFromHeadPath = function(e) {
            var n = t.pathUtil.getPathSegmentImpl(null, e, 0);
            return n === e.length ? "" : e.substring(n + 1);
        }, t.pathUtil.matchPath = function(e, n, r) {
            for (var a = []; ;) {
                if ("" === n ^ "" === e && r) return null;
                if (!e || !n) break;
                var o = t.pathUtil.getHeadPath(e), i = t.pathUtil.getHeadPath(n);
                if ("*" !== o && o !== i) return null;
                a.push(i), e = t.pathUtil.getFromHeadPath(e), n = t.pathUtil.getFromHeadPath(n);
            }
            return a;
        }, t.model.transform.expandWildcards = function(e, n) {
            t.each(n, function(n, r) {
                var a = e.queuedTransforms;
                e.pathOp.push(t.pathUtil.escapeSegment(r.toString()));
                for (var o = 0; o < a.length; ++o) if (t.pathUtil.matchPath(a[o].matchPath, e.path, !0)) {
                    var i = t.copy(a[o].transformSpec);
                    (void 0 === i.inputPath || t.model.transform.hasWildcard(i.inputPath)) && (i.inputPath = ""), 
                    e.inputPrefixOp.push(e.path), e.outputPrefixOp.push(e.path);
                    var u = t.model.transform.lookupType(i.type), s = t.model.transform.doTransform(i, e, u);
                    void 0 !== s && t.model.transform.setValue(null, s, e), e.outputPrefixOp.pop(), 
                    e.inputPrefixOp.pop();
                }
                t.isPrimitive(n) || t.model.transform.expandWildcards(e, n), e.pathOp.pop();
            });
        }, t.model.transform.hasWildcard = function(e) {
            return "string" == typeof e && -1 !== e.indexOf("*");
        }, t.model.transform.maybePushWildcard = function(e, n) {
            var r, a = t.model.transform.hasWildcard;
            return a(e.inputPath) ? r = t.model.composePaths(n.inputPrefix, e.inputPath) : (a(n.outputPrefix) || a(e.outputPath)) && (r = t.model.composePaths(n.outputPrefix, e.outputPath)), 
            !!r && (n.queuedTransforms.push({
                transformSpec: e,
                outputPrefix: n.outputPrefix,
                inputPrefix: n.inputPrefix,
                matchPath: r
            }), !0);
        }, t.model.sortByKeyLength = function(e) {
            return t.keys(e).sort(t.compareStringLength(!0));
        }, t.model.transform.handleTransformStrategy = function(e, n, r) {
            return t.model.transform.maybePushWildcard(e, n) ? void 0 : t.model.transform.doTransform(e, n, r);
        }, t.model.transform.handleInvertStrategy = function(e, n, r) {
            e = t.copy(e), t.hasGrade(r.defaults, "fluid.standardTransformFunction") && (e = t.model.transform.invertPaths(e, n));
            var a = r.defaults && r.defaults.invertConfiguration;
            if (a) {
                var o = t.invokeGlobalFunction(a, [ e, n ]);
                n.inverted.push(o);
            } else n.inverted.push(t.model.transform.uninvertibleTransform);
        }, t.model.transform.handleCollectStrategy = function(e, n, r) {
            var a = r.defaults, o = t.hasGrade(a, "fluid.standardInputTransformFunction"), i = t.hasGrade(a, "fluid.multiInputTransformFunction");
            if (o && t.model.transform.accumulateStandardInputPath("input", e, n, n.inputPaths), 
            i && t.model.transform.accumulateMultiInputPaths(a.inputVariables, e, n, n.inputPaths), 
            !i && !o) {
                var u = a.collectInputPaths;
                if (u) {
                    var s = t.makeArray(t.invokeGlobalFunction(u, [ e, n ]));
                    Array.prototype.push.apply(n.inputPaths, s);
                }
            }
        }, t.model.transform.lookupType = function(e, n) {
            return e || t.fail("Transformation record is missing a type name: ", n), -1 === e.indexOf(".") && (e = "fluid.transforms." + e), 
            {
                defaults: t.defaults(e),
                typeName: e
            };
        }, t.model.transform.processRule = function(e, n) {
            "string" == typeof e ? e = t.model.transform.pathToRule(e) : void 0 !== e.literalValue && (e = t.model.transform.literalValueToRule(e.literalValue));
            var r;
            if (e.transform) {
                var a, o;
                if (t.isArrayable(e.transform)) {
                    var i = e.transform;
                    r = void 0;
                    for (var u = 0; u < i.length; ++u) a = i[u], o = t.model.transform.lookupType(a.type), 
                    n.transformHandler(a, n, o);
                } else a = e.transform, o = t.model.transform.lookupType(a.type), r = n.transformHandler(a, n, o);
            }
            return t.isArrayable(e) && (n.collectedFlatSchemaOpts = n.collectedFlatSchemaOpts || {}, 
            n.collectedFlatSchemaOpts[n.outputPrefix] = "array"), t.each(e, function(e, r) {
                if ("transform" !== r) {
                    n.outputPrefixOp.push(r);
                    var a = n.expand(e, n);
                    void 0 !== a && (t.model.transform.setValue(null, a, n), a = void 0), n.outputPrefixOp.pop();
                }
            }), r;
        }, t.model.transform.makeStrategy = function(e, n, r) {
            r = r || t.model.transform.processRule, e.expand = function(t) {
                return r(t, e);
            }, e.outputPrefixOp = t.model.makePathStack(e, "outputPrefix"), e.inputPrefixOp = t.model.makePathStack(e, "inputPrefix"), 
            e.transformHandler = n;
        }, t.model.transform.uninvertibleTransform = Object.freeze({}), t.model.transform.invertConfiguration = function(e) {
            var n = {
                inverted: []
            };
            return t.model.transform.makeStrategy(n, t.model.transform.handleInvertStrategy), 
            n.expand(e), -1 === n.inverted.indexOf(t.model.transform.uninvertibleTransform) ? {
                transform: n.inverted
            } : t.model.transform.uninvertibleTransform;
        }, t.model.transform.collectInputPaths = function(e) {
            var n = {
                inputPaths: []
            };
            return t.model.transform.makeStrategy(n, t.model.transform.handleCollectStrategy), 
            n.expand(e), n.inputPaths;
        }, t.model.transform.flatSchemaStrategy = function(e, n) {
            var r = t.model.sortByKeyLength(e);
            return function(a, o, i, u) {
                for (var s = n.parser.compose.apply(null, u.slice(0, i)), l = 0; l < r.length; ++l) {
                    var c = r[l];
                    if (null !== t.pathUtil.matchPath(c, s, !0)) return e[c];
                }
            };
        }, t.model.transform.defaultSchemaValue = function(e) {
            return "array" === (t.isPrimitive(e) ? e : e.type) ? [] : {};
        }, t.model.transform.isomorphicSchemaStrategy = function(e, n) {
            return function(r, a, o, i) {
                var u = t.get(e, i.slice(0, o), n);
                return t.isArrayable(u) ? "array" : "object";
            };
        }, t.model.transform.decodeStrategy = function(e, n, r) {
            return n.isomorphic ? t.model.transform.isomorphicSchemaStrategy(e, r) : n.flatSchema ? t.model.transform.flatSchemaStrategy(n.flatSchema, r) : void 0;
        }, t.model.transform.schemaToCreatorStrategy = function(e) {
            return function(n, r, a, o) {
                if (void 0 === n[r]) {
                    var i = e(n, r, a, o);
                    return n[r] = t.model.transform.defaultSchemaValue(i), n[r];
                }
            };
        }, t.model.transform.sequence = function(e, n, r) {
            for (var a = 0; a < n.length; ++a) e = t.model.transform(e, n[a], r);
            return e;
        }, t.model.compareByPathLength = function(e, t) {
            var n = e.path.length - t.path.length;
            return 0 === n ? e.sequence - t.sequence : n;
        }, t.model.fireSortedChanges = function(e, n) {
            e.sort(t.model.compareByPathLength), t.fireChanges(n, e);
        }, t.model.transformWithRules = function(n, r, a) {
            a = a || {};
            var o = t.model.escapedGetConfig, i = t.model.escapedSetConfig, u = t.model.transform.decodeStrategy(n, a, o), s = {
                source: n,
                target: {
                    model: u ? t.model.transform.defaultSchemaValue(u(null, "", 0, [ "" ])) : {}
                },
                resolverGetConfig: o,
                resolverSetConfig: i,
                collectedFlatSchemaOpts: void 0,
                queuedChanges: [],
                queuedTransforms: []
            };
            t.model.transform.makeStrategy(s, t.model.transform.handleTransformStrategy), s.applier = {
                fireChangeRequest: function(e) {
                    e.sequence = s.queuedChanges.length, s.queuedChanges.push(e);
                }
            }, t.bindRequestChange(s.applier), s.expand(r);
            var l = t.copy(i);
            return void 0 !== s.collectedFlatSchemaOpts && (e.extend(s.collectedFlatSchemaOpts, a.flatSchema), 
            u = t.model.transform.flatSchemaStrategy(s.collectedFlatSchemaOpts, o)), l.strategies = [ t.model.defaultFetchStrategy, u ? t.model.transform.schemaToCreatorStrategy(u) : t.model.defaultCreatorStrategy ], 
            s.finalApplier = a.finalApplier || t.makeHolderChangeApplier(s.target, {
                resolverSetConfig: l
            }), s.queuedTransforms.length > 0 && (s.typeStack = [], s.pathOp = t.model.makePathStack(s, "path"), 
            t.model.transform.expandWildcards(s, n)), t.model.fireSortedChanges(s.queuedChanges, s.finalApplier), 
            s.target.model;
        }, e.extend(t.model.transformWithRules, t.model.transform), t.model.transform = t.model.transformWithRules, 
        t.transformOne = function(e) {
            return {
                transformOptions: {
                    transformer: "fluid.model.transformWithRules",
                    config: e
                }
            };
        }, t.transformMany = function(e) {
            return {
                transformOptions: {
                    transformer: "fluid.model.transform.sequence",
                    config: e
                }
            };
        };
    }(t, n);
    var a = a || {}, r = r || a;
    !function(e, t) {
        "use strict";
        t.registerNamespace("fluid.model.transform"), t.registerNamespace("fluid.transforms"), 
        t.defaults("fluid.transforms.value", {
            gradeNames: "fluid.standardTransformFunction",
            invertConfiguration: "fluid.identity"
        }), t.transforms.value = t.identity, t.transforms.identity = t.transforms.value, 
        t.defaults("fluid.transforms.identity", {
            gradeNames: "fluid.transforms.value"
        }), t.transforms.invertToIdentity = function(e) {
            return e.type = "fluid.transforms.identity", e;
        }, t.defaults("fluid.transforms.literalValue", {
            gradeNames: "fluid.standardOutputTransformFunction"
        }), t.transforms.literalValue = function(e) {
            return e.input;
        }, t.defaults("fluid.transforms.stringToNumber", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.stringToNumber.invert"
        }), t.transforms.stringToNumber = function(e) {
            var t = Number(e);
            return isNaN(t) ? void 0 : t;
        }, t.transforms.stringToNumber.invert = function(e) {
            return e.type = "fluid.transforms.numberToString", e;
        }, t.defaults("fluid.transforms.numberToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.numberToString.invert"
        }), t.transforms.numberToString = function(e, n) {
            if ("number" == typeof e) return "number" != typeof n.scale || isNaN(n.scale) ? e.toString() : t.roundToDecimal(e, n.scale, n.method).toString();
        }, t.transforms.numberToString.invert = function(e) {
            return e.type = "fluid.transforms.stringToNumber", e;
        }, t.defaults("fluid.transforms.count", {
            gradeNames: "fluid.standardTransformFunction"
        }), t.transforms.count = function(e) {
            return t.makeArray(e).length;
        }, t.defaults("fluid.transforms.round", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.invertToIdentity"
        }), t.transforms.round = function(e, n) {
            return t.roundToDecimal(e, n.scale, n.method);
        }, t.defaults("fluid.transforms.delete", {
            gradeNames: "fluid.transformFunction"
        }), t.transforms.delete = function(e, n) {
            var r = t.model.composePaths(n.outputPrefix, e.outputPath);
            n.applier.change(r, null, "DELETE");
        }, t.defaults("fluid.transforms.firstValue", {
            gradeNames: "fluid.standardOutputTransformFunction"
        }), t.transforms.firstValue = function(e, n) {
            e.values && e.values.length || t.fail('firstValue transformer requires an array of values at path named "values", supplied', e);
            for (var r = 0; r < e.values.length; r++) {
                var a = e.values[r], o = n.expand(a);
                if (void 0 !== o) return o;
            }
        }, t.defaults("fluid.transforms.linearScale", {
            gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.linearScale.invert",
            inputVariables: {
                factor: 1,
                offset: 0
            }
        }), t.transforms.linearScale = function(e, t) {
            var n = t.factor(), r = t.offset();
            if ("number" == typeof e && "number" == typeof n && "number" == typeof r) return e * n + r;
        }, t.transforms.linearScale.invert = function(e) {
            return delete e.factorPath, delete e.offsetPath, void 0 !== e.factor && (e.factor = 0 === e.factor ? 0 : 1 / e.factor), 
            void 0 !== e.offset && (e.offset = -e.offset * (void 0 !== e.factor ? e.factor : 1)), 
            e;
        }, t.defaults("fluid.transforms.binaryOp", {
            gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
            inputVariables: {
                left: null,
                right: null
            }
        }), t.transforms.binaryLookup = {
            "===": function(e, n) {
                return t.model.isSameValue(e, n);
            },
            "!==": function(e, n) {
                return !t.model.isSameValue(e, n);
            },
            "<=": function(e, t) {
                return e <= t;
            },
            "<": function(e, t) {
                return e < t;
            },
            ">=": function(e, t) {
                return e >= t;
            },
            ">": function(e, t) {
                return e > t;
            },
            "+": function(e, t) {
                return e + t;
            },
            "-": function(e, t) {
                return e - t;
            },
            "*": function(e, t) {
                return e * t;
            },
            "/": function(e, t) {
                return e / t;
            },
            "%": function(e, t) {
                return e % t;
            },
            "&&": function(e, t) {
                return e && t;
            },
            "||": function(e, t) {
                return e || t;
            }
        }, t.transforms.binaryOp = function(e, n, r) {
            var a = e.left(), o = e.right(), i = t.model.transform.getValue(void 0, n.operator, r), u = t.transforms.binaryLookup[i];
            return void 0 === u || void 0 === a || void 0 === o ? void 0 : u(a, o);
        }, t.defaults("fluid.transforms.condition", {
            gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
            inputVariables: {
                true: null,
                false: null,
                condition: null
            }
        }), t.transforms.condition = function(e) {
            var t = e.condition();
            if (null !== t) return e[t ? "true" : "false"]();
        }, t.defaults("fluid.transforms.valueMapper", {
            gradeNames: [ "fluid.transformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.valueMapper.invert",
            collectInputPaths: "fluid.transforms.valueMapper.collect"
        }), t.model.transform.compareMatches = function(e, t) {
            var n = t.matchValue - e.matchValue;
            return 0 === n ? e.index - t.index : n;
        }, t.transforms.valueMapper = function(e, n) {
            e.match || t.fail('valueMapper requires an array or hash of matches at path named "match", supplied ', e);
            var r = t.model.transform.getValue(e.defaultInputPath, e.defaultInput, n), a = t.isArrayable(e.match) ? t.transforms.valueMapper.longFormMatch(r, e, n) : e.match[r];
            if (void 0 === a && (a = e.noMatch), void 0 !== a) {
                var o = void 0 === a.outputPath ? e.defaultOutputPath : a.outputPath;
                n.outputPrefixOp.push(o);
                var i;
                return i = t.isPrimitive(a) ? a : a.outputUndefinedValue ? void 0 : void 0 === (i = t.model.transform.resolveParam(a, n, "outputValue", void 0)) ? e.defaultOutputValue : i, 
                "string" == typeof o && void 0 !== i && (t.model.transform.setValue(void 0, i, n, e.merge), 
                i = void 0), n.outputPrefixOp.pop(), i;
            }
        }, t.transforms.valueMapper.longFormMatch = function(e, n, r) {
            var a = n.match;
            0 === a.length && t.fail("valueMapper supplied empty list of matches: ", n);
            for (var o = [], i = 0; i < a.length; ++i) {
                var u = a[i], s = u.inputPath ? t.model.transform.getValue(u.inputPath, void 0, r) : e, l = t.model.transform.matchValue(u.inputValue, s, u.partialMatches);
                o[i] = {
                    index: i,
                    matchValue: l
                };
            }
            return o.sort(t.model.transform.compareMatches), o[0].matchValue <= 0 ? void 0 : a[o[0].index];
        }, t.transforms.valueMapper.invert = function(e, n) {
            var r = [], a = {
                type: "fluid.transforms.valueMapper",
                match: r
            }, o = t.isArrayable(e.match);
            a.defaultInputPath = t.model.composePaths(n.outputPrefix, e.defaultOutputPath), 
            a.defaultOutputPath = t.model.composePaths(n.inputPrefix, e.defaultInputPath);
            var i = t.firstDefined;
            return t.each(e.match, function(a, u) {
                if (!0 !== a.outputUndefinedValue) {
                    var s = {}, l = i(o ? a.inputValue : u, e.defaultInputValue);
                    void 0 === l && t.fail("Failure inverting configuration for valueMapper - inputValue could not be resolved for record " + u + ": ", e), 
                    s.outputValue = l, s.inputValue = !o && t.isPrimitive(a) ? a : i(a.outputValue, e.defaultOutputValue), 
                    a.outputPath && (s.inputPath = t.model.composePaths(n.outputPrefix, i(a.outputPath, e.outputPath))), 
                    a.inputPath && (s.outputPath = t.model.composePaths(n.inputPrefix, i(a.inputPath, e.inputPath))), 
                    r.push(s);
                }
            }), a;
        }, t.transforms.valueMapper.collect = function(e, n) {
            var r = [];
            return t.model.transform.accumulateInputPath(e.defaultInputPath, n, r), t.each(e.match, function(e) {
                t.model.transform.accumulateInputPath(e.inputPath, n, r);
            }), r;
        }, t.defaults("fluid.transforms.arrayToSetMembership", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.arrayToSetMembership.invert"
        }), t.transforms.arrayToSetMembership = function(e, n, r) {
            var a = {}, o = n.options;
            return e && t.isArrayable(e) || t.fail("arrayToSetMembership didn't find array at inputPath nor passed as value.", n), 
            o || t.fail("arrayToSetMembership requires an options block set"), void 0 === n.presentValue && (n.presentValue = !0), 
            void 0 === n.missingValue && (n.missingValue = !1), t.each(o, function(o, i) {
                var u = -1 !== e.indexOf(i) ? n.presentValue : n.missingValue;
                t.set(a, o, u, r.resolverSetConfig);
            }), a;
        }, t.transforms.arrayToSetMembership.invertWithType = function(e, n, r) {
            e.type = r;
            var a = {};
            return t.each(e.options, function(e, t) {
                a[e] = t;
            }), e.options = a, e;
        }, t.transforms.arrayToSetMembership.invert = function(e, n) {
            return t.transforms.arrayToSetMembership.invertWithType(e, n, "fluid.transforms.setMembershipToArray");
        }, t.defaults("fluid.transforms.setMembershipToArray", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.setMembershipToArray.invert"
        }), t.transforms.setMembershipToArray = function(e, n, r) {
            var a = n.options;
            a || t.fail("setMembershipToArray requires an options block specified"), void 0 === n.presentValue && (n.presentValue = !0), 
            void 0 === n.missingValue && (n.missingValue = !1);
            var o = [];
            return t.each(a, function(a, i) {
                t.get(e, i, r.resolverGetConfig) === n.presentValue && o.push(a);
            }), o;
        }, t.transforms.setMembershipToArray.invert = function(e, n) {
            return t.transforms.arrayToSetMembership.invertWithType(e, n, "fluid.transforms.arrayToSetMembership");
        }, t.model.transform.applyPaths = function(e, t, n) {
            for (var r = 0; r < n.length; ++r) "push" === e ? t.push(n[r]) : t.pop();
        }, t.model.transform.expandInnerValues = function(n, r, a, o) {
            var i = a.inputPrefixOp, u = a.outputPrefixOp, s = t.model.transform.applyPaths;
            s("push", i, n), s("push", u, r);
            var l = {};
            return t.each(o, function(n) {
                var r = a.expand(n);
                t.isPrimitive(r) ? l = r : e.extend(!0, l, r);
            }), s("pop", u, r), s("pop", i, n), l;
        }, t.defaults("fluid.transforms.indexArrayByKey", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.indexArrayByKey.invert"
        }), t.transforms.indexArrayByKey = function(e, n, r) {
            void 0 === n.key && t.fail("indexArrayByKey requires a 'key' option.", n), t.isArrayable(e) || t.fail("indexArrayByKey didn't find array at inputPath.", n);
            var a = {}, o = n.key;
            return t.each(e, function(e, i) {
                var u = e[o], s = typeof u;
                "string" !== s && "boolean" !== s && "number" !== s && t.fail("indexArrayByKey encountered untransformable array due to missing or invalid key", e);
                var l = t.copy(e);
                delete l[o], n.innerValue && (l = t.model.transform.expandInnerValues([ r.inputPrefix, n.inputPath, i.toString() ], [ n.outputPath, u ], r, n.innerValue)), 
                a[u] = l;
            }), a;
        }, t.transforms.indexArrayByKey.invert = function(e) {
            if (e.type = "fluid.transforms.deindexIntoArrayByKey", e.innerValue) for (var n = e.innerValue, r = 0; r < n.length; ++r) {
                var a = t.model.transform.invertConfiguration(n[r]);
                if (a === t.model.transform.uninvertibleTransform) return a;
                n[r] = a;
            }
            return e;
        }, t.defaults("fluid.transforms.deindexIntoArrayByKey", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.deindexIntoArrayByKey.invert"
        }), t.transforms.deindexIntoArrayByKey = function(n, r, a) {
            void 0 === r.key && t.fail('deindexIntoArrayByKey requires a "key" option.', r);
            var o = [], i = r.key;
            return t.each(n, function(n, u) {
                var s = {};
                s[i] = u, r.innerValue && (n = t.model.transform.expandInnerValues([ r.inputPath, u ], [ r.outputPath, o.length.toString() ], a, r.innerValue)), 
                e.extend(!0, s, n), o.push(s);
            }), o;
        }, t.transforms.deindexIntoArrayByKey.invert = function(e) {
            if (e.type = "fluid.transforms.indexArrayByKey", e.innerValue) for (var n = e.innerValue, r = 0; r < n.length; ++r) n[r] = t.model.transform.invertConfiguration(n[r]);
            return e;
        }, t.defaults("fluid.transforms.limitRange", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.invertToIdentity"
        }), t.transforms.limitRange = function(e, t) {
            var n = t.min;
            void 0 !== n && e < (n += t.excludeMin || 0) && (e = n);
            var r = t.max;
            return void 0 !== r && e > (r -= t.excludeMax || 0) && (e = r), e;
        }, t.defaults("fluid.transforms.indexOf", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.indexOf.invert"
        }), t.transforms.indexOf = function(e, n) {
            "number" == typeof n.notFound && n.notFound >= 0 && t.fail("A positive number is not allowed as 'notFound' value for indexOf");
            var r = t.transforms.parseIndexationOffset(n.offset, "indexOf"), a = t.makeArray(n.array).indexOf(e);
            return -1 === a && n.notFound ? n.notFound : a + r;
        }, t.transforms.indexOf.invert = function(e, n) {
            var r = t.transforms.invertArrayIndexation(e, n);
            return r.type = "fluid.transforms.dereference", r;
        }, t.defaults("fluid.transforms.dereference", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.dereference.invert"
        }), t.transforms.dereference = function(e, n) {
            if ("number" == typeof e) {
                var r = t.transforms.parseIndexationOffset(n.offset, "dereference");
                return t.makeArray(n.array)[e + r];
            }
        }, t.transforms.dereference.invert = function(e, n) {
            var r = t.transforms.invertArrayIndexation(e, n);
            return r.type = "fluid.transforms.indexOf", r;
        }, t.transforms.parseIndexationOffset = function(e, n) {
            var r = 0;
            return void 0 !== e && (r = t.parseInteger(e), isNaN(r) && t.fail(n + ' requires the value of "offset" to be an integer or a string that can be converted to an integer. ' + e + " is invalid.")), 
            r;
        }, t.transforms.invertArrayIndexation = function(e) {
            return isNaN(Number(e.offset)) || (e.offset = -1 * Number(e.offset)), e;
        }, t.defaults("fluid.transforms.stringTemplate", {
            gradeNames: "fluid.standardOutputTransformFunction"
        }), t.transforms.stringTemplate = function(e) {
            return t.stringTemplate(e.template, e.terms);
        }, t.defaults("fluid.transforms.free", {
            gradeNames: "fluid.transformFunction"
        }), t.transforms.free = function(e) {
            var n = t.makeArray(e.args);
            return t.invokeGlobalFunction(e.func, n);
        }, t.defaults("fluid.transforms.quantize", {
            gradeNames: "fluid.standardTransformFunction"
        }), t.transforms.quantize = function(e, n, r) {
            n.ranges && n.ranges.length || t.fail("fluid.transforms.quantize should have a key called ranges containing an array defining ranges to quantize");
            for (var a = 0; a < n.ranges.length; a++) {
                var o = n.ranges[a];
                if (e <= o.upperBound || void 0 === o.upperBound && e >= Number.NEGATIVE_INFINITY) return t.isPrimitive(o.output) ? o.output : r.expand(o.output);
            }
        }, t.defaults("fluid.transforms.inRange", {
            gradeNames: "fluid.standardTransformFunction"
        }), t.transforms.inRange = function(e, t) {
            return (void 0 === t.min || t.min <= e) && (void 0 === t.max || t.max >= e);
        }, t.transforms.stringToBoolean = function(e) {
            return !!e && !("0" === e || "false" === e);
        }, t.transforms.stringToBoolean.invert = function(e) {
            return e.type = "fluid.transforms.booleanToString", e;
        }, t.defaults("fluid.transforms.stringToBoolean", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.stringToBoolean.invert"
        }), t.transforms.booleanToString = function(e) {
            return e ? "true" : "false";
        }, t.transforms.booleanToString.invert = function(e) {
            return e.type = "fluid.transforms.stringToBoolean", e;
        }, t.defaults("fluid.transforms.booleanToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.booleanToString.invert"
        }), t.transforms.JSONstringToObject = function(e) {
            try {
                return JSON.parse(e);
            } catch (e) {
                return;
            }
        }, t.transforms.JSONstringToObject.invert = function(e) {
            return e.type = "fluid.transforms.objectToJSONString", e;
        }, t.defaults("fluid.transforms.JSONstringToObject", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.JSONstringToObject.invert"
        }), t.transforms.objectToJSONString = function(e, t) {
            var n = t.space || 0;
            return JSON.stringify(e, null, n);
        }, t.transforms.objectToJSONString.invert = function(e) {
            return e.type = "fluid.transforms.JSONstringToObject", e;
        }, t.defaults("fluid.transforms.objectToJSONString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.objectToJSONString.invert"
        }), t.transforms.stringToDate = function(e) {
            var t = new Date(e);
            return isNaN(t.getTime()) ? void 0 : t;
        }, t.transforms.stringToDate.invert = function(e) {
            return e.type = "fluid.transforms.dateToString", e;
        }, t.defaults("fluid.transforms.stringToDate", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.stringToDate.invert"
        }), t.transforms.dateToString = function(e) {
            if (e instanceof Date) {
                var t = e.toISOString();
                return t.substring(0, t.indexOf("T"));
            }
        }, t.transforms.dateToString.invert = function(e) {
            return e.type = "fluid.transforms.stringToDate", e;
        }, t.defaults("fluid.transforms.dateToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.dateToString.invert"
        }), t.transforms.dateTimeToString = function(e) {
            return e instanceof Date ? e.toISOString() : void 0;
        }, t.defaults("fluid.transforms.dateTimeToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.dateToString.invert"
        });
    }(t, n), function(e, t) {
        "use strict";
        t.registerNamespace("fluid.contextAware"), t.defaults("fluid.contextAware.marker", {
            gradeNames: [ "fluid.component" ]
        }), t.contextAware.makeCheckMarkers = function(e, n, r) {
            t.each(e, function(e, a) {
                t.constructSingle(n, {
                    type: a,
                    gradeNames: "fluid.contextAware.marker",
                    value: e
                }, r);
            });
        }, t.contextAware.performChecks = function(e) {
            return t.transform(e, function(e) {
                return "function" == typeof e ? e = {
                    func: e
                } : "string" == typeof e && (e = {
                    funcName: e
                }), t.isPrimitive(e) ? e : "value" in e ? e.value : "func" in e ? e.func() : "funcName" in e ? t.invokeGlobalFunction(e.funcName) : void t.fail("Error in contextAwareness check record ", e, " - must contain an entry with name value, func, or funcName");
            });
        }, t.contextAware.makeChecks = function(e, n, r) {
            var a = t.contextAware.performChecks(e);
            t.contextAware.makeCheckMarkers(a, n, r);
        }, t.contextAware.forgetChecks = function(e, n, r) {
            r = r || t.globalInstantiator, n = n || [];
            var a = t.makeArray(e);
            t.each(a, function(e) {
                var a = t.typeNameToMemberName(e), o = t.model.parseToSegments(n, r.parseEL, !0);
                o.push(a), t.destroy(o, r);
            });
        }, t.defaults("fluid.contextAware", {
            gradeNames: [ "{that}.check" ],
            mergePolicy: {
                contextAwareness: "noexpand"
            },
            contextAwareness: {},
            invokers: {
                check: {
                    funcName: "fluid.contextAware.check",
                    args: [ "{that}", "{that}.options.contextAwareness" ]
                }
            }
        }), t.contextAware.getCheckValue = function(e, n) {
            var r = t.parseContextReference(n), a = t.resolveContext(r.context, e), o = r.path || [ "options", "value" ];
            return t.getForComponent(a, o);
        }, t.contextAware.checkOne = function(e, n) {
            n.checks && n.checks.contextValue && t.fail("Nesting error in contextAwareness record ", n, ' - the "checks" entry must contain a hash and not a contextValue/gradeNames record at top level');
            var r = t.parsePriorityRecords(n.checks, "contextAwareness checkRecord");
            return t.find(r, function(n) {
                n.contextValue || t.fail("Cannot perform check for contextAwareness record ", n, ' without a valid field named "contextValue"');
                var r = t.contextAware.getCheckValue(e, n.contextValue);
                if (void 0 === n.equals ? r : r === n.equals) return n.gradeNames;
            }, n.defaultGradeNames);
        }, t.contextAware.check = function(e, n) {
            var r = [], a = t.parsePriorityRecords(n, "contextAwareness adaptationRecord");
            return t.each(a, function(n) {
                var a = t.contextAware.checkOne(e, n);
                r = r.concat(t.makeArray(a));
            }), r;
        }, t.contextAware.makeAdaptation = function(e) {
            t.expect("fluid.contextAware.makeAdaptation", e, [ "distributionName", "targetName", "adaptationName", "checkName", "record" ]), 
            t.defaults(e.distributionName, {
                gradeNames: [ "fluid.component" ],
                distributeOptions: {
                    target: "{/ " + e.targetName + "}.options.contextAwareness." + e.adaptationName + ".checks." + e.checkName,
                    record: e.record
                }
            }), t.constructSingle([], e.distributionName);
        }, t.contextAware.isBrowser = function() {
            return "undefined" != typeof window && window.document;
        }, t.contextAware.makeChecks({
            "fluid.browser": {
                funcName: "fluid.contextAware.isBrowser"
            }
        }), t.registerNamespace("fluid.contextAware.browser"), t.contextAware.browser.getPlatformName = function() {
            return "undefined" != typeof navigator && navigator.platform ? navigator.platform : void 0;
        }, t.contextAware.browser.getUserAgent = function() {
            return "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent : void 0;
        }, t.contextAware.makeChecks({
            "fluid.browser.platformName": {
                funcName: "fluid.contextAware.browser.getPlatformName"
            },
            "fluid.browser.userAgent": {
                funcName: "fluid.contextAware.browser.getUserAgent"
            }
        });
    }(0, n = n || {}), function() {
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
        if (!e.ArrayMath) {
            var t = {};
            t.add = function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] + n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t + n[r];
            }, t.sub = function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] - n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t - n[r];
            }, t.mul = function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] * n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t * n[r];
            }, t.mulCplx = function(e, t, n, r, a, o) {
                var i, u, s, l, c;
                if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, a.length, o.length) - 1; i >= 0; --i) u = n[i], 
                s = r[i], l = a[i], c = o[i], e[i] = u * l - s * c, t[i] = u * c + s * l; else for (i = Math.min(e.length, t.length, a.length, o.length) - 1; i >= 0; --i) l = a[i], 
                c = o[i], e[i] = n * l - r * c, t[i] = n * c + r * l;
            }, t.div = function(e, t, n) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] / n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t / n[r];
            }, t.divCplx = function(e, t, n, r, a, o) {
                var i, u, s, l, c, d;
                if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, a.length, o.length) - 1; i >= 0; --i) u = n[i], 
                s = r[i], d = 1 / ((l = a[i]) * l + (c = o[i]) * c), e[i] = (u * l + s * c) * d, 
                t[i] = (s * l - u * c) * d; else for (i = Math.min(e.length, t.length, a.length, o.length) - 1; i >= 0; --i) d = 1 / ((l = a[i]) * l + (c = o[i]) * c), 
                e[i] = (n * l + r * c) * d, t[i] = (r * l - n * c) * d;
            }, t.madd = function(e, t, n, r) {
                var a;
                if (t instanceof Float32Array) for (a = Math.min(e.length, t.length, n.length, r.length) - 1; a >= 0; --a) e[a] = t[a] * n[a] + r[a]; else for (a = Math.min(e.length, n.length, r.length) - 1; a >= 0; --a) e[a] = t * n[a] + r[a];
            }, t.abs = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.abs(t[n]);
            }, t.absCplx = function(e, t, n) {
                for (var r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = Math.sqrt(t[r] * t[r] + n[r] * n[r]);
            }, t.acos = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.acos(t[n]);
            }, t.asin = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.asin(t[n]);
            }, t.atan = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.atan(t[n]);
            }, t.atan2 = function(e, t, n) {
                for (var r = Math.min(e.length, n.length, t.length) - 1; r >= 0; --r) e[r] = Math.atan2(t[r], n[r]);
            }, t.ceil = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.ceil(t[n]);
            }, t.cos = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.cos(t[n]);
            }, t.exp = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.exp(t[n]);
            }, t.floor = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.floor(t[n]);
            }, t.log = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.log(t[n]);
            }, t.max = function(e) {
                for (var t = -1 / 0, n = e.length - 1; n >= 0; --n) {
                    var r = e[n];
                    r > t && (t = r);
                }
                return t;
            }, t.min = function(e) {
                for (var t = 1 / 0, n = e.length - 1; n >= 0; --n) {
                    var r = e[n];
                    r < t && (t = r);
                }
                return t;
            }, t.pow = function(e, t, n) {
                var r;
                if (n instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = Math.pow(t[r], n[r]); else for (r = Math.min(e.length, t.length) - 1; r >= 0; --r) e[r] = Math.pow(t[r], n);
            }, t.random = function(e, t, n) {
                t || (t = 0), isNaN(parseFloat(n)) && (n = 1);
                for (var r = n - t, a = e.length - 1; a >= 0; --a) e[a] = Math.random() * r + t;
            }, t.round = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.round(t[n]);
            }, t.sin = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.sin(t[n]);
            }, t.sqrt = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.sqrt(t[n]);
            }, t.tan = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.tan(t[n]);
            }, t.clamp = function(e, t, n, r) {
                for (var a = Math.min(e.length, t.length) - 1; a >= 0; --a) {
                    var o = t[a];
                    e[a] = o < n ? n : o > r ? r : o;
                }
            }, t.fract = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) {
                    var r = t[n];
                    e[n] = r - Math.floor(r);
                }
            }, t.fill = function(e, t) {
                for (var n = e.length - 1; n >= 0; --n) e[n] = t;
            }, t.ramp = function(e, t, n) {
                var r = e.length - 1;
                if (r >= 0 && (e[0] = t), r > 0) for (var a = (n - t) / r, o = 1; o <= r; ++o) e[o] = t + a * o;
            }, t.sign = function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = t[n] < 0 ? -1 : 1;
            }, t.sum = function(e) {
                for (var t = 0, n = e.length - 1; n >= 0; --n) t += e[n];
                return t;
            }, t.sampleLinear = function(e, t, n) {
                for (var r = t.length - 1, a = Math.min(e.length, n.length) - 1; a >= 0; --a) {
                    var o = n[a];
                    o = o < 0 ? 0 : o > r ? r : o;
                    var i = Math.floor(o), u = o - i, s = t[i], l = t[i < r ? i + 1 : r];
                    e[a] = s + u * (l - s);
                }
            }, t.sampleLinearRepeat = function(e, t, n) {
                for (var r = t.length, a = r - 1, o = Math.min(e.length, n.length) - 1; o >= 0; --o) {
                    var i = n[o];
                    i -= Math.floor(i / r) * r;
                    var u = Math.floor(i), s = i - u, l = t[u], c = t[u < a ? u + 1 : 0];
                    e[o] = l + s * (c - l);
                }
            }, t.sampleCubic = function(e, t, n) {
                for (var r = t.length - 1, a = Math.min(e.length, n.length) - 1; a >= 0; --a) {
                    var o = n[a];
                    o = o < 0 ? 0 : o > r ? r : o;
                    var i = Math.floor(o), u = o - i, s = u * u, l = s * u, c = -2 * l + 3 * s, d = 1 - c, f = l - s, p = f - s + u, m = t[i > 0 ? i - 1 : 0], g = t[i], h = t[i < r ? i + 1 : r], v = t[i < r - 1 ? i + 2 : r];
                    e[a] = d * g + c * h + .5 * (p * (h - m) + f * (v - g));
                }
            }, t.sampleCubicRepeat = function(e, t, n) {
                for (var r = t.length, a = r - 1, o = Math.min(e.length, n.length) - 1; o >= 0; --o) {
                    var i = n[o];
                    i -= Math.floor(i / r) * r;
                    var u = Math.floor(i), s = i - u, l = s * s, c = l * s, d = -2 * c + 3 * l, f = 1 - d, p = c - l, m = p - l + s, g = t[u > 0 ? u - 1 : a], h = t[u], v = t[u < a ? u + 1 : 0], y = t[u < a - 1 ? u + 2 : u + 2 - Math.floor((u + 2) / r) * r];
                    e[o] = f * h + d * v + .5 * (m * (v - g) + p * (y - h));
                }
            }, t.pack = function(e, t, n, r, a, o, i) {
                var u = Math.floor(Math.max(0, e.length - t) / n), s = Math.min(u, r.length);
                if (a) {
                    s = Math.min(s, a.length);
                    if (o) {
                        s = Math.min(s, o.length);
                        if (i) for (var s = Math.min(s, i.length), l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = a[l], 
                        e[t + 2] = o[l], e[t + 3] = i[l], t += n; else for (l = 0; l < s; ++l) e[t] = r[l], 
                        e[t + 1] = a[l], e[t + 2] = o[l], t += n;
                    } else for (l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = a[l], t += n;
                } else for (l = 0; l < s; ++l) e[t] = r[l], t += n;
            }, t.unpack = function(e, t, n, r, a, o, i) {
                var u = Math.floor(Math.max(0, e.length - t) / n), s = Math.min(u, r.length);
                if (a) {
                    s = Math.min(s, a.length);
                    if (o) {
                        s = Math.min(s, o.length);
                        if (i) for (var s = Math.min(s, i.length), l = 0; l < s; ++l) r[l] = e[t], a[l] = e[t + 1], 
                        o[l] = e[t + 2], i[l] = e[t + 3], t += n; else for (l = 0; l < s; ++l) r[l] = e[t], 
                        a[l] = e[t + 1], o[l] = e[t + 2], t += n;
                    } else for (l = 0; l < s; ++l) r[l] = e[t], a[l] = e[t + 1], t += n;
                } else for (l = 0; l < s; ++l) r[l] = e[t], t += n;
            }, e.ArrayMath = t;
        }
    }(), function() {
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
        if (!e.Filter) {
            var t = function(e, t) {
                !isNaN(parseFloat(e)) && isFinite(e) || (e = 1), t || (t = 0), this._b = new Float32Array(e), 
                this._b[0] = 1, this._a = new Float32Array(t), this._bHist = new Float32Array(e), 
                this._aHist = new Float32Array(t);
            };
            t.prototype.filter = function(e, t) {
                var n, r = this._a, a = r.length, o = this._b, i = o.length, u = this._aHist, s = this._bHist, l = t.length, c = e.length, d = i - 1, f = a;
                for (n = 0; (d || f) && n < l; ++n) {
                    var p;
                    p = i - d, d && d--;
                    I = o[0] * t[n];
                    for (w = 1; w < p; ++w) I += o[w] * t[n - w];
                    for (;w < i; ++w) I += o[w] * s[w - p];
                    for (p = a - f, f && f--, w = 0; w < p; ++w) I -= r[w] * e[n - 1 - w];
                    for (;w < a; ++w) I -= r[w] * u[w - p];
                    e[n] = I;
                }
                if (3 == i && 2 == a) for (var m, g, h = o[0], v = o[1], y = o[2], b = r[0], k = r[1], S = t[n - 1], x = t[n - 2], C = e[n - 1], A = e[n - 2]; n < l; ++n) m = x, 
                x = S, g = A, C = h * (S = t[n]) + v * x + y * m - b * (A = C) - k * g, e[n] = C; else for (;n < l; ++n) {
                    var w, I = o[0] * t[n];
                    for (w = 1; w < i; ++w) I += o[w] * t[n - w];
                    for (w = 0; w < a; ++w) I -= r[w] * e[n - 1 - w];
                    e[n] = I;
                }
                var N = Math.min(i - 1, l);
                for (n = i - 2; n >= N; --n) s[n] = s[n - N];
                for (n = 0; n < N; ++n) s[n] = t[l - 1 - n];
                for (N = Math.min(a, c), n = a - 1; n >= N; --n) u[n] = u[n - N];
                for (n = 0; n < N; ++n) u[n] = e[l - 1 - n];
            }, t.prototype.clearHistory = function() {
                for (e = this._bHist.length - 1; e >= 0; --e) this._bHist[e] = 0;
                for (var e = this._aHist.length - 1; e >= 0; --e) this._aHist[e] = 0;
            }, t.prototype.setB = function(e) {
                for (var t = Math.min(this._b.length, e.length), n = 0; n < t; ++n) this._b[n] = e[n];
            }, t.prototype.setA = function(e) {
                for (var t = Math.min(this._a.length, e.length), n = 0; n < t; ++n) this._a[n] = e[n];
            }, e.Filter = t;
        }
    }(), function() {
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
        if (!e.FFT) {
            var t = function(e, t, n, r, a, o, i) {
                for (var u, s, l, c, d, f, p, m, g = 0, h = n, v = n + i, y = .7071067811865475, b = h + i; h < b; ) l = e[h] * y, 
                c = t[h] * y, d = e[v] * y, f = t[v] * y, u = d * (p = a[g]) - f * (m = o[g]), s = d * m + f * p, 
                e[v] = l - u, t[v] = c - s, e[h] = l + u, t[h] = c + s, g += r, ++h, ++v;
            }, n = function(e, t, n, r, a, o, i) {
                for (var u, s, l, c, d, f, p, m, g, h, v, y, b, k, S, x, C = 0, A = 0, w = 2 * r, I = n, N = n + i, M = n + 2 * i, P = o[r * i], T = .5773502691896258, O = I + i; I < O; ) g = e[I] * T, 
                h = t[I] * T, v = e[N] * T, y = t[N] * T, b = e[M] * T, k = t[M] * T, S = a[C], 
                c = v * (x = o[C]) + y * S, u = (l = v * S - y * x) - (d = b * (S = a[A]) - k * (x = o[A])), 
                s = c - (f = b * x + k * S), v = g - .5 * (p = l + d), y = h - .5 * (m = c + f), 
                u *= P, s *= P, e[I] = g + p, t[I] = h + m, e[M] = v + s, t[M] = y - u, e[N] = v - s, 
                t[N] = y + u, C += r, A += w, ++I, ++N, ++M;
            }, r = function(e, t, n, r, a, o, i, u) {
                for (var s, l, c, d, f, p, m, g, h, v, y, b, k, S, x, C, A, w, I, N, M, P, T = 0, O = 0, D = 0, V = 2 * r, L = 3 * r, R = n, F = n + i, E = n + 2 * i, G = n + 3 * i, B = R + i; R < B; ) k = .5 * e[R], 
                S = .5 * t[R], x = .5 * e[F], C = .5 * t[F], A = .5 * e[E], w = .5 * t[E], I = .5 * e[G], 
                N = .5 * t[G], s = x * (M = a[T]) - C * (P = o[T]), l = x * P + C * M, y = k - (c = A * (M = a[O]) - w * (P = o[O])), 
                b = S - (d = A * P + w * M), k += c, S += d, m = s + (f = I * (M = a[D]) - N * (P = o[D])), 
                g = l + (p = I * P + N * M), h = s - f, v = l - p, e[E] = k - m, t[E] = S - g, e[R] = k + m, 
                t[R] = S + g, u ? (e[F] = y - v, t[F] = b + h, e[G] = y + v, t[G] = b - h) : (e[F] = y + v, 
                t[F] = b - h, e[G] = y - v, t[G] = b + h), T += r, O += V, D += L, ++R, ++F, ++E, 
                ++G;
            }, a = function(e, t, n, r, a, o, i) {
                for (var u, s, l, c, d, f, p, m, g, h, v, y, b, k, S, x, C, A, w, I, N, M, P, T, O, D, V, L, R, F, E, G, B, q, _, U, j, W, z = 0, H = 0, K = 0, J = 0, $ = 2 * r, Y = 3 * r, Q = 4 * r, X = n, Z = n + i, ee = n + 2 * i, te = n + 3 * i, ne = n + 4 * i, re = a[r * i], ae = o[r * i], oe = a[2 * r * i], ie = o[2 * r * i], ue = .4472135954999579, se = X + i; X < se; ) V = e[X] * ue, 
                L = t[X] * ue, R = e[Z] * ue, F = t[Z] * ue, E = e[ee] * ue, G = t[ee] * ue, B = e[te] * ue, 
                q = t[te] * ue, _ = e[ne] * ue, U = t[ne] * ue, u = V, s = L, l = R * (j = a[z]) - F * (W = o[z]), 
                c = R * W + F * j, d = E * (j = a[H]) - G * (W = o[H]), f = E * W + G * j, p = B * (j = a[K]) - q * (W = o[K]), 
                m = B * W + q * j, S = l + (g = _ * (j = a[J]) - U * (W = o[J])), x = c + (h = _ * W + U * j), 
                N = l - g, M = c - h, C = d + p, A = f + m, w = d - p, I = f - m, e[X] = V + S + C, 
                t[X] = L + x + A, v = u + S * re + C * oe, y = s + x * re + A * oe, b = M * ae + I * ie, 
                k = -N * ae - w * ie, e[Z] = v - b, t[Z] = y - k, e[ne] = v + b, t[ne] = y + k, 
                P = u + S * oe + C * re, T = s + x * oe + A * re, O = -M * ie + I * ae, D = N * ie - w * ae, 
                e[ee] = P + O, t[ee] = T + D, e[te] = P - O, t[te] = T - D, z += r, H += $, K += Y, 
                J += Q, ++X, ++Z, ++ee, ++te, ++ne;
            }, o = function(e, t, n, r, a, o, i, u, s) {
                var l, c, d, f, p, m, g, h, v, y, b = new Float32Array(u), k = new Float32Array(u), S = Math.sqrt(1 / u);
                for (l = 0; l < i; ++l) {
                    for (f = n + l, c = 0; c < u; ++c) b[c] = e[f] * S, k[c] = t[f] * S, f += i;
                    f = n + l;
                    var x = r * l;
                    for (c = 0; c < u; ++c) {
                        p = b[0], m = k[0];
                        var C = 0;
                        for (d = 1; d < u; ++d) (C += x) >= s && (C -= s), g = b[d], h = k[d], p += g * (v = a[C]) - h * (y = o[C]), 
                        m += g * y + h * v;
                        e[f] = p, t[f] = m, f += i, x += r;
                    }
                }
            }, i = function(e, u, s, l, c, d, f, p, m, g, h, v, y, b) {
                var k = m[g++], S = m[g++], x = s, C = s + k * S, A = f * p;
                if (1 == S) do {
                    e[s] = l[d], u[s] = c[d], d += A, ++s;
                } while (s != C); else do {
                    i(e, u, s, l, c, d, f * k, p, m, g, h, v, y, b), d += A, s += S;
                } while (s != C);
                switch (s = x, k) {
                  case 2:
                    t(e, u, s, f, h, v, S);
                    break;

                  case 3:
                    n(e, u, s, f, h, v, S);
                    break;

                  case 4:
                    r(e, u, s, f, h, v, S, b);
                    break;

                  case 5:
                    a(e, u, s, f, h, v, S);
                    break;

                  default:
                    o(e, u, s, f, h, v, S, k, y);
                }
            }, u = function(e, t) {
                var n = 4, r = Math.floor(Math.sqrt(e)), a = 0;
                do {
                    for (;e % n; ) {
                        switch (n) {
                          case 4:
                            n = 2;
                            break;

                          case 2:
                            n = 3;
                            break;

                          default:
                            n += 2;
                        }
                        n > r && (n = e);
                    }
                    e = Math.floor(e / n), t[a++] = n, t[a++] = e;
                } while (e > 1);
            }, s = function(e) {
                e || (e = 256), Object.defineProperty(this, "size", {
                    configurable: !1,
                    writable: !1,
                    value: e
                }), this._twiddlesFwdRe = new Float32Array(e), this._twiddlesFwdIm = new Float32Array(e), 
                this._twiddlesInvRe = this._twiddlesFwdRe, this._twiddlesInvIm = new Float32Array(e);
                for (var t = 0; t < e; ++t) {
                    var n = -2 * Math.PI * t / e, r = Math.cos(n), a = Math.sin(n);
                    this._twiddlesFwdRe[t] = r, this._twiddlesFwdIm[t] = a, this._twiddlesInvIm[t] = -a;
                }
                this._factors = new Int32Array(64), u(e, this._factors);
            };
            s.prototype.forwardCplx = function(e, t, n, r) {
                var a = this._twiddlesFwdRe, o = this._twiddlesFwdIm;
                i(e, t, 0, n, r, 0, 1, 1, this._factors, 0, a, o, this.size, !1);
            }, s.prototype.forward = function(e, t, n) {
                this.forwardCplx(e, t, n, new Float32Array(this.size));
            }, s.prototype.inverseCplx = function(e, t, n, r) {
                var a = this._twiddlesInvRe, o = this._twiddlesInvIm;
                i(e, t, 0, n, r, 0, 1, 1, this._factors, 0, a, o, this.size, !0);
            }, s.prototype.inverse = function(e, t, n) {
                this.inverseCplx(e, new Float32Array(this.size), t, n);
            }, e.FFT = s;
        }
    }();
    var o = function(e) {
        if ("number" != typeof (e = void 0 === e ? new Date().getTime() : e) || Math.ceil(e) != Math.floor(e)) throw new TypeError("seed value must be an integer");
        this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, 
        this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, 
        this.init_by_array([ e ], 1);
    };
    o.prototype.init_genrand = function(e) {
        for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
            var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
            this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, 
            this.mt[this.mti] >>>= 0;
        }
    }, o.prototype.init_by_array = function(e, t) {
        var n, r, a;
        for (this.init_genrand(19650218), n = 1, r = 0, a = this.N > t ? this.N : t; a; a--) {
            o = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
            this.mt[n] = (this.mt[n] ^ (1664525 * ((4294901760 & o) >>> 16) << 16) + 1664525 * (65535 & o)) + e[r] + r, 
            this.mt[n] >>>= 0, r++, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), 
            r >= t && (r = 0);
        }
        for (a = this.N - 1; a; a--) {
            var o = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
            this.mt[n] = (this.mt[n] ^ (1566083941 * ((4294901760 & o) >>> 16) << 16) + 1566083941 * (65535 & o)) - n, 
            this.mt[n] >>>= 0, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1);
        }
        this.mt[0] = 2147483648;
    }, o.prototype.genrand_int32 = function() {
        var e, t = new Array(0, this.MATRIX_A);
        if (this.mti >= this.N) {
            var n;
            for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
            this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[1 & e];
            for (;n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
            this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
            e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], 
            this.mti = 0;
        }
        return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, 
        (e ^= e >>> 18) >>> 0;
    }, o.prototype.genrand_int31 = function() {
        return this.genrand_int32() >>> 1;
    }, o.prototype.genrand_real1 = function() {
        return this.genrand_int32() * (1 / 4294967295);
    }, o.prototype.random = function() {
        return this.pythonCompatibility && (this.skip && this.genrand_int32(), this.skip = !0), 
        this.genrand_int32() * (1 / 4294967296);
    }, o.prototype.genrand_real3 = function() {
        return (this.genrand_int32() + .5) * (1 / 4294967296);
    }, o.prototype.genrand_res53 = function() {
        return (67108864 * (this.genrand_int32() >>> 5) + (this.genrand_int32() >>> 6)) * (1 / 9007199254740992);
    }, o.prototype.LOG4 = Math.log(4), o.prototype.SG_MAGICCONST = 1 + Math.log(4.5), 
    o.prototype.exponential = function(e) {
        if (1 != arguments.length) throw new SyntaxError("exponential() must  be called with 'lambda' parameter");
        var t = this.random();
        return -Math.log(t) / e;
    }, o.prototype.gamma = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("gamma() must be called with alpha and beta parameters");
        if (!(e > 1)) {
            if (1 == e) {
                for (n = this.random(); n <= 1e-7; ) n = this.random();
                return -Math.log(n) * t;
            }
            for (;;) {
                var n = this.random(), r = (Math.E + e) / Math.E, a = r * n;
                if (a <= 1) o = Math.pow(a, 1 / e); else var o = -Math.log((r - a) / e);
                var i = this.random();
                if (a > 1) {
                    if (i <= Math.pow(o, e - 1)) break;
                } else if (i <= Math.exp(-o)) break;
            }
            return o * t;
        }
        for (var u = Math.sqrt(2 * e - 1), s = e - this.LOG4, l = e + u; ;) if (!((i = this.random()) < 1e-7 || n > .9999999)) {
            var c = 1 - this.random(), d = Math.log(i / (1 - i)) / u, f = i * i * c, p = s + l * d - (o = e * Math.exp(d));
            if (p + this.SG_MAGICCONST - 4.5 * f >= 0 || p >= Math.log(f)) return o * t;
        }
    }, o.prototype.normal = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("normal() must be called with mu and sigma parameters");
        var n = this.lastNormal;
        if (this.lastNormal = NaN, !n) {
            var r = 2 * this.random() * Math.PI, a = Math.sqrt(-2 * Math.log(1 - this.random()));
            n = Math.cos(r) * a, this.lastNormal = Math.sin(r) * a;
        }
        return e + n * t;
    }, o.prototype.pareto = function(e) {
        if (1 != arguments.length) throw new SyntaxError("pareto() must be called with alpha parameter");
        var t = this.random();
        return 1 / Math.pow(1 - t, 1 / e);
    }, o.prototype.triangular = function(e, t, n) {
        if (3 != arguments.length) throw new SyntaxError("triangular() must be called with lower, upper and mode parameters");
        var r = (n - e) / (t - e), a = this.random();
        return a <= r ? e + Math.sqrt(a * (t - e) * (n - e)) : t - Math.sqrt((1 - a) * (t - e) * (t - n));
    }, o.prototype.uniform = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("uniform() must be called with lower and upper parameters");
        return e + this.random() * (t - e);
    }, o.prototype.weibull = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("weibull() must be called with alpha and beta parameters");
        var n = 1 - this.random();
        return e * Math.pow(-Math.log(n), 1 / t);
    }, "undefined" == typeof window && "undefined" != typeof module && module.exports && (module.exports = o);
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = r.registerNamespace("jQuery");
        if (i.fluid = r, i.init = function(e) {
            var t = e ? {
                components: {
                    audioSystem: {
                        options: {
                            model: e
                        }
                    }
                }
            } : void 0;
            return i.enviro(t);
        }, i.ALL_CHANNELS = 32, i.OUT_UGEN_ID = "flocking-out", i.PI = Math.PI, i.TWOPI = 2 * Math.PI, 
        i.HALFPI = Math.PI / 2, i.LOG01 = Math.log(.1), i.LOG001 = Math.log(.001), i.ROOT2 = Math.sqrt(2), 
        i.rates = {
            AUDIO: "audio",
            CONTROL: "control",
            SCHEDULED: "scheduled",
            DEMAND: "demand",
            CONSTANT: "constant"
        }, r.registerNamespace("flock.debug"), i.debug.failHard = !0, i.browser = function() {
            if ("undefined" == typeof navigator) return {};
            var e, t, n = navigator.userAgent.toLowerCase(), r = {};
            return e = /(chrome)[ \/]([\w.]+)/.exec(n) || /(webkit)[ \/]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || [], 
            (t = {
                browser: e[1] || "",
                version: e[2] || "0"
            }).browser && (r[t.browser] = !0, r.version = t.version), r.chrome ? r.webkit = !0 : r.webkit && (r.safari = !0), 
            r;
        }, r.registerNamespace("flock.platform"), i.platform.isBrowser = "undefined" != typeof window, 
        i.platform.hasRequire = "undefined" != typeof require, i.platform.os = i.platform.isBrowser ? window.navigator.platform : require("os").platform(), 
        i.platform.isLinux = i.platform.os.indexOf("Linux") > -1, i.platform.isAndroid = i.platform.isLinux && i.platform.os.indexOf("arm") > -1, 
        i.platform.isIOS = "iPhone" === i.platform.os || "iPad" === i.platform.os || "iPod" === i.platform.os, 
        i.platform.isMobile = i.platform.isAndroid || i.platform.isIOS, i.platform.browser = i.browser(), 
        i.platform.isWebAudio = "undefined" != typeof AudioContext || "undefined" != typeof webkitAudioContext, 
        i.platform.audioEngine = i.platform.isBrowser ? "webAudio" : "nodejs", i.platform.browser && void 0 !== i.platform.browser.version) {
            var t = i.platform.browser.version.indexOf(".");
            i.platform.browser.majorVersionNumber = Number(t < 0 ? i.platform.browser.version : i.platform.browser.version.substring(0, t));
        }
        i.shim = {
            URL: i.platform.isBrowser ? window.URL || window.webkitURL || window.msURL : void 0
        }, i.requireModule = function(e, t) {
            if (i.platform.isBrowser) return window[t || e];
            if (i.platform.hasRequire) {
                var n = i.requireModule.paths[e] || e, r = require(n);
                return t ? r[t] : r;
            }
        }, i.requireModule.paths = {
            webarraymath: "../third-party/webarraymath/js/webarraymath.js",
            Random: "../third-party/simjs/js/random-0.26.js"
        }, i.noOp = function() {}, i.isIterable = function(e) {
            var t = typeof e;
            return e && void 0 !== e.length && "string" !== t && "function" !== t;
        }, i.hasValue = function(e, t) {
            var n = !1;
            for (var r in e) if (e[r] === t) {
                n = !0;
                break;
            }
            return n;
        }, i.hasTag = function(e, t) {
            return !(!e || !t) && (e.tags && e.tags.indexOf(t) > -1);
        }, i.randomValue = function(e, t) {
            var n = t - e;
            return Math.random() * n + e;
        }, i.randomAudioValue = function() {
            return 2 * Math.random() - 1;
        }, i.fillBuffer = function(e, t) {
            for (var n = 0; n < e.length; n++) e[n] = t(n, e);
            return e;
        }, i.fillBufferWithValue = function(e, t) {
            for (var n = 0; n < e.length; n++) e[n] = t;
            return e;
        }, i.generateBuffer = function(e, t) {
            var n = new Float32Array(e);
            return i.fillBuffer(n, t);
        }, i.generateBufferWithValue = function(e, t) {
            var n = new Float32Array(e);
            return i.fillBufferWithValue(n, t);
        }, i.generate = function(e, t) {
            var n = "number" == typeof e;
            return ("function" == typeof t ? n ? i.generateBuffer : i.fillBuffer : n ? i.generateBufferWithValue : i.fillBufferWithValue)(e, t);
        }, i.generate.silence = function(e) {
            return new Float32Array(e);
        }, i.clearBuffer = function(e) {
            for (var t = 0; t < e.length; t++) e[t] = 0;
            return e;
        }, i.reverse = function(e) {
            if (!e || !i.isIterable(e) || e.length < 2) return e;
            if ("function" == typeof e.reverse) return e.reverse();
            for (var t, n = 0, r = e.length - 1; n < r; n++, r--) t = e[n], e[n] = e[r], e[r] = t;
            return e;
        }, i.randomIndex = function(e) {
            var t = e.length - 1;
            return Math.round(Math.random() * t);
        }, i.arrayChoose = function(e, t) {
            return t = t || i.randomIndex, (e = r.makeArray(e))[t(e)];
        }, i.choose = function(e, t) {
            var n;
            return i.isIterable(e) ? i.arrayChoose(e, t) : (n = i.arrayChoose(e.keys, t), e[n]);
        }, i.shuffle = function(e) {
            for (var t = e.length - 1; t > 0; t -= 1) {
                var n = Math.floor(Math.random() * (t + 1)), r = e[t];
                e[t] = e[n], e[n] = r;
            }
            return e;
        }, i.normalize = function(e, t, n) {
            n = n || e;
            var r, a, o, i = 0;
            for (t = void 0 === t ? 1 : t, r = 0; r < e.length; r++) (a = Math.abs(e[r])) > i && (i = a);
            if (i > 0) for (r = 0; r < e.length; r++) o = e[r], n[r] = o / i * t;
            return n;
        }, i.generateFourierTable = function(e, t, n, r, a) {
            return r *= i.TWOPI, i.generateBuffer(e, function(e) {
                var o, i, u, s = 0;
                for (o = 0; o < n; o++) i = a ? a[o] : 1, u = (o + 1) * (e * t), s += i * Math.cos(u + r);
                return s;
            });
        }, i.generateNormalizedFourierTable = function(e, t, n, r, a) {
            var o = i.generateBuffer(n, function(e) {
                return a(e + 1);
            }), u = i.generateFourierTable(e, t, n, r, o);
            return i.normalize(u);
        }, i.fillTable = function(e, t) {
            var n = "number" == typeof e ? e : e.length;
            return t(e, i.TWOPI / n);
        }, i.tableGenerators = {
            sin: function(e, t) {
                return i.generateBuffer(e, function(e) {
                    return Math.sin(e * t);
                });
            },
            tri: function(e, t) {
                return i.generateNormalizedFourierTable(e, t, 1e3, 1, function(e) {
                    return e % 2 == 0 ? 0 : 1 / (e * e);
                });
            },
            saw: function(e, t) {
                return i.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                    return 1 / e;
                });
            },
            square: function(e, t) {
                return i.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                    return e % 2 == 0 ? 0 : 1 / e;
                });
            },
            hann: function(e) {
                return i.generateBuffer(e, function(t) {
                    var n = Math.sin(Math.PI * t / e);
                    return n * n;
                });
            },
            sinWindow: function(e) {
                return i.generateBuffer(e, function(t) {
                    return Math.sin(Math.PI * t / e);
                });
            }
        }, i.range = function(e) {
            var t, n, r = {
                max: Number.NEGATIVE_INFINITY,
                min: 1 / 0
            };
            for (t = 0; t < e.length; t++) (n = e[t]) > r.max && (r.max = n), n < r.min && (r.min = n);
            return r;
        }, i.scale = function(e) {
            if (e) {
                var t, n = i.range(e), r = (n.max - n.min) / 2, a = (n.max + n.min) / 2;
                for (t = 0; t < e.length; t++) e[t] = (e[t] - a) / r;
                return e;
            }
        }, i.copyBuffer = function(e, t, n) {
            void 0 === n && (n = e.length);
            var r, a, o = n - t, i = new Float32Array(o);
            for (r = t, a = 0; r < n; r++, a++) i[a] = e[r];
            return i;
        }, i.copyToBuffer = function(e, t) {
            for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) t[r] = e[r];
        }, i.parseMidiString = function(e) {
            if (!e || e.length < 2) return NaN;
            var t = (e = e.toLowerCase()).charAt(1), n = "#" === t || "b" === t ? 2 : 1, r = e.substring(0, n);
            return 12 * Number(e.substring(n)) + i.midiFreq.noteNames[r];
        }, i.midiFreq = function(e, t, n, r) {
            return t = void 0 === t ? 440 : t, n = void 0 === n ? 69 : n, r = r || 12, "string" == typeof e && (e = i.parseMidiString(e)), 
            t * Math.pow(2, 1 * (e - n) / r);
        }, i.midiFreq.noteNames = {
            "b#": 0,
            c: 0,
            "c#": 1,
            db: 1,
            d: 2,
            "d#": 3,
            eb: 3,
            e: 4,
            "e#": 5,
            f: 5,
            "f#": 6,
            gb: 6,
            g: 7,
            "g#": 8,
            ab: 8,
            a: 9,
            "a#": 10,
            bb: 10,
            b: 11,
            cb: 11
        }, i.interpolate = {
            none: function(e, t) {
                return e %= t.length, t[0 | e];
            },
            linear: function(e, t) {
                var n = t.length, r = 0 | (e %= n), a = (r + 1) % n, o = e - r, i = t[r];
                return i + o * (t[a] - i);
            },
            hermite: function(e, t) {
                var n = t.length, r = Math.floor(e), a = r % n, o = e - r, i = (a + 1) % n, u = (a + 2) % n, s = t[a > 0 ? a - 1 : n - 1], l = t[a], c = t[i], d = .5 * (c - s), f = l - c, p = d + f, m = p + f + .5 * (t[u] - l);
                return ((m * o - (p + m)) * o + d) * o + l;
            }
        }, i.interpolate.cubic = i.interpolate.hermite, i.log = {
            fail: function(e) {
                r.log(r.logLevel.FAIL, e);
            },
            warn: function(e) {
                r.log(r.logLevel.WARN, e);
            },
            debug: function(e) {
                r.log(r.logLevel.INFO, e);
            }
        }, i.fail = function(e) {
            if (i.debug.failHard) throw new Error(e);
            i.log.fail(e);
        }, i.pathParseError = function(e, t, n) {
            var r = "Error parsing path '" + t + "'. Segment '" + n + "' could not be resolved.";
            i.fail(r);
        }, i.get = function(e, t) {
            if (!e) return r.getGlobalValue(t);
            if (1 === arguments.length && "string" == typeof e) return r.getGlobalValue(e);
            if (t && "" !== t) {
                var n, a = "" === t ? [] : String(t).split("."), o = e[a[0]];
                for (n = 1; n < a.length; n++) {
                    if (null === o || void 0 === o) return void i.pathParseError(e, t, a[n - 1]);
                    o = o[a[n]];
                }
                return o;
            }
        }, i.set = function(e, t, n) {
            if (e && t && "" !== t) {
                var r, a = String(t).split("."), o = a.length, u = a[0];
                for (r = 1; r < o; r++) {
                    if (e = e[u], "object" !== typeof e) return void i.fail("Error while setting a value at path '" + t + "'. A non-container object was found at segment '" + u + "'. Value: " + e);
                    void 0 === e[u = a[r]] && (e[u] = {});
                }
                return e[u] = n, n;
            }
        }, i.invoke = function(e, t, n) {
            var r = "function" == typeof e ? e : i.get(e, t);
            {
                if ("function" == typeof r) return r.apply(null, n);
                i.fail("Path '" + t + "' does not resolve to a function.");
            }
        }, i.input = {}, i.input.shouldExpand = function(e) {
            return i.parse.specialInputs.indexOf(e) < 0;
        }, i.input.pathExpander = function(e) {
            var t, n = r.model.parseEL(e), a = n.length - 1, o = [];
            for (t = 0; t < a; t++) {
                var i = n[t], u = n[t + 1];
                if (o.push(i), "model" === u || "options" === u) {
                    o = o.concat(n.slice(t + 1, a));
                    break;
                }
                isNaN(Number(u)) && o.push("inputs");
            }
            return o.push(n[a]), o.join(".");
        }, i.input.expandPaths = function(e) {
            var t, n, r, a = {};
            for (t in e) n = i.input.pathExpander(t), r = e[t], a[n] = r;
            return a;
        }, i.input.expandPath = function(e) {
            return "string" == typeof e ? i.input.pathExpander(e) : i.input.expandPaths(e);
        }, i.input.getValueForPath = function(e, t) {
            t = i.input.expandPath(t);
            var n = i.get(e, t);
            return i.hasTag(n, "flock.ugen.valueType") ? n.inputs.value : n;
        }, i.input.getValuesForPathArray = function(e, t) {
            var n, r, a = {};
            for (n = 0; n < t.length; n++) a[r = t[n]] = i.input.get(e, r);
            return a;
        }, i.input.getValuesForPathObject = function(e, t) {
            var n;
            for (n in t) t[n] = i.input.get(e, n);
            return t;
        }, i.input.get = function(e, t) {
            return "string" == typeof t ? i.input.getValueForPath(e, t) : i.isIterable(t) ? i.input.getValuesForPathArray(e, t) : i.input.getValuesForPathObject(e, t);
        }, i.input.resolveValue = function(e, t, n, a, o, u, s) {
            if ("string" == typeof n) {
                var l = r.extractEL(n, i.input.valueExpressionSpec);
                if (l) {
                    var c = i.input.getValueForPath(e, l);
                    return void 0 === c && i.log.debug("The value expression '" + n + "' resolved to undefined. If this isn't expected, check to ensure that your path is valid."), 
                    c;
                }
            }
            return i.input.shouldExpand(o) && s ? s(n, t, a, u) : n;
        }, i.input.valueExpressionSpec = {
            ELstyle: "${}"
        }, i.input.setValueForPath = function(e, t, n, r, a) {
            t = i.input.expandPath(t);
            var o = i.get(e, t), u = t.lastIndexOf("."), s = t.slice(u + 1), l = u > -1 ? i.get(e, t.slice(0, t.lastIndexOf(".inputs"))) : r, c = i.input.resolveValue(e, t, n, l, s, o, a);
            return i.set(e, t, c), l && l.onInputChanged && l.onInputChanged(s), c;
        }, i.input.setValuesForPaths = function(e, t, n, r) {
            var a, o, u, s = {};
            for (a in t) o = t[a], u = i.input.set(e, a, o, n, r), s[a] = u;
            return s;
        }, i.input.set = function(e, t, n, r, a) {
            return "string" == typeof t ? i.input.setValueForPath(e, t, n, r, a) : i.input.setValuesForPaths(e, t, r, a);
        }, r.defaults("flock.audioSystem", {
            gradeNames: [ "fluid.modelComponent" ],
            channelRange: {
                min: 1,
                max: 32
            },
            outputBusRange: {
                min: 2,
                max: 1024
            },
            inputBusRange: {
                min: 1,
                max: 32
            },
            model: {
                rates: {
                    audio: 44100,
                    control: 689.0625,
                    scheduled: 0,
                    demand: 0,
                    constant: 0
                },
                blockSize: 64,
                numBlocks: 16,
                chans: 2,
                numInputBuses: 2,
                numBuses: 8,
                bufferSize: "@expand:flock.audioSystem.defaultBufferSize()"
            },
            modelRelay: [ {
                target: "rates.control",
                singleTransform: {
                    type: "fluid.transforms.binaryOp",
                    left: "{that}.model.rates.audio",
                    operator: "/",
                    right: "{that}.model.blockSize"
                }
            }, {
                target: "numBlocks",
                singleTransform: {
                    type: "fluid.transforms.binaryOp",
                    left: "{that}.model.bufferSize",
                    operator: "/",
                    right: "{that}.model.blockSize"
                }
            }, {
                target: "chans",
                singleTransform: {
                    type: "fluid.transforms.limitRange",
                    input: "{that}.model.chans",
                    min: "{that}.options.channelRange.min",
                    max: "{that}.options.channelRange.max"
                }
            }, {
                target: "numInputBuses",
                singleTransform: {
                    type: "fluid.transforms.limitRange",
                    input: "{that}.model.numInputBuses",
                    min: "{that}.options.inputBusRange.min",
                    max: "{that}.options.inputBusRange.max"
                }
            }, {
                target: "numBuses",
                singleTransform: {
                    type: "fluid.transforms.free",
                    func: "flock.audioSystem.clampNumBuses",
                    args: [ "{that}.model.numBuses", "{that}.options.outputBusRange", "{that}.model.chans" ]
                }
            } ]
        }), i.audioSystem.clampNumBuses = function(e, t, n) {
            return e = Math.max(e, Math.max(n, t.min)), e = Math.min(e, t.max);
        }, i.audioSystem.defaultBufferSize = function() {
            return i.platform.isMobile ? 8192 : i.platform.browser.mozilla ? 2048 : 1024;
        }, r.defaults("flock.busManager", {
            gradeNames: [ "fluid.modelComponent" ],
            model: {
                nextAvailableBus: {
                    input: 0,
                    interconnect: 0
                }
            },
            members: {
                buses: {
                    expander: {
                        funcName: "flock.enviro.createAudioBuffers",
                        args: [ "{audioSystem}.model.numBuses", "{audioSystem}.model.blockSize" ]
                    }
                }
            },
            invokers: {
                acquireNextBus: {
                    funcName: "flock.busManager.acquireNextBus",
                    args: [ "{arguments}.0", "{that}.buses", "{that}.applier", "{that}.model", "{audioSystem}.model.chans", "{audioSystem}.model.numInputBuses" ]
                },
                reset: {
                    changePath: "nextAvailableBus",
                    value: {
                        input: 0,
                        interconnect: 0
                    }
                }
            },
            listeners: {
                "onDestroy.reset": "{that}.reset()"
            }
        }), i.busManager.acquireNextBus = function(e, t, n, r, a, o) {
            var u = r.nextAvailableBus[e];
            if (void 0 !== u) {
                var s = u + a, l = a + o;
                if ("interconnect" === e && (s += o, l = t.length), !(s >= l)) return n.change("nextAvailableBus." + e, ++u), 
                s;
                i.fail("Unable to aquire a bus. There are insufficient buses available. Please use an existing bus or configure additional buses using the enviroment's numBuses and numInputBuses parameters.");
            } else i.fail("An invalid bus type was specified when invoking flock.busManager.acquireNextBus(). Type was: " + e);
        }, r.defaults("flock.outputManager", {
            gradeNames: [ "fluid.modelComponent" ],
            model: {
                audioSettings: "{audioSystem}.model"
            },
            invokers: {
                start: "{that}.events.onStart.fire()",
                stop: "{that}.events.onStop.fire()",
                reset: "{that}.events.onReset.fire"
            },
            events: {
                onStart: "{enviro}.events.onStart",
                onStop: "{enviro}.events.onStop",
                onReset: "{enviro}.events.onReset"
            }
        }), r.defaults("flock.nodeListComponent", {
            gradeNames: "fluid.component",
            members: {
                nodeList: "@expand:flock.nodeList()"
            },
            invokers: {
                insert: "flock.nodeList.insert({that}.nodeList, {arguments}.0, {arguments}.1)",
                head: "flock.nodeList.head({that}.nodeList, {arguments}.0)",
                tail: "flock.nodeList.tail({that}.nodeList, {arguments}.0)",
                before: "flock.nodeList.before({that}.nodeList, {arguments}.0, {arguments}.1)",
                after: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)",
                remove: "flock.nodeList.remove({that}.nodeList, {arguments}.0)",
                replace: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)"
            }
        }), r.defaults("flock.enviro", {
            gradeNames: [ "fluid.modelComponent", "flock.nodeListComponent", "fluid.resolveRootSingle" ],
            singleRootType: "flock.enviro",
            isGlobalSingleton: !0,
            members: {
                buffers: {},
                bufferSources: {}
            },
            components: {
                asyncScheduler: {
                    type: "flock.scheduler.async"
                },
                audioSystem: {
                    type: "flock.audioSystem"
                },
                busManager: {
                    type: "flock.busManager"
                }
            },
            model: {
                isPlaying: !1
            },
            invokers: {
                gen: {
                    funcName: "flock.enviro.gen",
                    args: [ "{busManager}.buses", "{audioSystem}.model", "{that}.nodeList.nodes" ]
                },
                start: "flock.enviro.start({that}.model, {that}.events.onStart.fire)",
                play: "{that}.start",
                stop: "flock.enviro.stop({that}.model, {that}.events.onStop.fire)",
                reset: "{that}.events.onReset.fire()",
                registerBuffer: "flock.enviro.registerBuffer({arguments}.0, {that}.buffers)",
                releaseBuffer: "flock.enviro.releaseBuffer({arguments}.0, {that}.buffers)",
                saveBuffer: {
                    funcName: "flock.enviro.saveBuffer",
                    args: [ "{arguments}.0", "{that}.buffers", "{audioSystem}" ]
                }
            },
            events: {
                onStart: null,
                onPlay: "{that}.events.onStart",
                onStop: null,
                onReset: null
            },
            listeners: {
                onCreate: [ "flock.enviro.registerGlobalSingleton({that})" ],
                onStart: [ "{that}.applier.change(isPlaying, true)" ],
                onStop: [ "{that}.applier.change(isPlaying, false)" ],
                onReset: [ "{that}.stop()", "{asyncScheduler}.clearAll()", "flock.nodeList.clearAll({that}.nodeList)", "{busManager}.reset()", "fluid.clear({that}.buffers)" ]
            }
        }), i.enviro.registerGlobalSingleton = function(e) {
            e.options.isGlobalSingleton && (i.environment = i.enviro.shared = e);
        }, i.enviro.registerBuffer = function(e, t) {
            e.id && (t[e.id] = e);
        }, i.enviro.releaseBuffer = function(e, t) {
            e && delete t["string" == typeof e ? e : e.id];
        }, i.enviro.saveBuffer = function(e, t, n) {
            if ("string" == typeof e && (e = {
                buffer: e
            }), "string" == typeof e.buffer) {
                var r = e.buffer;
                e.buffer = t[r], e.buffer.id = r;
            }
            return e.type = e.type || "wav", e.path = e.path || e.buffer.id + "." + e.type, 
            e.format = e.format || "int16", n.bufferWriter.save(e, e.buffer);
        }, i.enviro.gen = function(e, t, n) {
            i.evaluate.clearBuses(e, t.numBuses, t.blockSize), i.evaluate.synths(n);
        }, i.enviro.start = function(e, t) {
            e.isPlaying || t();
        }, i.enviro.stop = function(e, t) {
            e.isPlaying && t();
        }, i.enviro.createAudioBuffers = function(e, t) {
            var n, r = [];
            for (n = 0; n < e; n++) r[n] = new Float32Array(t);
            return r;
        }, r.defaults("flock.autoEnviro", {
            gradeNames: [ "fluid.component" ],
            members: {
                enviro: "@expand:flock.autoEnviro.initEnvironment()"
            }
        }), i.autoEnviro.initEnvironment = function() {
            return i.environment ? i.environment : i.init();
        }, r.defaults("flock.silentEnviro", {
            gradeNames: "flock.enviro",
            listeners: {
                onCreate: [ "flock.silentEnviro.insertOutputGainNode({that})" ]
            }
        }), i.silentEnviro.insertOutputGainNode = function(e) {
            e.audioSystem.nativeNodeManager && e.audioSystem.nativeNodeManager.createOutputNode({
                node: "Gain",
                params: {
                    gain: 0
                }
            });
        }, r.defaults("flock.node", {
            gradeNames: [ "flock.autoEnviro", "fluid.modelComponent" ],
            addToEnvironment: "tail",
            model: {},
            components: {
                enviro: "{flock.enviro}"
            },
            invokers: {
                play: {
                    funcName: "flock.node.play",
                    args: [ "{that}", "{that}.enviro", "{that}.addToEnvironment" ]
                },
                pause: "{that}.removeFromEnvironment()",
                addToEnvironment: {
                    funcName: "flock.node.addToEnvironment",
                    args: [ "{that}", "{arguments}.0", "{that}.enviro.nodeList" ]
                },
                removeFromEnvironment: {
                    funcName: "flock.node.removeFromEnvironment",
                    args: [ "{that}", "{that}.enviro.nodeList" ]
                },
                isPlaying: {
                    funcName: "flock.nodeList.isNodeActive",
                    args: [ "{that}.enviro.nodeList", "{that}" ]
                }
            },
            listeners: {
                onCreate: [ "{that}.addToEnvironment({that}.options.addToEnvironment)" ],
                onDestroy: [ "{that}.removeFromEnvironment()" ]
            }
        }), i.node.addToEnvironment = function(e, t, n) {
            if (void 0 === t && (t = e.options.addToEnvironment), void 0 !== t && null !== t && !1 !== t) {
                var r = typeof t;
                "string" === r && "head" === t || "tail" === t ? i.nodeList[t](n, e) : "number" === r ? i.nodeList.insert(n, e, t) : i.nodeList.tail(n, e);
            }
        }, i.node.removeFromEnvironment = function(e, t) {
            i.nodeList.remove(t, e);
        }, i.node.play = function(e, t, n) {
            -1 === t.nodeList.nodes.indexOf(e) && n(e.options.addToEnvironment || "tail"), t.model.isPlaying || t.play();
        }, r.defaults("flock.noteTarget", {
            gradeNames: "fluid.component",
            noteChanges: {
                on: {
                    "env.gate": 1
                },
                off: {
                    "env.gate": 0
                }
            },
            invokers: {
                set: {
                    funcName: "fluid.notImplemented"
                },
                noteOn: {
                    func: "{that}.events.noteOn.fire"
                },
                noteOff: {
                    func: "{that}.events.noteOff.fire"
                },
                noteChange: {
                    funcName: "flock.noteTarget.change",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                }
            },
            events: {
                noteOn: null,
                noteOff: null
            },
            listeners: {
                "noteOn.handleChange": [ "{that}.noteChange(on, {arguments}.0)" ],
                "noteOff.handleChange": [ "{that}.noteChange(off, {arguments}.0)" ]
            }
        }), i.noteTarget.change = function(t, n, r) {
            var a = t.options.noteChanges[n], o = e.extend({}, a, r);
            t.set(o);
        }, r.defaults("flock.synth", {
            gradeNames: [ "flock.node", "flock.noteTarget" ],
            rate: i.rates.AUDIO,
            addToEnvironment: !0,
            mergePolicy: {
                ugens: "nomerge"
            },
            ugens: {
                expander: {
                    funcName: "flock.makeUGens",
                    args: [ "{that}.options.synthDef", "{that}.rate", "{that}.nodeList", "{that}.enviro", "{that}.audioSettings" ]
                }
            },
            members: {
                rate: "{that}.options.rate",
                audioSettings: "{that}.enviro.audioSystem.model",
                nodeList: "@expand:flock.nodeList()",
                out: "{that}.options.ugens",
                genFn: "@expand:fluid.getGlobalValue(flock.evaluate.ugens)"
            },
            model: {
                blockSize: "@expand:flock.synth.calcBlockSize({that}.rate, {that}.enviro.audioSystem.model)"
            },
            invokers: {
                set: {
                    funcName: "flock.synth.set",
                    args: [ "{that}", "{that}.nodeList.namedNodes", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
                },
                get: {
                    funcName: "flock.input.get",
                    args: [ "{that}.nodeList.namedNodes", "{arguments}.0" ]
                },
                input: {
                    funcName: "flock.synth.input",
                    args: [ "{arguments}", "{that}.get", "{that}.set" ]
                }
            }
        }), i.synth.createUGenTree = function(e, t, n) {
            return new i.UGenTree(e, t, n);
        }, i.synth.calcBlockSize = function(e, t) {
            return e === i.rates.AUDIO ? t.blockSize : 1;
        }, i.synth.set = function(e, t, n, r, a) {
            return i.input.set(t, n, r, void 0, function(t, n, r, o) {
                return i.synth.ugenValueParser(e, t, o, a);
            });
        }, i.synth.input = function(e, t, n) {
            var r = e[0];
            return r ? "string" == typeof r ? e.length < 2 ? t(r) : n.apply(null, e) : i.isIterable(r) ? t(r) : n.apply(null, e) : void 0;
        }, i.synth.ugenValueParser = function(e, t, n, r) {
            if (null === t || void 0 === t) return n;
            var a, o, u, s = i.parse.ugenDef(t, e.enviro, {
                audioSettings: e.audioSettings,
                buses: e.enviro.busManager.buses,
                buffers: e.enviro.buffers
            }), l = i.isIterable(s) ? s : void 0 !== s ? [ s ] : [], c = i.isIterable(n) ? n : void 0 !== n ? [ n ] : [], d = Math.min(l.length, c.length), f = r ? "swapTree" : "replaceTree";
            for (a = 0; a < d; a++) o = i.ugenNodeList[f](e.nodeList, l[a], c[a]);
            for (u = a; u < l.length; u++) o++, i.ugenNodeList.insertTree(e.nodeList, l[u], o);
            for (u = a; u < c.length; u++) i.ugenNodeList.removeTree(e.nodeList, c[u]);
            return s;
        }, r.defaults("flock.synth.value", {
            gradeNames: [ "flock.synth" ],
            rate: "demand",
            addToEnvironment: !1,
            invokers: {
                value: {
                    funcName: "flock.evaluate.synthValue",
                    args: [ "{that}" ]
                }
            }
        }), r.defaults("flock.synth.frameRate", {
            gradeNames: [ "flock.synth.value" ],
            rate: "scheduled",
            fps: 60,
            members: {
                audioSettings: {
                    rates: {
                        scheduled: "{that}.options.fps"
                    }
                }
            }
        }), i.bufferDesc = function() {
            throw new Error("flock.bufferDesc is not defined. Did you forget to include the buffers.js file?");
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.nodeList = function() {
            return {
                nodes: [],
                namedNodes: {}
            };
        }, i.nodeList.insert = function(e, t, n) {
            return n < 0 && (n = 0), e.nodes.splice(n, 0, t), i.nodeList.registerNode(e, t), 
            n;
        }, i.nodeList.registerNode = function(e, t) {
            var n = t.name || t.id;
            n && (e.namedNodes[n] = t);
        }, i.nodeList.head = function(e, t) {
            return i.nodeList.insert(e, t, 0);
        }, i.nodeList.before = function(e, t, n) {
            var r = e.nodes.indexOf(n);
            return i.nodeList.insert(e, t, r);
        }, i.nodeList.after = function(e, t, n) {
            var r = e.nodes.indexOf(n) + 1;
            return i.nodeList.insert(e, t, r);
        }, i.nodeList.tail = function(e, t) {
            var n = e.nodes.length;
            return i.nodeList.insert(e, t, n);
        }, i.nodeList.unregisterNode = function(e, t) {
            var n = t.name || t.id;
            n && delete e.namedNodes[n];
        }, i.nodeList.isNodeActive = function(e, t) {
            return e.nodes.indexOf(t) > -1;
        }, i.nodeList.remove = function(e, t) {
            if (e) {
                var n = e.nodes.indexOf(t);
                return n > -1 && (e.nodes.splice(n, 1), i.nodeList.unregisterNode(e, t)), n;
            }
        }, i.nodeList.replace = function(e, t, n) {
            var r = e.nodes.indexOf(n);
            return r < 0 ? i.nodeList.tail(e, t) : (e.nodes[r] = t, i.nodeList.unregisterNode(e, n), 
            i.nodeList.registerNode(e, t), r);
        }, i.nodeList.clearAll = function(e) {
            e.nodes.length = 0;
            for (var t in e.namedNodes) delete e.namedNodes[t];
        }, i.ugenNodeList = function() {
            return i.nodeList();
        }, i.ugenNodeList.insertTree = function(e, t, n) {
            var r, a, o = t.inputs;
            for (r in o) a = o[r], i.isUGen(a) && (n = i.ugenNodeList.insertTree(e, a, n), n++);
            return i.nodeList.insert(e, t, n);
        }, i.ugenNodeList.removeTree = function(e, t) {
            var n, r, a = t.inputs;
            for (n in a) r = a[n], i.isUGen(r) && i.ugenNodeList.removeTree(e, r);
            return i.nodeList.remove(e, t);
        }, i.ugenNodeList.tailTree = function(e, t) {
            var n = e.nodes.length;
            return i.ugenNodeList.insertTree(e, t, n);
        }, i.ugenNodeList.replaceTree = function(e, t, n) {
            if (!n) return i.ugenNodeList.tailTree(e, t);
            var r = i.ugenNodeList.removeTree(e, n);
            return i.ugenNodeList.insertTree(e, t, r), r;
        }, i.ugenNodeList.swapTree = function(e, t, n, r) {
            return r ? (i.ugenNodeList.reattachInputs(e, t, n, r), i.ugenNodeList.replaceInputs(e, t, n, r)) : t.inputs = n.inputs, 
            i.nodeList.replace(e, t, n);
        }, i.ugenNodeList.reattachInputs = function(e, t, n, r) {
            for (var a in n.inputs) r.indexOf(a) < 0 ? i.ugenNodeList.removeTree(e, n.inputs[a]) : t.inputs[a] = n.inputs[a];
        }, i.ugenNodeList.replaceInputs = function(e, t, n, r) {
            for (var a in t.inputs) r.indexOf(a) < 0 && i.ugenNodeList.replaceTree(e, t.inputs[a], n.inputs[a]);
        }, i.makeUGens = function(e, t, n, a, o) {
            e || r.log(r.logLevel.IMPORTANT, "Warning: An empy synthDef was found while instantiating a unit generator tree.Did you forget to include a 'synthDef' option for your Synth?");
            var u = t === i.rates.SCHEDULED || t === i.rates.DEMAND;
            return i.parse.synthDef(e, a, {
                rate: t,
                overrideRate: u,
                visitors: [ i.makeUGens.visitor(n) ],
                buffers: a.buffers,
                buses: a.busManager.buses,
                audioSettings: o || a.audioSystem.model
            });
        }, i.makeUGens.visitor = function(e) {
            return function(t) {
                i.nodeList.tail(e, t);
            };
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.evaluate = {
            synth: function(e) {
                e.genFn(e.nodeList.nodes), e.out && (e.model.value = e.out.model.value);
            },
            synthValue: function(e) {
                return i.evaluate.synth(e), e.model.value;
            },
            synths: function(e) {
                for (var t = 0; t < e.length; t++) i.evaluate.synth(e[t]);
            },
            clearBuses: function(e, t, n) {
                for (var r = 0; r < t; r++) for (var a = e[r], o = 0; o < n; o++) a[o] = 0;
            },
            ugens: function(e) {
                for (var t, n = 0; n < e.length; n++) void 0 !== (t = e[n]).gen && t.gen(t.model.blockSize);
            }
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.modelSynth", {
            gradeNames: "flock.synth",
            model: {
                inputs: {}
            },
            modelListeners: {
                inputs: [ {
                    funcName: "flock.modelSynth.updateUGens",
                    args: [ "{that}.set", "{that}.options.ugens", "{change}" ]
                } ]
            },
            invokers: {
                value: "{that}.events.onEvaluate.fire()"
            },
            events: {
                onEvaluate: null
            },
            listeners: {
                onEvaluate: [ "{that}.genFn({that}.nodeList.nodes)", {
                    changePath: "value",
                    value: "{that}.out.model.value"
                } ]
            }
        }), i.modelSynth.updateUGens = function(e, t, n) {
            var r = {};
            i.modelSynth.flattenModel("", n.value, r), e(r);
        }, i.modelSynth.shouldFlattenValue = function(e) {
            return r.isPrimitive(e) || i.isIterable(e) || e.ugen;
        }, i.modelSynth.flattenModel = function(e, t, n) {
            for (var a in t) {
                var o = t[a], u = r.pathUtil.composePath(e, a.toString());
                i.modelSynth.shouldFlattenValue(o) ? n[u] = o : i.modelSynth.flattenModel(u, o, n);
            }
            return n;
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.synth.group", {
            gradeNames: [ "flock.node", "flock.noteTarget" ],
            methodEventMap: {
                onSet: "set"
            },
            members: {
                nodeList: "@expand:flock.nodeList()",
                genFn: "@expand:fluid.getGlobalValue(flock.evaluate.synths)"
            },
            invokers: {
                play: "{that}.events.onPlay.fire",
                pause: "{that}.events.onPause.fire",
                set: "{that}.events.onSet.fire",
                get: "flock.synth.group.get({arguments}, {that}.nodeList.nodes)",
                head: "flock.synth.group.head({arguments}.0, {that})",
                tail: "flock.synth.group.tail({arguments}.0, {that})",
                insert: "flock.synth.group.insert({arguments}.0, {arguments}.1, {that})",
                before: "flock.synth.group.before({arguments}.0, {arguments}.1, {that})",
                after: "flock.synth.group.after({arguments}.0, {arguments}.1, {that})",
                remove: "{that}.events.onRemove.fire",
                input: {
                    funcName: "flock.synth.group.input",
                    args: [ "{arguments}", "{that}.get", "{that}.events.onSet.fire" ]
                }
            },
            events: {
                onSet: null,
                onGen: null,
                onPlay: null,
                onPause: null,
                onInsert: null,
                onRemove: null
            },
            listeners: {
                onInsert: [ {
                    funcName: "flock.synth.group.bindMethods",
                    args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "addListener" ]
                }, "flock.synth.group.removeNodeFromEnvironment({arguments}.0)" ],
                onRemove: [ {
                    funcName: "flock.synth.group.bindMethods",
                    args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "removeListener" ]
                }, {
                    this: "{that}.nodeList",
                    method: "remove",
                    args: [ "{arguments}.0" ]
                } ]
            }
        }), i.synth.group.head = function(e, t) {
            i.nodeList.head(t.nodeList, e), t.events.onInsert.fire(e);
        }, i.synth.group.tail = function(e, t) {
            i.nodeList.tail(t.nodeList, e), t.events.onInsert.fire(e);
        }, i.synth.group.insert = function(e, t, n) {
            i.nodeList.insert(n.nodeList, e, t), n.events.onInsert.fire(e);
        }, i.synth.group.before = function(e, t, n) {
            i.nodeList.before(n.nodeList, e, t), n.events.onInsert.fire(e);
        }, i.synth.group.after = function(e, t, n) {
            i.nodeList.after(n.nodeList, e, t), n.events.onInsert.fire(e);
        }, i.synth.group.removeNodeFromEnvironment = function(e) {
            e.removeFromEnvironment();
        }, i.synth.group.get = function(e, t) {
            var n = t[t.length - 1];
            return n.get.apply(n, e);
        }, i.synth.group.input = function(e, t, n) {
            return (e.length > 1 ? n : t).apply(null, e);
        }, i.synth.group.bindMethods = function(e, t, n, r) {
            for (var a in t) {
                var o = e[t[a]];
                (0, n[a][r])(o);
            }
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = r.registerNamespace("jQuery");
        r.defaults("flock.synth.polyphonic", {
            gradeNames: [ "flock.synth.group" ],
            maxVoices: 16,
            amplitudeNormalizer: "static",
            amplitudeKey: "env.sustain",
            noteSpecs: "{that}.options.noteChanges",
            distributeOptions: {
                source: "{that}.options.voiceAllocatorOptions",
                target: "{that flock.synth.voiceAllocator}.options",
                removeSource: !0
            },
            voiceAllocatorOptions: {
                synthDef: "{polyphonic}.options.synthDef",
                maxVoices: "{polyphonic}.options.maxVoices",
                amplitudeNormalizer: "{polyphonic}.options.amplitudeNormalizer",
                amplitudeKey: "{polyphonic}.options.amplitudeKey",
                listeners: {
                    onCreateVoice: {
                        funcName: "flock.nodeList.tail",
                        args: [ "{polyphonic}.nodeList", "{arguments}.0" ]
                    }
                }
            },
            components: {
                voiceAllocator: {
                    type: "flock.synth.voiceAllocator.lazy"
                }
            },
            invokers: {
                noteChange: {
                    funcName: "flock.synth.polyphonic.noteChange",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
                },
                createVoice: {
                    func: "{voiceAllocator}.createVoice",
                    args: [ "{that}.options", "{that}.insert" ]
                }
            },
            listeners: {
                "noteOn.handleChange": [ {
                    funcName: "flock.synth.polyphonic.noteOn",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                } ],
                "noteOff.handleChange": [ {
                    funcName: "flock.synth.polyphonic.noteOff",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                } ]
            }
        }), i.synth.polyphonic.noteChange = function(t, n, r, a) {
            var o = t.options.noteChanges[n], i = e.extend({}, o, a);
            r.set(i);
        }, i.synth.polyphonic.noteOn = function(e, t, n) {
            var r = e.voiceAllocator.getFreeVoice();
            return e.voiceAllocator.activeVoices[t] && e.noteOff(t), e.voiceAllocator.activeVoices[t] = r, 
            e.noteChange("on", r, n), r;
        }, i.synth.polyphonic.noteOff = function(e, t, n) {
            var r = e.voiceAllocator.activeVoices[t];
            return r ? (e.noteChange("off", r, n), delete e.voiceAllocator.activeVoices[t], 
            e.voiceAllocator.freeVoices.push(r), r) : null;
        }, r.defaults("flock.synth.voiceAllocator", {
            gradeNames: [ "fluid.component" ],
            maxVoices: 16,
            amplitudeNormalizer: "static",
            amplitudeKey: "env.sustain",
            members: {
                activeVoices: {},
                freeVoices: []
            },
            invokers: {
                createVoice: {
                    funcName: "flock.synth.voiceAllocator.createVoice",
                    args: [ "{that}.options", "{that}.events.onCreateVoice.fire" ]
                }
            },
            events: {
                onCreateVoice: null
            }
        }), i.synth.voiceAllocator.createVoice = function(e, t) {
            var n, r = i.synth({
                synthDef: e.synthDef,
                addToEnvironment: !1
            }), a = e.amplitudeNormalizer, o = e.amplitudeKey;
            return a && ("function" == typeof a ? a(r, o) : "static" === a && (n = 1 / e.maxVoices, 
            r.input(o, n))), t(r), r;
        }, r.defaults("flock.synth.voiceAllocator.lazy", {
            gradeNames: [ "flock.synth.voiceAllocator" ],
            invokers: {
                getFreeVoice: {
                    funcName: "flock.synth.voiceAllocator.lazy.get",
                    args: [ "{that}.freeVoices", "{that}.activeVoices", "{that}.createVoice", "{that}.options.maxVoices" ]
                }
            }
        }), i.synth.voiceAllocator.lazy.get = function(e, t, n, r) {
            return e.length > 1 ? e.pop() : Object.keys(t).length > r ? null : n();
        }, r.defaults("flock.synth.voiceAllocator.pool", {
            gradeNames: [ "flock.synth.voiceAllocator" ],
            invokers: {
                getFreeVoice: "flock.synth.voiceAllocator.pool.get({that}.freeVoices)"
            }
        }), i.synth.voiceAllocator.pool.get = function(e) {
            if (e.length > 0) return e.pop();
        }, i.synth.voiceAllocator.pool.allocateVoices = function(e, t, n) {
            for (var r = 0; r < n; r++) e[r] = t();
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.band", {
            gradeNames: [ "fluid.component" ],
            synthGrade: "flock.noteTarget",
            invokers: {
                play: {
                    func: "{that}.events.onPlay.fire"
                },
                pause: {
                    func: "{that}.events.onPause.fire"
                },
                set: {
                    func: "{that}.events.onSet.fire"
                },
                getSynths: {
                    funcName: "fluid.queryIoCSelector",
                    args: [ "{that}", "{that}.options.synthGrade" ]
                }
            },
            events: {
                onPlay: null,
                onPause: null,
                onSet: null
            },
            distributeOptions: [ {
                source: "{that}.options.synthListeners",
                removeSource: !0,
                target: "{that flock.synth}.options.listeners"
            } ],
            synthListeners: {
                "{band}.events.onPlay": {
                    func: "{that}.play"
                },
                "{band}.events.onPause": {
                    func: "{that}.pause"
                },
                "{band}.events.onSet": {
                    func: "{that}.set"
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        function e() {
            function e(e, n) {
                r.value = n, r.then = "reject" === e ? function(e, t) {
                    return t(n), this;
                } : function(e) {
                    return e(n), this;
                }, r.resolve = r.reject = function() {
                    throw new Error("Promise already completed");
                }, t(e, n);
            }
            function t(e, t) {
                var r, a;
                for (r = 0; r < n.length; r++) (a = n[r])[e] && a[e](t);
                n = null;
            }
            var n = [], r = {
                state: "pending",
                value: void 0,
                resolve: function(t) {
                    e("resolve", t), r.state = "fulfilled";
                },
                reject: function(t) {
                    e("reject", t), r.state = "rejected";
                },
                then: function(e, t) {
                    return n ? n.push({
                        resolve: e,
                        reject: t
                    }) : ("fulfilled" === r.state ? e : t)(r.value), this;
                },
                safe: {
                    then: function(e, t) {
                        return r.then(e, t), this;
                    }
                }
            };
            return r;
        }
        r.defaults("flock.promise", {
            gradeNames: [ "fluid.component" ],
            members: {
                promise: {
                    expander: {
                        funcName: "flock.promise.make"
                    }
                }
            }
        }), i.promise.make = function() {
            return new e();
        }, i.bufferDesc = function(e, t, n) {
            return (i.platform.isWebAudio && e instanceof AudioBuffer ? i.bufferDesc.fromAudioBuffer : i.isIterable(e) ? i.bufferDesc.fromChannelArray : i.bufferDesc.expand)(e, t, n);
        }, i.bufferDesc.inferFormat = function(e, t, n) {
            var r = e.format, a = e.data;
            return r.sampleRate = t || r.sampleRate || 44100, r.numChannels = n || r.numChannels || e.data.channels.length, 
            r.numSampleFrames = r.numSampleFrames || a.channels.length > 0 ? a.channels[0].length : 0, 
            r.duration = r.numSampleFrames / r.sampleRate, e;
        }, i.bufferDesc.fromChannelArray = function(e, t, n) {
            e instanceof Float32Array && (e = [ e ]);
            var r = {
                container: {},
                format: {
                    numChannels: n,
                    sampleRate: t,
                    numSampleFrames: e[0].length
                },
                data: {
                    channels: e
                }
            };
            return i.bufferDesc.inferFormat(r, t, n);
        }, i.bufferDesc.expand = function(e, t, n) {
            if (e = e || {
                data: {
                    channels: []
                }
            }, e.container = e.container || {}, e.format = e.format || {}, e.format.numChannels = n || e.format.numChannels || e.data.channels.length, 
            e.data && e.data.channels && (1 === e.format.numChannels && 1 !== e.data.channels.length && (e.data.channels = [ e.data.channels ]), 
            e.format.numChannels !== e.data.channels.length)) throw new Error("The specified number of channels does not match the actual channel data. numChannels was: " + e.format.numChannels + " but the sample data contains " + e.data.channels.length + " channels.");
            return i.bufferDesc.inferFormat(e, t, n);
        }, i.bufferDesc.fromAudioBuffer = function(e) {
            var t, n = {
                container: {},
                format: {
                    sampleRate: e.sampleRate,
                    numChannels: e.numberOfChannels,
                    numSampleFrames: e.length,
                    duration: e.duration
                },
                data: {
                    channels: []
                }
            };
            for (t = 0; t < e.numberOfChannels; t++) n.data.channels.push(e.getChannelData(t));
            return n;
        }, i.bufferDesc.toAudioBuffer = function(e, t) {
            for (var n = e.createBuffer(t.format.numChannels, t.format.numSampleFrames, t.format.sampleRate), r = 0; r < t.format.numChannels; r++) n.copyToChannel(t.data.channels[r], r);
            return n;
        }, r.defaults("flock.bufferSource", {
            gradeNames: [ "fluid.modelComponent" ],
            sampleRate: "{enviro}.audioSystem.model.sampleRate",
            model: {
                state: "start",
                src: null
            },
            components: {
                bufferPromise: {
                    createOnEvent: "onRefreshPromise",
                    type: "flock.promise",
                    options: {
                        listeners: {
                            onCreate: {
                                this: "{that}.promise",
                                method: "then",
                                args: [ "{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire" ]
                            }
                        }
                    }
                }
            },
            invokers: {
                get: {
                    funcName: "flock.bufferSource.get",
                    args: [ "{that}", "{arguments}.0" ]
                },
                set: {
                    funcName: "flock.bufferSource.set",
                    args: [ "{that}", "{arguments}.0" ]
                },
                error: {
                    funcName: "flock.bufferSource.error",
                    args: [ "{that}", "{arguments}.0" ]
                }
            },
            listeners: {
                onCreate: {
                    funcName: "{that}.events.onRefreshPromise.fire"
                },
                onRefreshPromise: {
                    changePath: "state",
                    value: "start"
                },
                onFetch: {
                    changePath: "state",
                    value: "in-progress"
                },
                afterFetch: [ {
                    changePath: "state",
                    value: "fetched"
                }, {
                    funcName: "{that}.events.onBufferUpdated.fire",
                    args: [ "{arguments}.0" ]
                } ],
                onBufferUpdated: "{enviro}.registerBuffer({arguments}.0)",
                onError: {
                    changePath: "state",
                    value: "error"
                }
            },
            events: {
                onRefreshPromise: null,
                onError: null,
                onFetch: null,
                afterFetch: null,
                onBufferUpdated: null
            }
        }), i.bufferSource.get = function(e, t) {
            return "in-progress" === e.model.state || t.src === e.model.src && !t.replace ? e.bufferPromise.promise : (t.src && ("fetched" !== e.model.state && "errored" !== e.model.state || e.model.src === t.src && !t.replace || e.events.onRefreshPromise.fire(), 
            "start" === e.model.state && (e.model.src = t.src, e.events.onFetch.fire(t), i.audio.decode({
                src: t.src,
                sampleRate: e.options.sampleRate,
                success: function(n) {
                    t.id && (n.id = t.id), e.set(n);
                },
                error: e.error
            }))), e.bufferPromise.promise);
        }, i.bufferSource.set = function(e, t) {
            var n = e.model.state;
            return "start" !== n && "in-progress" !== n || e.bufferPromise.promise.resolve(t), 
            e.bufferPromise.promise;
        }, i.bufferSource.error = function(e, t) {
            return e.bufferPromise.promise.reject(t), e.bufferPromise.promise;
        }, r.defaults("flock.bufferLoader", {
            gradeNames: [ "fluid.component" ],
            bufferDefs: [],
            members: {
                buffers: [],
                bufferDefs: "@expand:flock.bufferLoader.expandBufferDefs({that}.options.bufferDefs)"
            },
            components: {
                enviro: "{flock.enviro}"
            },
            events: {
                afterBuffersLoaded: null,
                onError: null
            },
            listeners: {
                "onCreate.loadBuffers": {
                    funcName: "flock.bufferLoader.loadBuffers",
                    args: [ "{that}" ]
                },
                "onError.logError": {
                    funcName: "flock.log.fail"
                }
            }
        }), i.bufferLoader.idFromURL = function(e) {
            var t = e.lastIndexOf("/"), n = t > -1 ? t + 1 : 0, r = e.lastIndexOf("."), a = r > -1 ? r : e.length;
            return e.substring(n, a);
        }, i.bufferLoader.idsFromURLs = function(e) {
            return r.transform(e, i.bufferLoader.idFromURL);
        }, i.bufferLoader.expandFileSequence = function(e) {
            e = e || [];
            var t, n, r, a = [];
            for (t = 0; t < e.length; t++) n = e[t], r = i.bufferLoader.idFromURL(n), a.push({
                id: r,
                url: n
            });
            return a;
        }, i.bufferLoader.expandBufferDef = function(e) {
            return "string" == typeof e && (e = {
                url: e
            }), void 0 === e.id && void 0 !== e.url && (e.id = i.bufferLoader.idFromURL(e.url)), 
            e;
        }, i.bufferLoader.expandBufferDefs = function(e) {
            return e ? (e = r.makeArray(e), r.transform(e, i.bufferLoader.expandBufferDef)) : [];
        }, i.bufferLoader.loadBuffer = function(e, t, n) {
            try {
                i.parse.bufferForDef(e, t, n.enviro);
            } catch (e) {
                n.events.onError.fire(e.message);
            }
        }, i.bufferLoader.loadBuffers = function(e) {
            var t = 1, n = {
                setBuffer: function(r) {
                    if (e.buffers.push(r), e.buffers.length === e.options.bufferDefs.length) e.events.afterBuffersLoaded.fire(e.buffers); else if (t < e.bufferDefs.length) {
                        var a = e.bufferDefs[t];
                        i.bufferLoader.loadBuffer(a, n, e), t++;
                    }
                }
            };
            i.bufferLoader.loadBuffer(e.bufferDefs[0], n, e);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = r.registerNamespace("jQuery");
        r.registerNamespace("flock.parse"), i.parse.synthDef = function(e, t, n) {
            return e || (e = []), i.parse.synthDef.hasOutUGen(e) || (e = i.parse.synthDef.makeOutUGenDef(e, n)), 
            i.parse.ugenForDef(e, t, n);
        }, i.parse.synthDef.hasOutUGen = function(e) {
            return !i.isIterable(e) && (e.id === i.OUT_UGEN_ID || "flock.ugen.out" === e.ugen || "flock.ugen.valueOut" === e.ugen);
        }, i.parse.synthDef.makeOutUGenDef = function(e, t) {
            return e = {
                id: i.OUT_UGEN_ID,
                ugen: "flock.ugen.valueOut",
                inputs: {
                    sources: e
                }
            }, t.rate === i.rates.AUDIO && (e.ugen = "flock.ugen.out", e.inputs.bus = 0, e.inputs.expand = t.audioSettings.chans), 
            e;
        }, i.parse.makeUGen = function(t, n, a, o) {
            var u = o.audioSettings.rates, s = o.audioSettings.blockSize;
            if (t.rate || (t.rate = i.rates.AUDIO), !i.hasValue(i.rates, t.rate) && (i.fail("An invalid rate was specified for a unit generator. ugenDef was: " + r.prettyPrintJSON(t)), 
            !i.debug.failHard)) {
                var l = t.rate;
                t.rate = i.rates.AUDIO, i.log.warn("Overriding invalid unit generator rate. Rate is now '" + t.rate + "'; was: " + r.prettyPrintJSON(l));
            }
            var c;
            c = t.options && void 0 !== t.options.sampleRate ? t.options.sampleRate : u[t.rate], 
            t.options = e.extend(!0, {}, t.options, {
                sampleRate: c,
                rate: t.rate,
                audioSettings: {
                    rates: u,
                    blockSize: s
                }
            });
            var d, f = t.rate === i.rates.AUDIO ? s : 1;
            if (i.hasTag(t.options, "flock.ugen.multiChannelOutput")) {
                var p = t.options.numOutputs || 1;
                d = [];
                for (var m = 0; m < p; m++) d.push(new Float32Array(f));
            } else d = new Float32Array(f);
            var g = r.copy(t.options);
            return g.buffers = o.buffers, g.buses = o.buses, g.enviro = a, i.invoke(void 0, t.ugen, [ n, d, g ]);
        }, i.parse.reservedWords = [ "id", "ugen", "rate", "inputs", "options" ], i.parse.specialInputs = [ "value", "buffer", "list", "table", "envelope", "durations", "values" ], 
        i.parse.expandInputs = function(e) {
            if (e.inputs) return e;
            var t, n = {};
            for (t in e) -1 === i.parse.reservedWords.indexOf(t) && (n[t] = e[t], delete e[t]);
            return e.inputs = n, e;
        }, i.parse.ugenDefForConstantValue = function(e) {
            return {
                ugen: "flock.ugen.value",
                rate: i.rates.CONSTANT,
                inputs: {
                    value: e
                }
            };
        }, i.parse.expandValueDef = function(e) {
            var t = typeof e;
            if ("number" === t) return i.parse.ugenDefForConstantValue(e);
            if ("object" === t) return e;
            throw new Error("Invalid value type found in ugen definition. UGenDef was: " + r.prettyPrintJSON(e));
        }, i.parse.rateMap = {
            ar: i.rates.AUDIO,
            kr: i.rates.CONTROL,
            sr: i.rates.SCHEDULED,
            dr: i.rates.DEMAND,
            cr: i.rates.CONSTANT
        }, i.parse.expandRate = function(e, t) {
            return e.rate = i.parse.rateMap[e.rate] || e.rate, t.overrideRate && e.rate !== i.rates.CONSTANT && (e.rate = t.rate), 
            e;
        }, i.parse.ugenDef = function(e, t, n) {
            return (i.isIterable(e) ? i.parse.ugensForDefs : i.parse.ugenForDef)(e, t, n);
        }, i.parse.ugenDef.mergeOptions = function(t) {
            var n = i.ugenDefaults(t.ugen) || {};
            return n = r.copy(n), n.options = n.ugenOptions, delete n.ugenOptions, e.extend(!0, {}, n, t);
        }, i.parse.ugensForDefs = function(e, t, n) {
            var r, a = [];
            for (r = 0; r < e.length; r++) a[r] = i.parse.ugenForDef(e[r], t, n);
            return a;
        }, i.parse.ugenForDef = function(t, n, a) {
            n = n || i.environment;
            var o = a = e.extend(!0, {
                audioSettings: n.audioSystem.model,
                buses: n.busManager.buses,
                buffers: n.buffers
            }, a), u = o.visitors, s = o.audioSettings.rates;
            if (t = i.parse.expandValueDef(t), i.isIterable(t)) return i.parse.ugensForDefs(t, n, a);
            t = i.parse.expandInputs(t), i.parse.expandRate(t, a);
            var l, c = (t = i.parse.ugenDef.mergeOptions(t, a)).inputs, d = {};
            for (l in c) {
                var f = c[l];
                null !== f && (d[l] = i.input.shouldExpand(l, t) ? i.parse.ugenForDef(f, n, a) : f);
            }
            if (!t.ugen) throw new Error("Unit generator definition lacks a 'ugen' property; can't initialize the synth graph. Value: " + r.prettyPrintJSON(t));
            var p = i.parse.makeUGen(t, d, n, a);
            if (t.id && (p.id = t.id), p.options.ugenDef = t, u) for (var m = 0; m < u.length; m++) u[m](p, t, s);
            return p;
        }, i.parse.expandBufferDef = function(e) {
            return "string" == typeof e ? {
                id: e
            } : i.isIterable(e) || e.data || e.format ? i.bufferDesc(e) : e;
        }, i.parse.bufferForDef = function(e, t, n) {
            (e = i.parse.expandBufferDef(e)).data && e.data.channels ? (e = i.bufferDesc(e), 
            i.parse.bufferForDef.resolveBuffer(e, t, n)) : i.parse.bufferForDef.resolveDef(e, t, n);
        }, i.parse.bufferForDef.createBufferSource = function(e) {
            return i.bufferSource({
                sampleRate: e.audioSystem.model.sampleRate
            });
        }, i.parse.bufferForDef.findSource = function(e, t) {
            var n;
            return t && e.id ? (n = t.bufferSources[e.id]) || (n = i.parse.bufferForDef.createBufferSource(t), 
            t.bufferSources[e.id] = n) : n = i.parse.bufferForDef.createBufferSource(t), n;
        }, i.parse.bufferForDef.bindToPromise = function(e, t, n) {
            var r = function(e) {
                t.events.onBufferUpdated.addListener(r), n && n.setBuffer(e);
            };
            e.then(r, function(e) {
                throw !e && t.model.src && t.model.src.indexOf(".aif") && (e = "if this is an AIFF file, you might need to include flocking-audiofile-compatibility.js in some browsers."), 
                new Error("Error while resolving buffer " + t.model.src + ": " + e);
            });
        }, i.parse.bufferForDef.resolveDef = function(e, t, n) {
            var r, a = i.parse.bufferForDef.findSource(e, n);
            e.src = e.url || e.src, e.selector && "undefined" != typeof document && (e.src = document.querySelector(e.selector).files[0]), 
            r = a.get(e), i.parse.bufferForDef.bindToPromise(r, a, t);
        }, i.parse.bufferForDef.resolveBuffer = function(e, t, n) {
            var r = i.parse.bufferForDef.findSource(e, n), a = r.set(e);
            i.parse.bufferForDef.bindToPromise(a, r, t);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = "undefined" != typeof window ? window.atob : require("atob");
        i.applyDeferred = function(e, t, n) {
            e && (n = void 0 === n ? 0 : n, setTimeout(function() {
                e.apply(null, t);
            }, n));
        }, r.registerNamespace("flock.net"), i.net.readBufferFromUrl = function(e) {
            var t = e.src, n = new XMLHttpRequest();
            n.onreadystatechange = function() {
                if (4 === n.readyState) if (i.net.isXHRSuccessful(n)) e.success(n.response, i.file.parseFileExtension(t)); else {
                    if (!e.error) throw new Error(n.statusText);
                    e.error(n.statusText);
                }
            }, n.open(e.method || "GET", t, !0), n.responseType = e.responseType || "arraybuffer", 
            n.send(e.data);
        }, i.net.isXHRSuccessful = function(e) {
            return 200 === e.status || 0 === e.responseURL.indexOf("file://") && 0 === e.status && e.response;
        }, r.registerNamespace("flock.file"), i.file.mimeTypes = {
            "audio/wav": "wav",
            "audio/x-wav": "wav",
            "audio/wave": "wav",
            "audio/x-aiff": "aiff",
            "audio/aiff": "aiff",
            "sound/aiff": "aiff"
        }, i.file.typeAliases = {
            aif: "aiff",
            wave: "wav"
        }, i.file.parseFileExtension = function(e) {
            var t, n = e.lastIndexOf(".");
            if (!(n < 0)) return t = e.substring(n + 1), t = t.toLowerCase(), i.file.typeAliases[t] || t;
        }, i.file.parseMIMEType = function(e) {
            return i.file.mimeTypes[e];
        }, i.file.stringToBuffer = function(e) {
            var t, n = e.length, r = new ArrayBuffer(n), a = new Uint8Array(r);
            for (t = 0; t < n; t++) a[t] = e.charCodeAt(t);
            return a.buffer;
        }, i.file.readBufferFromDataUrl = function(t) {
            var n = t.src, r = n.indexOf(","), a = n.substring(0, r), o = n.substring(r + 1), u = a.indexOf(";base64"), s = u > -1, l = n.indexOf("data:") + 5, c = s ? u : r, d = n.substring(l, c);
            s && (o = e(o)), i.applyDeferred(function() {
                var e = i.file.stringToBuffer(o);
                t.success(e, i.file.parseMIMEType(d));
            });
        }, i.file.readBufferFromFile = function(e) {
            var t = new FileReader();
            return t.onload = function(t) {
                e.success(t.target.result, i.file.parseFileExtension(e.src.name));
            }, t.readAsArrayBuffer(e.src), t;
        }, r.registerNamespace("flock.audio"), i.audio.loadBuffer = function(e) {
            var t = e.src || e.url;
            t && (t instanceof ArrayBuffer && i.applyDeferred(e.success, [ t, e.type ]), i.audio.loadBuffer.readerForSource(t)(e));
        }, i.audio.loadBuffer.readerForSource = function(e) {
            return "undefined" != typeof File && e instanceof File ? i.file.readBufferFromFile : 0 === e.indexOf("data:") ? i.file.readBufferFromDataUrl : i.net.readBufferFromUrl;
        }, i.audio.decode = function(e) {
            var t = e.success;
            e.success = function(n, a) {
                var o = i.audio.decoderStrategies, u = o[a] || o.default;
                e.decoder && (u = "string" == typeof e.decoder ? r.getGlobalValue(e.decoder) : e.decoder), 
                u({
                    rawData: n,
                    type: a,
                    success: t,
                    error: e.error,
                    sampleRate: e.sampleRate
                });
            }, i.audio.loadBuffer(e);
        }, i.audio.decode.webAudio = function(e) {
            i.webAudio.audioSystem.audioContextSingleton.decodeAudioData(e.rawData, function(t) {
                var n = i.bufferDesc.fromAudioBuffer(t);
                e.success(n);
            }, e.error);
        }, i.audio.decoderStrategies = {
            default: i.audio.decode.webAudio
        }, i.audio.registerDecoderStrategy = function(e, t) {
            if (e) if ("object" != typeof e) "string" == typeof t && (t = r.getGlobalValue(t)), 
            i.audio.decoderStrategies[e] = t; else for (var n in e) i.audio.decoderStrategies[n] = e[n];
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
        r.registerNamespace("flock.audio.convert"), i.audio.convert.maxFloatValue = function(e) {
            return 1 - 1 / e.scale;
        }, i.audio.convert.pcm = {
            int8: {
                scale: 128,
                setter: "setInt8",
                width: 1
            },
            int16: {
                scale: 32768,
                setter: "setInt16",
                width: 2
            },
            int32: {
                scale: 2147483648,
                setter: "setInt32",
                width: 4
            },
            float32: {
                scale: 1,
                setter: "setFloat32",
                width: 4
            }
        };
        for (var t in i.audio.convert.pcm) {
            var n = i.audio.convert.pcm[t];
            n.maxFloatValue = i.audio.convert.maxFloatValue(n);
        }
        i.audio.convert.specForPCMType = function(e) {
            var t = "string" == typeof e ? i.audio.convert.pcm[e] : e;
            return t || i.fail("Flocking does not support " + e + " format PCM wave files."), 
            t;
        }, i.audio.convert.floatToInt = function(e, t) {
            var n = Math.min(t.maxFloatValue, e);
            return n = Math.max(-1, n), n *= t.scale, n = Math.round(n);
        }, i.audio.convert.floatsToInts = function(t, n) {
            if (t) {
                for (var r = "Int" + 8 * n.width + "Array", a = new e[r](t.length), o = 0; o < t.length; o++) {
                    var u = t[o], s = i.audio.convert.floatToInt(u, n);
                    a[o] = s;
                }
                return a;
            }
        }, i.audio.convert.intToFloat = function(e, t) {
            return e / t.scale;
        }, i.audio.convert.intsToFloats = function(e, t) {
            if (e) {
                for (var n = new Float32Array(e.length), r = 0; r < e.length; r++) {
                    var a = e[r], o = i.audio.convert.intToFloat(a, t);
                    n[r] = o;
                }
                return n;
            }
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.registerNamespace("flock.audio.encode"), i.audio.interleave = function(e) {
            var t, n, r = e.format.numSampleFrames, a = e.data.channels, o = e.format.numChannels, i = r * o, u = new Float32Array(i), s = 0;
            for (t = 0; t < r; t++) for (n = 0; n < o; n++) u[s] = a[n][t], s++;
            return u;
        }, i.audio.encode = function(e, t, n) {
            return "wav" !== (t = t || "wav").toLowerCase() && i.fail("Flocking currently only supports encoding WAVE files."), 
            i.audio.encode.wav(e, n);
        }, i.audio.encode.writeFloat32Array = function(e, t, n) {
            for (var r = 0; r < n.length; r++) t.setFloat32(e, n[r], !0), e += 4;
            return t;
        }, i.audio.encode.setString = function(e, t, n) {
            for (var r = 0; r < n.length; r++) e.setUint8(t + r, n.charCodeAt(r));
        }, i.audio.encode.setBytes = function(e, t, n) {
            for (var r = 0; r < n.length; r++) e.setUint8(t + r, n[r]);
        }, i.audio.encode.writeAsPCM = function(e, t, n, r) {
            if ("setFloat32" === e.setter && r instanceof Float32Array) return i.audio.encode.writeFloat32Array(t, n, r);
            for (var a = 0; a < r.length; a++) {
                var o = i.audio.convert.floatToInt(r[a], e);
                n[e.setter](t, o, !0), t += e.width;
            }
            return n;
        }, i.audio.encode.wav = function(e, t) {
            t = t || i.audio.convert.pcm.int16;
            var n = i.audio.convert.specForPCMType(t), r = i.audio.interleave(e), a = e.format.numChannels, o = e.format.sampleRate, u = "setFloat32" !== n.setter, s = 16, l = 1, c = r.length * n.width, d = 8 + c, f = n.width * a, p = 8 * n.width;
            if (a > 2 || !u) {
                s += 12, a > 2 ? (s += 24, l = 65534) : (s += 2, l = 3);
            }
            var m = 12 + s + d, g = 8 + m, h = new ArrayBuffer(g), v = new DataView(h);
            i.audio.encode.setString(v, 0, "RIFF"), v.setUint32(4, m, !0), i.audio.encode.setString(v, 8, "WAVE"), 
            i.audio.encode.setString(v, 12, "fmt "), v.setUint32(16, s, !0), v.setUint16(20, l, !0), 
            v.setUint16(22, a, !0), v.setUint32(24, o, !0), v.setUint32(28, o * f, !0), v.setUint16(32, f, !0), 
            v.setUint16(34, p, !0);
            var y = 36;
            return 3 === l ? (v.setUint16(y, 0, !0), y += 2, y = i.audio.encode.wav.writeFactChunk(v, y, e.format.numSampleFrames)) : 65534 === l && (v.setUint16(y, 22, !0), 
            y += 2, y = i.audio.encode.wav.additionalFormat(y, v, p, u), y = i.audio.encode.wav.writeFactChunk(v, y, e.format.numSampleFrames)), 
            i.audio.encode.wav.writeDataChunk(n, y, v, r, c), v.buffer;
        }, i.audio.encode.wav.subformats = {
            pcm: new Uint8Array([ 1, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ]),
            float: new Uint8Array([ 3, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ])
        }, i.audio.encode.wav.additionalFormat = function(e, t, n, r) {
            t.setUint16(e, n, !0), e += 2, t.setUint32(e, 2147483648, !0), e += 4;
            var a = i.audio.encode.wav.subformats[r ? "pcm" : "float"];
            return i.audio.encode.setBytes(t, e, a), e += 16;
        }, i.audio.encode.wav.writeFactChunk = function(e, t, n) {
            return i.audio.encode.setString(e, t, "fact"), t += 4, e.setUint32(t, 4, !0), t += 4, 
            e.setUint32(t, n, !0), t += 4;
        }, i.audio.encode.wav.writeDataChunk = function(e, t, n, r, a) {
            i.audio.encode.setString(n, t, "data"), t += 4, n.setUint32(t, a, !0), t += 4, i.audio.encode.writeAsPCM(e, t, n, r);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.shim = {
            URL: "undefined" != typeof window ? window.URL || window.webkitURL || window.msURL : void 0
        }, i.worker = function(e) {
            var t, n, r = typeof e;
            if ("function" === r) e = "(" + e.toString() + ")();"; else if ("string" !== r) throw new Error("A flock.worker must be initialized with a String or a Function.");
            return window.Blob ? (n = new Blob([ e ], {
                type: "text/javascript"
            }), t = i.shim.URL.createObjectURL(n)) : t = "data:text/javascript;base64," + window.btoa(e), 
            new Worker(t);
        }, r.registerNamespace("flock.scheduler"), r.defaults("flock.scheduler.clock", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                end: "fluid.mustBeOverridden"
            },
            events: {
                tick: null
            },
            listeners: {
                "onDestroy.end": "{that}.end()"
            }
        }), r.defaults("flock.scheduler.intervalClock", {
            gradeNames: [ "flock.scheduler.clock" ],
            members: {
                scheduled: {}
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.intervalClock.schedule",
                    args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.tick.fire", "{that}.events.onClear.fire" ]
                },
                clear: {
                    funcName: "flock.scheduler.intervalClock.clear",
                    args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                clearAll: {
                    funcName: "flock.scheduler.intervalClock.clearAll",
                    args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                end: "{that}.clearAll"
            }
        }), i.scheduler.intervalClock.schedule = function(e, t, n) {
            var r = setInterval(function() {
                n(e);
            }, e);
            t[e] = r;
        }, i.scheduler.intervalClock.clear = function(e, t) {
            var n = t[e];
            clearInterval(n), delete t[e];
        }, i.scheduler.intervalClock.clearAll = function(e, t) {
            for (var n in e) i.scheduler.intervalClock.clear(n, e, t);
        }, r.defaults("flock.scheduler.scheduleClock", {
            gradeNames: [ "flock.scheduler.clock" ],
            members: {
                scheduled: []
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.scheduleClock.schedule",
                    args: [ "{arguments}.0", "{that}.scheduled", "{that}.events" ]
                },
                clear: {
                    funcName: "flock.scheduler.scheduleClock.clear",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                clearAll: {
                    funcName: "flock.scheduler.scheduleClock.clearAll",
                    args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                end: "{that}.clearAll"
            }
        }), i.scheduler.scheduleClock.schedule = function(e, t, n) {
            var r;
            r = setTimeout(function() {
                clearTimeout(r), n.tick.fire(e);
            }, e), t.push(r);
        }, i.scheduler.scheduleClock.clear = function(e, t, n) {
            (t = void 0 === t ? n.indexOf(e) : t) > -1 && (n.splice(t, 1), clearTimeout(e));
        }, i.scheduler.scheduleClock.clearAll = function(e) {
            for (var t = 0; t < e.length; t++) {
                var n = e[t];
                clearTimeout(n);
            }
            e.length = 0;
        }, r.defaults("flock.scheduler.webWorkerClock", {
            gradeNames: [ "fluid.component" ],
            members: {
                worker: {
                    expander: {
                        funcName: "flock.worker",
                        args: "@expand:fluid.getGlobalValue(flock.scheduler.webWorkerClock.workerImpl)"
                    }
                }
            },
            invokers: {
                postToWorker: {
                    funcName: "flock.scheduler.webWorkerClock.postToWorker",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.options.messages", "{that}.worker" ]
                },
                schedule: "{that}.postToWorker(schedule, {arguments}.0)",
                clear: "{that}.postToWorker(clear, {arguments}.0)",
                clearAll: "{that}.postToWorker(clearAll)",
                end: "{that}.postToWorker(end)"
            },
            events: {
                tick: null
            },
            listeners: {
                onCreate: {
                    funcName: "flock.scheduler.webWorkerClock.init",
                    args: [ "{that}" ]
                },
                "onDestroy.clearAllScheduled": "{that}.clearAll",
                "onDestroy.endWorker": {
                    priority: "after:clearAllScheduled",
                    func: "{that}.end"
                }
            },
            startMsg: {
                msg: "start",
                value: "{that}.options.clockType"
            },
            messages: {
                schedule: {
                    msg: "schedule"
                },
                clear: {
                    msg: "clear"
                },
                clearAll: {
                    msg: "clearAll"
                },
                end: {
                    msg: "end"
                }
            }
        }), i.scheduler.webWorkerClock.init = function(e) {
            e.worker.addEventListener("message", function(t) {
                e.events.tick.fire(t.data.value);
            }, !1), e.worker.postMessage(e.options.startMsg);
        }, i.scheduler.webWorkerClock.postToWorker = function(e, t, n, r) {
            var a = n[e];
            void 0 !== t && (a.value = t), r.postMessage(a);
        }, i.scheduler.webWorkerClock.workerImpl = function() {
            var e = e || {};
            e.worker = e.worker || {}, e.worker.clock = function() {
                var e = {};
                return e.tick = function(e) {
                    self.postMessage({
                        msg: "tick",
                        value: e
                    });
                }, e;
            }, e.worker.intervalClock = function() {
                var t = e.worker.clock();
                return t.scheduled = {}, t.schedule = function(e) {
                    var n = setInterval(function() {
                        t.tick(e);
                    }, e);
                    t.scheduled[e] = n;
                }, t.clear = function(e) {
                    var n = t.scheduled[e];
                    clearInterval(n), delete t.scheduled[e];
                }, t.clearAll = function() {
                    for (var e in t.scheduled) t.clear(e);
                }, t;
            }, e.worker.scheduleClock = function() {
                var t = e.worker.clock();
                return t.scheduled = [], t.schedule = function(e) {
                    var n;
                    n = setTimeout(function() {
                        t.clear(n), t.tick(e);
                    }, e), t.scheduled.push(n);
                }, t.clear = function(e, n) {
                    (n = void 0 === n ? t.scheduled.indexOf(e) : n) > -1 && t.scheduled.splice(n, 1), 
                    clearTimeout(e);
                }, t.clearAll = function() {
                    for (var e = 0; e < t.scheduled.length; e++) {
                        var n = t.scheduled[e];
                        clearTimeout(n);
                    }
                    t.scheduled.length = 0;
                }, t;
            }, self.addEventListener("message", function(t) {
                "start" === t.data.msg ? e.clock = e.worker[t.data.value]() : "end" === t.data.msg ? e.clock && (e.clock.clearAll(), 
                self.close()) : e.clock && e.clock[t.data.msg](t.data.value);
            }, !1);
        }, r.defaults("flock.scheduler.webWorkerIntervalClock", {
            gradeNames: [ "flock.scheduler.webWorkerClock" ],
            clockType: "intervalClock"
        }), r.defaults("flock.scheduler.webWorkerScheduleClock", {
            gradeNames: [ "flock.scheduler.webWorkerClock" ],
            clockType: "scheduleClock"
        }), r.defaults("flock.scheduler", {
            gradeNames: [ "fluid.component" ],
            events: {
                onScheduled: null,
                onFinished: null,
                onClearAll: null
            },
            listeners: {
                "onClearAll.clearClock": [ "{that}.clock.clearAll()" ]
            }
        }), i.scheduler.addListener = function(e, t, n) {
            return t.push(e), n(e), e;
        }, i.scheduler.removeListener = function(e, t, n) {
            if (e) {
                var r = t.indexOf(e);
                r > -1 ? (t.splice(r, 1), n(e)) : e.wrappedListener && i.scheduler.removeListener(e.wrappedListener, t, n);
            }
        }, r.defaults("flock.scheduler.repeat", {
            gradeNames: [ "flock.scheduler" ],
            members: {
                listeners: {}
            },
            components: {
                clock: {
                    type: "flock.scheduler.webWorkerIntervalClock"
                }
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.repeat.schedule",
                    args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.listeners", "{that}.events.onScheduled.fire" ]
                },
                clear: "{that}.events.onFinished.fire",
                clearAll: {
                    funcName: "flock.scheduler.repeat.clearAll",
                    args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
                },
                clearInterval: {
                    funcName: "flock.scheduler.repeat.clearInterval",
                    args: [ "{arguments}.0", "{that}.listeners", "{that}.events.onFinished.fire" ]
                },
                addIntervalListener: {
                    funcName: "flock.scheduler.repeat.addIntervalListener",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
                },
                removeIntervalListener: {
                    funcName: "flock.scheduler.repeat.removeIntervalListener",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
                }
            },
            listeners: {
                onScheduled: [ "{that}.addIntervalListener({arguments}.0, {arguments}.1)", "{that}.clock.schedule({arguments}.0)" ],
                onFinished: [ "{that}.removeIntervalListener({arguments}.0, {arguments}.1)" ]
            }
        }), i.scheduler.repeat.intervalListeners = function(e, t) {
            return t[e];
        }, i.scheduler.repeat.addIntervalListener = function(e, t, n, r) {
            var a = i.scheduler.repeat.intervalListeners(e, n);
            i.scheduler.addListener(t, a, r);
        }, i.scheduler.repeat.removeIntervalListener = function(e, t, n, r) {
            var a = i.scheduler.repeat.intervalListeners(e, n);
            i.scheduler.removeListener(t, a, r);
        }, i.scheduler.repeat.schedule = function(e, t, n, r, a, o) {
            e = n.value(e), t = i.scheduler.async.prepareListener(t, r);
            var u = i.scheduler.repeat.wrapValueListener(e, t);
            return i.scheduler.repeat.addInterval(e, a), o(e, u), u;
        }, i.scheduler.repeat.wrapValueListener = function(e, t) {
            var n = function(n) {
                n === e && t(n);
            };
            return n.wrappedListener = t, n;
        }, i.scheduler.repeat.addInterval = function(e, t) {
            var n = t[e];
            n || (n = t[e] = []);
        }, i.scheduler.repeat.clearAll = function(e, t, n) {
            for (var r in e) i.scheduler.repeat.clearInterval(r, e, t);
            n();
        }, i.scheduler.repeat.clearInterval = function(e, t, n) {
            var r = t[e];
            if (r) for (var a = 0; a < r.length; a++) n(e, r[a]);
        }, r.defaults("flock.scheduler.once", {
            gradeNames: [ "flock.scheduler" ],
            members: {
                listeners: []
            },
            components: {
                clock: {
                    type: "flock.scheduler.webWorkerScheduleClock"
                }
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.once.schedule",
                    args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.clear", "{that}.events.onScheduled.fire" ]
                },
                clear: "{that}.events.onFinished.fire",
                clearAll: {
                    funcName: "flock.scheduler.once.clearAll",
                    args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
                }
            },
            listeners: {
                onScheduled: [ {
                    funcName: "flock.scheduler.addListener",
                    args: [ "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
                }, {
                    func: "{that}.clock.schedule",
                    args: [ "{arguments}.0" ]
                } ],
                onFinished: {
                    funcName: "flock.scheduler.removeListener",
                    args: [ "{arguments}.0", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
                }
            }
        }), i.scheduler.once.wrapValueListener = function(e, t, n) {
            var r = function(a) {
                a === e && (t(a), n(r));
            };
            return r.wrappedListener = t, r;
        }, i.scheduler.once.schedule = function(e, t, n, r, a, o) {
            e = n.value(e), t = i.scheduler.async.prepareListener(t, r);
            var u = i.scheduler.once.wrapValueListener(e, t, a);
            return o(e, u), u;
        }, i.scheduler.once.clearAll = function(e, t, n) {
            for (var r = 0; r < e.length; r++) t(e[r]);
            n();
        }, r.defaults("flock.scheduler.async", {
            gradeNames: [ "fluid.component" ],
            subSchedulerOptions: {
                components: {
                    timeConverter: "{async}.timeConverter"
                },
                listeners: {
                    "{async}.events.onClear": "{that}.clear()",
                    "{async}.events.onClearAll": "{that}.clearAll()",
                    "{async}.events.onEnd": "{that}.clock.end()"
                }
            },
            distributeOptions: {
                source: "{that}.options.subSchedulerOptions",
                removeSource: !0,
                target: "{that flock.scheduler}.options"
            },
            components: {
                timeConverter: {
                    type: "flock.convert.seconds"
                },
                onceScheduler: {
                    type: "flock.scheduler.once"
                },
                repeatScheduler: {
                    type: "flock.scheduler.repeat"
                },
                synthContext: void 0
            },
            invokers: {
                repeat: {
                    func: "{repeatScheduler}.schedule",
                    args: [ "{arguments}.0", "{arguments}.1" ]
                },
                once: {
                    func: "{onceScheduler}.schedule",
                    args: [ "{arguments}.0", "{arguments}.1" ]
                },
                sequence: {
                    funcName: "flock.scheduler.async.sequence",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.once" ]
                },
                schedule: {
                    funcName: "flock.scheduler.async.schedule",
                    args: [ "{arguments}.0", "{that}" ]
                },
                clear: "{that}.events.onClear.fire",
                clearAll: "{that}.events.onClearAll.fire",
                end: "{that}.events.onEnd.fire"
            },
            events: {
                onClear: null,
                onClearAll: null,
                onEnd: null
            },
            listeners: {
                onCreate: "{that}.schedule({that}.options.score)",
                onEnd: "{that}.clearAll"
            }
        }), i.scheduler.async.sequence = function(e, t, n) {
            for (var r = [], a = 0; a < e.length; a++) {
                var o = n(e[a], t);
                r.push(o);
            }
            return r;
        }, i.scheduler.async.schedule = function(e, t) {
            if (e) {
                e = i.isIterable(e) ? e : [ e ];
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    i.invoke(t, r.interval, [ r.time, r.change ]);
                }
            }
        }, i.scheduler.async.prepareListener = function(e, t) {
            return "function" == typeof e ? e : i.scheduler.async.evaluateChangeSpec(e, t);
        }, i.scheduler.async.getTargetSynth = function(e, t) {
            var n = e.synth;
            return n ? "string" != typeof n ? n : r.get(t, n) : t;
        }, i.scheduler.async.makeSynthUpdater = function(e, t, n, r) {
            return function() {
                for (var a in e) {
                    var o = e[a];
                    n[a] = i.evaluate.synthValue(o);
                }
                var u = i.scheduler.async.getTargetSynth(t, r);
                u ? u.set(n) : i.fail("A target synth named " + t.synth + " could not be found in the specified synthContext. Synth context was: " + r);
            };
        }, i.scheduler.async.evaluateChangeSpec = function(e, t) {
            var n = {}, r = {};
            for (var a in e.values) {
                var o = e.values[a];
                o.synthDef ? n[a] = i.synth.value(o) : r[a] = o;
            }
            return i.scheduler.async.makeSynthUpdater(n, e, r, t);
        }, r.defaults("flock.scheduler.async.tempo", {
            gradeNames: [ "flock.scheduler.async" ],
            bpm: 60,
            components: {
                timeConverter: {
                    type: "flock.convert.beats",
                    options: {
                        bpm: "{tempo}.options.bpm"
                    }
                }
            }
        }), r.registerNamespace("flock.convert"), r.defaults("flock.convert.ms", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                value: "fluid.identity({arguments}.0)"
            }
        }), r.defaults("flock.convert.seconds", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                value: "flock.convert.seconds.toMillis({arguments}.0)"
            }
        }), i.convert.seconds.toMillis = function(e) {
            return 1e3 * e;
        }, r.defaults("flock.convert.beats", {
            gradeNames: [ "fluid.component" ],
            bpm: 60,
            invokers: {
                value: "flock.convert.beats.toMillis({arguments}.0, {that}.options.bpm)"
            }
        }), i.convert.beats.toMillis = function(e, t) {
            return t <= 0 ? 0 : e / t * 6e4;
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.registerNamespace("flock.webAudio"), i.webAudio.createNode = function(e, t) {
            var n = t.args ? r.makeArray(t.args) : void 0, a = "create" + t.node, o = a.indexOf("Node");
            o > -1 && (a = a.substring(0, o));
            var u = e[a].apply(e, n);
            return i.webAudio.initNodeParams(e, u, t), i.webAudio.initNodeProperties(u, t), 
            i.webAudio.initNodeInputs(u, t), u;
        }, i.webAudio.setAudioParamValue = function(e, t, n, r) {
            r = r || 0;
            var a = e.currentTime + r;
            t.setValueAtTime(n, a);
        }, i.webAudio.initNodeParams = function(e, t, n) {
            var r = n.params;
            if (t && r) {
                for (var a in r) {
                    var o = t[a], u = r[a];
                    i.webAudio.setAudioParamValue(e, o, u);
                }
                return t;
            }
        }, i.webAudio.safariPropertyProhibitions = [ "channelCount", "channelCountMode" ], 
        i.webAudio.shouldSetProperty = function(e) {
            return !i.platform.browser.safari || i.webAudio.safariPropertyProhibitions.indexOf(e) < 0;
        }, i.webAudio.initNodeProperties = function(e, t) {
            var n = t.props;
            if (n) {
                for (var r in n) {
                    var a = n[r];
                    i.webAudio.shouldSetProperty(r) && (e[r] = a);
                }
                return e;
            }
        }, i.webAudio.connectInput = function(e, t, n, r) {
            n.connect(e, r, t);
        }, i.webAudio.initNodeInputs = function(e, t) {
            var n = t.inputs;
            for (var a in n) {
                var o = n[a], u = parseInt(a, 10);
                o = r.makeArray(o);
                for (var s = 0; s < o.length; s++) {
                    var l = o[s];
                    i.webAudio.connectInput(e, u, l);
                }
            }
        }, r.defaults("flock.webAudio.node", {
            gradeNames: [ "fluid.modelComponent" ],
            members: {
                node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
            },
            nodeSpec: {
                args: [],
                params: {},
                properties: {}
            }
        }), r.defaults("flock.webAudio.gain", {
            gradeNames: [ "flock.webAudio.node" ],
            members: {
                node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
            },
            nodeSpec: {
                node: "Gain"
            }
        }), r.defaults("flock.webAudio.scriptProcessor", {
            gradeNames: [ "flock.webAudio.node" ],
            nodeSpec: {
                node: "ScriptProcessor",
                args: [ "{audioSystem}.model.bufferSize", "{audioSystem}.model.numInputBuses", "{audioSystem}.model.chans" ],
                params: {},
                properties: {
                    channelCountMode: "explicit"
                }
            }
        }), r.defaults("flock.webAudio.channelMerger", {
            gradeNames: [ "flock.webAudio.node" ],
            nodeSpec: {
                node: "ChannelMerger",
                args: [ "{audioSystem}.model.numInputBuses" ],
                properties: {
                    channelCountMode: "discrete"
                }
            }
        }), r.defaults("flock.webAudio.outputFader", {
            gradeNames: [ "fluid.component" ],
            fadeDuration: .5,
            gainSpec: {
                node: "Gain",
                params: {
                    gain: 0
                },
                properties: {
                    channelCount: "{flock.enviro}.audioSystem.model.chans",
                    channelCountMode: "explicit"
                }
            },
            members: {
                gainNode: "@expand:flock.webAudio.outputFader.createGainNode({flock.enviro}.audioSystem.nativeNodeManager, {that}.options.gainSpec)",
                context: "{flock.enviro}.audioSystem.context"
            },
            invokers: {
                fadeIn: {
                    funcName: "flock.webAudio.outputFader.fadeIn",
                    args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
                },
                fadeTo: {
                    funcName: "flock.webAudio.outputFader.fadeTo",
                    args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
                }
            }
        }), i.webAudio.outputFader.createGainNode = function(e, t) {
            return e.createOutputNode(t);
        }, i.webAudio.outputFader.fade = function(e, t, n, r, a) {
            a = a || 0;
            var o = e.currentTime + a;
            i.webAudio.setAudioParamValue(e, t.gain, n), t.gain.linearRampToValueAtTime(r, o);
        }, i.webAudio.outputFader.fadeTo = function(e, t, n, r) {
            i.webAudio.outputFader.fade(e, t, t.gain.value, n, r);
        }, i.webAudio.outputFader.fadeIn = function(e, t, n, r) {
            i.webAudio.outputFader.fade(e, t, 0, n, r);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.webAudio.audioSystem", {
            gradeNames: [ "flock.audioSystem" ],
            channelRange: {
                min: "@expand:flock.webAudio.audioSystem.calcMinChannels()",
                max: "@expand:flock.webAudio.audioSystem.calcMaxChannels({that}.context.destination)"
            },
            members: {
                context: "@expand:flock.webAudio.audioSystem.createContext()"
            },
            model: {
                rates: {
                    audio: "{that}.context.sampleRate"
                }
            },
            components: {
                outputManager: {
                    type: "flock.webAudio.outputManager"
                },
                nativeNodeManager: {
                    type: "flock.webAudio.nativeNodeManager"
                },
                inputDeviceManager: {
                    type: "flock.webAudio.inputDeviceManager"
                },
                bufferWriter: {
                    type: "flock.webAudio.bufferWriter"
                }
            },
            listeners: {
                onCreate: [ "flock.webAudio.audioSystem.configureDestination({that}.context, {that}.model.chans)" ]
            }
        }), i.webAudio.audioSystem.createContext = function() {
            var e = i.webAudio.audioSystem;
            return e.audioContextSingleton || (e.audioContextSingleton = new i.shim.AudioContext()), 
            e.audioContextSingleton;
        }, i.webAudio.audioSystem.calcMaxChannels = function(e) {
            return i.platform.browser.safari ? e.channelCount : e.maxChannelCount;
        }, i.webAudio.audioSystem.calcMinChannels = function() {
            return i.platform.browser.safari ? 2 : 1;
        }, i.webAudio.audioSystem.configureDestination = function(e, t) {
            i.platform.browser.safari || (e.destination.channelCount = t, e.destination.channelCountMode = "explicit", 
            e.destination.channelInterpretation = "discrete");
        }, r.defaults("flock.webAudio.enviroContextDistributor", {
            gradeNames: [ "fluid.component" ],
            distributeOptions: [ {
                target: "{/ flock.enviro > audioSystem}.options",
                record: {
                    gradeNames: "flock.webAudio.audioSystem"
                }
            } ]
        }), r.constructSingle([], {
            singleRootType: "flock.enviroContextDistributor",
            type: "flock.webAudio.enviroContextDistributor"
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.webAudio.bufferWriter", {
            gradeNames: "fluid.component",
            invokers: {
                save: "flock.webAudio.bufferWriter.saveBuffer({arguments}.0)"
            }
        }), i.webAudio.bufferWriter.saveBuffer = function(e) {
            try {
                var t = i.audio.encode.wav(e.buffer, e.format), n = new Blob([ t ], {
                    type: "audio/wav"
                });
                return i.webAudio.bufferWriter.download(e.path, n), e.success && e.success(t), t;
            } catch (t) {
                e.error ? e.error(t) : i.fail("There was an error while trying to download the buffer named " + e.buffer.id + ". Error: " + t);
            }
        }, i.webAudio.bufferWriter.download = function(e, t) {
            var n = i.shim.URL.createObjectURL(t), r = window.document.createElement("a"), a = document.createEvent("Event");
            r.href = n, r.download = e, a.initEvent("click", !0, !0), r.dispatchEvent(a);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.registerNamespace("flock.webAudio.chrome"), i.webAudio.chrome.getSources = function(e) {
            return MediaStreamTrack.getSources(function(t) {
                var n = r.transform(t, function(e) {
                    return e.deviceId = e.id, e;
                });
                e(n);
            });
        }, i.webAudio.mediaStreamFailure = function() {
            i.fail("Media Capture and Streams are not supported on this browser.");
        };
        var e = {
            AudioContext: window.AudioContext || window.webkitAudioContext,
            getUserMediaImpl: navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || i.webAudio.mediaStreamFailure,
            getUserMedia: function() {
                i.shim.getUserMediaImpl.apply(navigator, arguments);
            },
            getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices : void 0 !== window.MediaStreamTrack ? i.webAudio.chrome.getSources : i.webAudio.mediaStreamFailure,
            getMediaDevice: function() {
                i.shim.getMediaDevicesImpl.apply(navigator, arguments);
            }
        };
        t.extend(i.shim, e), r.defaults("flock.webAudio.inputDeviceManager", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                openAudioDevice: {
                    funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                    args: [ "{arguments}.0", "{that}.openAudioDeviceWithId", "{that}.openFirstAudioDeviceWithLabel", "{that}.openAudioDeviceWithConstraints" ]
                },
                openAudioDeviceWithConstraints: {
                    funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                    args: [ "{audioSystem}.context", "{enviro}", "{nativeNodeManager}.createMediaStreamInput", "{arguments}.0" ]
                },
                openAudioDeviceWithId: {
                    funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                    args: [ "{arguments}.0", "{that}.openAudioDeviceWithConstraints" ]
                },
                openFirstAudioDeviceWithLabel: {
                    funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                    args: [ "{arguments}.0", "{that}.openAudioDeviceWithId" ]
                }
            }
        }), i.webAudio.inputDeviceManager.openAudioDevice = function(e, t, n, r) {
            if (e) {
                if (e.id) return t(e.id);
                if (e.label) return n(e.label);
            }
            return r();
        }, i.webAudio.inputDeviceManager.openAudioDeviceWithId = function(e, t) {
            t({
                audio: {
                    optional: [ {
                        sourceId: e
                    } ]
                }
            });
        }, i.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function(e, t) {
            e && i.shim.getMediaDevices(function(n) {
                var a = n.filter(function(t) {
                    if (t.label.toLowerCase() === e.toLowerCase()) return !0;
                });
                a.length > 0 ? t(a[0].deviceId) : r.log(r.logLevel.IMPORTANT, "An audio device named '" + e + "' could not be found.");
            });
        }, i.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function(e, t, n, a) {
            a = a || {
                audio: !0
            };
            var o = t.busManager.acquireNextBus("input");
            return i.shim.getUserMedia(a, function(e) {
                n(e, o);
            }, function(e) {
                r.log(r.logLevel.IMPORTANT, "An error occurred while trying to access the user's microphone. " + e);
            }), o;
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.registerNamespace("flock.midi"), i.midi.requestAccess = function(e, t, n) {
            if (!navigator.requestMIDIAccess) {
                var a = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
                return r.log(r.logLevel.WARN, a), void n(a);
            }
            navigator.requestMIDIAccess({
                sysex: e
            }).then(t, n);
        }, i.midi.getPorts = function(e) {
            var t = {}, n = "function" == typeof e.inputs ? i.midi.collectPortsLegacy : i.midi.collectPorts;
            return n("inputs", e, t), n("outputs", e, t), t;
        }, i.midi.requestPorts = function(e, t) {
            i.midi.requestAccess(!1, function(t) {
                var n = i.midi.getPorts(t);
                e(n);
            }, t);
        }, i.midi.createPortViews = function(e) {
            return r.transform(e, function(e) {
                return {
                    id: e.id,
                    name: e.name,
                    manufacturer: e.manufacturer,
                    state: e.state,
                    connection: e.connection
                };
            });
        }, i.midi.prettyPrintPorts = function(e) {
            return r.prettyPrintJSON({
                inputs: i.midi.createPortViews(e.inputs),
                outputs: i.midi.createPortViews(e.outputs)
            });
        }, i.midi.logPorts = function() {
            i.midi.requestPorts(function(e) {
                var t = i.midi.prettyPrintPorts(e);
                console.log(t);
            }, function(e) {
                console.log(e);
            });
        }, i.midi.collectPorts = function(e, t, n) {
            for (var r = n[e] = n[e] || [], a = t[e].values(), o = a.next(); !o.done; ) r.push(o.value), 
            o = a.next();
            return n;
        }, i.midi.collectPortsLegacy = function(e, t, n) {
            return t[e] && (n[e] = t[e]()), n;
        }, i.midi.read = function(e) {
            var t, n = e[0], a = 15 & n;
            switch (n >> 4) {
              case 8:
                t = i.midi.read.noteOff;
                break;

              case 9:
                t = e[2] > 0 ? i.midi.read.noteOn : i.midi.read.noteOff;
                break;

              case 10:
                t = i.midi.read.polyAftertouch;
                break;

              case 11:
                t = i.midi.read.controlChange;
                break;

              case 12:
                t = i.midi.read.programChange;
                break;

              case 13:
                t = i.midi.read.channelAftertouch;
                break;

              case 14:
                t = i.midi.read.pitchbend;
                break;

              case 15:
                t = i.midi.read.system;
                break;

              default:
                return i.fail("Received an unrecognized MIDI message: " + r.prettyPrintJSON(e));
            }
            return t(a, e);
        }, i.midi.read.note = function(e, t, n) {
            return {
                type: e,
                chan: t,
                note: n[1],
                velocity: n[2]
            };
        }, i.midi.read.noteOn = function(e, t) {
            return i.midi.read.note("noteOn", e, t);
        }, i.midi.read.noteOff = function(e, t) {
            return i.midi.read.note("noteOff", e, t);
        }, i.midi.read.polyAftertouch = function(e, t) {
            return {
                type: "aftertouch",
                chan: e,
                note: t[1],
                pressure: t[2]
            };
        }, i.midi.read.controlChange = function(e, t) {
            return {
                type: "control",
                chan: e,
                number: t[1],
                value: t[2]
            };
        }, i.midi.read.programChange = function(e, t) {
            return {
                type: "program",
                chan: e,
                program: t[1]
            };
        }, i.midi.read.channelAftertouch = function(e, t) {
            return {
                type: "aftertouch",
                chan: e,
                pressure: t[1]
            };
        }, i.midi.read.twoByteValue = function(e) {
            return e[2] << 7 | e[1];
        }, i.midi.read.pitchbend = function(e, t) {
            return {
                type: "pitchbend",
                chan: e,
                value: i.midi.read.twoByteValue(t)
            };
        }, i.midi.read.system = function(e, t) {
            if (1 === e) return i.midi.messageFailure("quarter frame MTC");
            var n;
            switch (e) {
              case 0:
                n = i.midi.read.sysex;
                break;

              case 2:
                n = i.midi.read.songPointer;
                break;

              case 3:
                n = i.midi.read.songSelect;
                break;

              case 6:
                n = i.midi.read.tuneRequest;
                break;

              case 8:
                n = i.midi.read.clock;
                break;

              case 10:
                n = i.midi.read.start;
                break;

              case 11:
                n = i.midi.read.continue;
                break;

              case 12:
                n = i.midi.read.stop;
                break;

              case 14:
                n = i.midi.read.activeSense;
                break;

              case 15:
                n = i.midi.read.reset;
                break;

              default:
                return i.fail("Received an unrecognized MIDI system message: " + r.prettyPrintJSON(t));
            }
            return n(t);
        }, i.midi.messageFailure = function(e) {
            i.fail("Flocking does not currently support MIDI " + e + " messages.");
        }, i.midi.read.sysex = function(e) {
            return {
                type: "sysex",
                data: e
            };
        }, i.midi.read.valueMessage = function(e, t) {
            return {
                type: e,
                value: t
            };
        }, i.midi.read.songPointer = function(e) {
            var t = i.midi.read.twoByteValue(e);
            return i.midi.read.valueMessage("songPointer", t);
        }, i.midi.read.songSelect = function(e) {
            return i.midi.read.valueMessage("songSelect", e[1]);
        }, i.midi.read.tuneRequest = function() {
            return {
                type: "tuneRequest"
            };
        }, i.midi.systemRealtimeMessages = [ "tuneRequest", "clock", "start", "continue", "stop", "activeSense", "reset" ], 
        i.midi.createSystemRealtimeMessageReaders = function(e) {
            r.each(e, function(e) {
                i.midi.read[e] = function() {
                    return {
                        type: e
                    };
                };
            });
        }, i.midi.createSystemRealtimeMessageReaders(i.midi.systemRealtimeMessages), r.defaults("flock.midi.system", {
            gradeNames: [ "fluid.component" ],
            sysex: !1,
            members: {
                access: void 0,
                ports: void 0
            },
            invokers: {
                requestAccess: {
                    funcName: "flock.midi.requestAccess",
                    args: [ "{that}.options.sysex", "{that}.events.onAccessGranted.fire", "{that}.events.onAccessError.fire" ]
                },
                refreshPorts: {
                    funcName: "flock.midi.system.refreshPorts",
                    args: [ "{that}", "{that}.access", "{that}.events.onPortsAvailable.fire" ]
                }
            },
            events: {
                onAccessGranted: null,
                onAccessError: null,
                onReady: null,
                onPortsAvailable: null
            },
            listeners: {
                onCreate: {
                    func: "{that}.requestAccess"
                },
                onAccessGranted: [ "flock.midi.system.setAccess({that}, {arguments}.0)", "{that}.refreshPorts()", "{that}.events.onReady.fire({that}.ports)" ],
                onAccessError: {
                    funcName: "fluid.log",
                    args: [ r.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0" ]
                }
            }
        }), i.midi.system.setAccess = function(e, t) {
            e.access = t;
        }, i.midi.system.refreshPorts = function(e, t, n) {
            e.ports = i.midi.getPorts(t), n(e.ports);
        }, r.defaults("flock.midi.receiver", {
            gradeNames: [ "fluid.component" ],
            events: {
                raw: null,
                message: null,
                note: null,
                noteOn: null,
                noteOff: null,
                control: null,
                program: null,
                aftertouch: null,
                pitchbend: null
            }
        }), r.defaults("flock.midi.connection", {
            gradeNames: [ "flock.midi.receiver" ],
            openImmediately: !1,
            sysex: !1,
            distributeOptions: {
                source: "{that}.options.sysex",
                target: "{that > system}.options.sysex"
            },
            ports: 0,
            invokers: {
                sendRaw: {
                    func: "{that}.events.onSendRaw.fire"
                },
                send: {
                    funcName: "flock.midi.connection.send"
                },
                open: {
                    funcName: "flock.midi.connection.bind",
                    args: [ "{that}.system.ports", "{that}.options.ports", "{that}.events.onReady.fire", "{that}.events.raw.fire", "{that}.events.onSendRaw" ]
                },
                close: {
                    funcName: "flock.midi.connection.close",
                    args: [ "{that}.system.ports", "{that}.events.raw.fire" ]
                }
            },
            components: {
                system: {
                    type: "flock.midi.system",
                    options: {
                        events: {
                            onReady: "{connection}.events.onPortsAvailable"
                        }
                    }
                }
            },
            events: {
                onPortsAvailable: null,
                onReady: null,
                onError: null,
                onSendRaw: null
            },
            listeners: {
                onPortsAvailable: {
                    funcName: "flock.midi.connection.autoOpen",
                    args: [ "{that}.options.openImmediately", "{that}.open" ]
                },
                onError: {
                    funcName: "fluid.log",
                    args: [ r.logLevel.WARN, "{arguments}.0" ]
                },
                raw: {
                    funcName: "flock.midi.connection.fireEvent",
                    args: [ "{arguments}.0", "{that}.events" ]
                },
                onDestroy: [ "{that}.close()" ]
            }
        }), i.midi.connection.send = function() {
            i.fail("Sending MIDI messages is not currently supported.");
        }, i.midi.connection.autoOpen = function(e, t) {
            e && t();
        }, i.midi.findPorts = function(e, t) {
            t = r.makeArray(t);
            var n = [];
            return r.each(t, function(t) {
                var r = i.midi.findPorts.portFinder(t)(e);
                n = n.concat(r);
            }), n;
        }, i.midi.findPorts.portFinder = function(e) {
            if ("number" == typeof e) return i.midi.findPorts.byIndex(e);
            "string" == typeof e && (e = {
                name: e
            });
            var t = e.id ? i.midi.findPorts.idMatcher(e.id) : e.manufacturer && e.name ? i.midi.findPorts.bothMatcher(e.manufacturer, e.name) : e.manufacturer ? i.midi.findPorts.manufacturerMatcher(e.manufacturer) : i.midi.findPorts.nameMatcher(e.name);
            return function(e) {
                return e.filter(t);
            };
        }, i.midi.findPorts.byIndex = function(e) {
            return function(t) {
                var n = t[e];
                return n ? [ n ] : [];
            };
        }, i.midi.findPorts.lowerCaseContainsMatcher = function(e) {
            return function(t) {
                var n;
                for (var r in e) {
                    var a = t[r], o = e[r];
                    if (!(n = "*" === o || a && a.toLowerCase().indexOf(o.toLowerCase()) > -1)) break;
                }
                return n;
            };
        }, i.midi.findPorts.idMatcher = function(e) {
            return function(t) {
                return t.id === e;
            };
        }, i.midi.findPorts.bothMatcher = function(e, t) {
            return i.midi.findPorts.lowerCaseContainsMatcher({
                manufacturer: e,
                name: t
            });
        }, i.midi.findPorts.manufacturerMatcher = function(e) {
            return i.midi.findPorts.lowerCaseContainsMatcher({
                manufacturer: e
            });
        }, i.midi.findPorts.nameMatcher = function(e) {
            return i.midi.findPorts.lowerCaseContainsMatcher({
                name: e
            });
        }, i.midi.findPorts.eachPortOfType = function(e, t, n) {
            var a = r.makeArray(e);
            r.each(a, function(e) {
                e.type === t && n(e);
            });
        }, i.midi.connection.openPort = function(e, t) {
            if (e.open) {
                var n = e.open();
                t.push(n);
            }
            return t;
        }, i.midi.connection.listen = function(e, t, n) {
            return i.midi.findPorts.eachPortOfType(e, "input", function(e) {
                i.midi.connection.openPort(e, n), e.addEventListener("midimessage", t, !1);
            }), n;
        }, i.midi.connection.stopListening = function(e, t) {
            i.midi.findPorts.eachPortOfType(e, "input", function(e) {
                e.close(), e.removeEventListener("midimessage", t, !1);
            });
        }, i.midi.connection.bindSender = function(e, t, n) {
            var a = r.makeArray(e);
            return r.each(a, function(e) {
                i.midi.connection.openPort(e, n), t.addListener(e.send.bind(e));
            }), n;
        }, i.midi.connection.fireReady = function(e, t) {
            !e || e.length < 1 || Promise.all(e).then(t);
        }, i.midi.connection.bind = function(e, t, n, r, a) {
            t = i.midi.connection.expandPortSpec(t);
            var o = i.midi.findPorts(e.inputs, t.input), u = i.midi.findPorts(e.outputs, t.output), s = [];
            o && o.length > 0 ? i.midi.connection.listen(o, r, s) : void 0 !== t.input && i.midi.connection.logNoMatchedPorts("input", t), 
            u && u.length > 0 ? i.midi.connection.bindSender(u, a, s) : void 0 !== t.output && i.midi.connection.logNoMatchedPorts("output", t), 
            i.midi.connection.fireReady(s, n);
        }, i.midi.connection.close = function(e, t) {
            i.midi.connection.stopListening(e.inputs, t);
        }, i.midi.connection.logNoMatchedPorts = function(e, t) {
            r.log(r.logLevel.WARN, "No matching " + e + " ports were found for port specification: ", t[e]);
        }, i.midi.connection.expandPortSpec = function(e) {
            if (void 0 !== e.input || void 0 !== e.output) return e;
            var t = {
                input: {},
                output: {}
            };
            return "number" == typeof e ? t.input = t.output = e : (i.midi.connection.expandPortSpecProperty("manufacturer", e, t), 
            i.midi.connection.expandPortSpecProperty("name", e, t)), t;
        }, i.midi.connection.expandPortSpecProperty = function(e, t, n) {
            return n.input[e] = n.output[e] = t[e], n;
        }, i.midi.connection.fireEvent = function(e, t) {
            var n = i.midi.read(e.data), r = n.type ? t[n.type] : void 0;
            t.message.fire(n, e), "noteOn" !== n.type && "noteOff" !== n.type || t.note.fire(n, e), 
            r && r.fire(n, e);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.midi.controller", {
            gradeNames: [ "fluid.component" ],
            members: {
                controlMap: {
                    expander: {
                        funcName: "flock.midi.controller.optimizeMIDIMap",
                        args: [ "{that}.options.controlMap" ]
                    }
                },
                noteMap: {
                    expander: {
                        funcName: "flock.midi.controller.optimizeNoteMap",
                        args: [ "{that}.options.noteMap" ]
                    }
                }
            },
            controlMap: {},
            noteMap: {},
            components: {
                synthContext: {
                    type: "flock.band"
                },
                connection: {
                    type: "flock.midi.connection",
                    options: {
                        ports: {
                            input: "*"
                        },
                        openImmediately: !0
                    }
                }
            },
            invokers: {
                mapControl: {
                    funcName: "flock.midi.controller.mapControl",
                    args: [ "{arguments}.0", "{that}.synthContext", "{that}.controlMap" ]
                },
                mapNote: {
                    funcName: "flock.midi.controller.mapNote",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.synthContext", "{that}.noteMap" ]
                }
            },
            events: {
                control: "{that}.connection.events.control",
                note: "{that}.connection.events.note",
                noteOn: "{that}.connection.events.noteOn",
                noteOff: "{that}.connection.events.noteOff"
            },
            listeners: {
                control: "{that}.mapControl({arguments}.0)",
                note: "{that}.mapNote(note, {arguments}.0)",
                noteOn: "{that}.mapNote(noteOn, {arguments}.0)",
                noteOff: "{that}.mapNote(noteOff, {arguments}.0)"
            }
        }), i.midi.controller.optimizeMIDIMap = function(e) {
            var t = new Array(127);
            return r.each(e, function(e, n) {
                var a = Number(n);
                t[a] = r.makeArray(e);
            }), t;
        }, i.midi.controller.optimizeNoteMap = function(e) {
            return {
                note: r.makeArray(e.note),
                noteOn: r.makeArray(e.noteOn),
                noteOff: r.makeArray(e.noteOff),
                velocity: r.makeArray(e.velocity)
            };
        }, i.midi.controller.expandControlMapSpec = function(e, t) {
            return t.transform.id = e, t.valuePath = t.valuePath || "value", t.transform.ugen || (t.transform.ugen = "flock.ugen.value"), 
            t;
        }, i.midi.controller.makeValueSynth = function(e, t, n) {
            var r = (n = i.midi.controller.expandControlMapSpec(t, n)).transform, a = n.valuePath;
            i.set(r, a, e);
            var o = i.synth.value({
                synthDef: r
            });
            return n.valuePath = t + "." + a, o;
        }, i.midi.controller.transformValue = function(e, t) {
            var n = t.transform;
            return "function" === typeof n ? n(e) : (t.transformSynth ? t.transformSynth.set(t.valuePath, e) : t.transformSynth = i.midi.controller.makeValueSynth(e, "flock-midi-controller-in", t), 
            t.transformSynth.value());
        }, i.midi.controller.setMappedValue = function(e, t, n) {
            e = void 0 !== t.value ? t.value : t.transform ? i.midi.controller.transformValue(e, t) : e, 
            (n[t.synth] || n).set(t.input, e);
        }, i.midi.controller.mapMIDIValue = function(e, t, n) {
            if (t && !(t.length < 1)) for (var r = 0; r < t.length; r++) {
                var a = t[r];
                i.midi.controller.setMappedValue(e, a, n);
            }
        }, i.midi.controller.mapControl = function(e, t, n) {
            var r = n[e.number], a = e.value;
            i.midi.controller.mapMIDIValue(a, r, t);
        }, i.midi.controller.mapNote = function(e, t, n, r) {
            var a = r[e], o = t.note, u = r.velocity, s = t.velocity;
            i.midi.controller.mapMIDIValue(o, a, n), i.midi.controller.mapMIDIValue(s, u, n);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.webAudio.nativeNodeManager", {
            gradeNames: [ "fluid.component" ],
            members: {
                outputNode: void 0,
                inputNodes: []
            },
            components: {
                scriptProcessor: {
                    createOnEvent: "onCreateScriptProcessor",
                    type: "flock.webAudio.scriptProcessor",
                    options: {
                        nodeSpec: {
                            inputs: {
                                "0": "{inputMerger}"
                            }
                        }
                    }
                },
                merger: {
                    type: "flock.webAudio.channelMerger"
                }
            },
            invokers: {
                connect: "{that}.events.onConnect.fire",
                disconnect: "{that}.events.onDisconnect.fire",
                createNode: {
                    funcName: "flock.webAudio.createNode",
                    args: [ "{audioSystem}.context", "{arguments}.0" ]
                },
                createInputNode: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                },
                createMediaStreamInput: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                    args: [ "{that}", {
                        node: "MediaStreamSource",
                        args: [ "{arguments}.0" ]
                    }, "{arguments}.1" ]
                },
                createMediaElementInput: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                    args: [ "{that}", {
                        node: "MediaElementSource",
                        args: [ "{arguments}.0" ]
                    }, "{arguments}.1" ]
                },
                createOutputNode: {
                    funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
                    args: [ "{that}", "{arguments}.0" ]
                },
                insertInput: {
                    funcName: "flock.webAudio.nativeNodeManager.insertInput",
                    args: [ "{that}", "{audioSystem}.model", "{enviro}", "{arguments}.0", "{arguments}.1" ]
                },
                removeInput: {
                    funcName: "flock.webAudio.nativeNodeManager.removeInput",
                    args: [ "{arguments}.0", "{that}.inputNodes" ]
                },
                removeAllInputs: {
                    funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
                    args: "{that}.inputNodes"
                },
                insertOutput: {
                    funcName: "flock.webAudio.nativeNodeManager.insertOutput",
                    args: [ "{that}", "{arguments}.0" ]
                },
                removeOutput: {
                    funcName: "flock.webAudio.nativeNodeManager.removeOutput",
                    args: [ "{scriptProcessor}.node" ]
                }
            },
            events: {
                onStart: "{enviro}.events.onStart",
                onStop: "{enviro}.events.onStop",
                onReset: "{enviro}.events.onReset",
                onCreateScriptProcessor: null,
                onConnect: null,
                onDisconnectNodes: null,
                onDisconnect: null
            },
            listeners: {
                onCreate: [ "{that}.events.onCreateScriptProcessor.fire()", {
                    func: "{that}.insertOutput",
                    args: "{scriptProcessor}.node"
                } ],
                onStart: [ "{that}.connect()" ],
                onConnect: [ {
                    this: "{merger}.node",
                    method: "connect",
                    args: [ "{scriptProcessor}.node" ]
                }, {
                    this: "{that}.outputNode",
                    method: "connect",
                    args: [ "{audioSystem}.context.destination" ]
                }, {
                    funcName: "flock.webAudio.nativeNodeManager.connectOutput",
                    args: [ "{scriptProcessor}.node", "{that}.outputNode" ]
                } ],
                onStop: [ "{that}.disconnect()" ],
                onDisconnectNodes: [ {
                    this: "{merger}.node",
                    method: "disconnect",
                    args: [ 0 ]
                }, {
                    this: "{scriptProcessor}.node",
                    method: "disconnect",
                    args: [ 0 ]
                }, {
                    this: "{that}.outputNode",
                    method: "disconnect",
                    args: [ 0 ]
                } ],
                "onDisconnect.onDisconnectNodes": {
                    func: "{that}.events.onDisconnectNodes.fire"
                },
                onReset: [ "{that}.removeAllInputs()", "{that}.events.onCreateScriptProcessor.fire()" ],
                onDestroy: [ "{that}.events.onDisconnectNodes.fire()", "{that}.removeAllInputs()", "flock.webAudio.nativeNodeManager.disconnectOutput({that})" ]
            }
        }), i.webAudio.nativeNodeManager.createInputNode = function(e, t, n) {
            var r = e.createNode(t);
            return e.insertInput(r, n);
        }, i.webAudio.nativeNodeManager.createOutputNode = function(e, t) {
            var n = e.createNode(t);
            return e.insertOutput(n);
        }, i.webAudio.nativeNodeManager.connectOutput = function(e, t) {
            e !== t && e.connect(t);
        }, i.webAudio.nativeNodeManager.disconnectOutput = function(e) {
            e.outputNode && e.outputNode.disconnect(0);
        }, i.webAudio.nativeNodeManager.removeAllInputs = function(e) {
            for (var t = 0; t < e.length; t++) e[t].disconnect(0);
            e.length = 0;
        }, i.webAudio.nativeNodeManager.insertInput = function(e, t, n, r, a) {
            var o = t.numInputBuses;
            {
                if (!(e.inputNodes.length >= o)) {
                    var u = (a = void 0 === a ? n.busManager.acquireNextBus("input") : a) - t.chans;
                    return e.inputNodes.push(r), r.connect(e.merger.node, 0, u), a;
                }
                i.fail("There are too many input nodes connected to Flocking. The maximum number of input buses is currently set to " + o + ". Either remove an existing input node or increase Flockings numInputBuses option.");
            }
        }, i.webAudio.nativeNodeManager.removeInput = function(e, t) {
            var n = t.indexOf(e);
            n > -1 && t.splice(n, 1), e.disconnect(0);
        }, i.webAudio.nativeNodeManager.insertOutput = function(e, t) {
            return i.webAudio.nativeNodeManager.disconnectOutput(e), e.outputNode = t, t;
        }, i.webAudio.nativeNodeManager.removeOutput = function(e) {
            i.webAudio.nativeNodeManager.insertOutput(e);
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        r.defaults("flock.webAudio.outputManager", {
            gradeNames: [ "flock.outputManager" ],
            model: {
                isGenerating: !1,
                shouldInitIOS: i.platform.isIOS,
                audioSettings: {}
            },
            invokers: {
                bindAudioProcess: {
                    funcName: "flock.webAudio.outputManager.bindAudioProcess",
                    args: [ "{enviro}.nodeList", "{busManager}.buses", "{nativeNodeManager}", "{that}.model" ]
                },
                unbindAudioProcess: {
                    funcName: "flock.webAudio.outputManager.unbindAudioProcess",
                    args: [ "{nativeNodeManager}" ]
                }
            },
            listeners: {
                "{nativeNodeManager}.events.onConnect": [ "{that}.bindAudioProcess()" ],
                "{nativeNodeManager}.events.onDisconnect": [ "{that}.unbindAudioProcess()" ],
                onStart: [ {
                    func: "{that}.applier.change",
                    args: [ "isGenerating", !0 ]
                }, {
                    priority: "last",
                    funcName: "flock.webAudio.outputManager.iOSStart",
                    args: [ "{that}", "{audioSystem}.context", "{nativeNodeManager}.scriptProcessor.node" ]
                } ],
                onStop: [ {
                    func: "{that}.applier.change",
                    args: [ "isGenerating", !1 ]
                } ],
                "onDestroy.unbindAudioProcess": "{that}.unbindAudioProcess()"
            }
        }), i.webAudio.outputManager.bindAudioProcess = function(e, t, n, r) {
            var a = n.scriptProcessor.node;
            a.model = r, a.nodeList = e, a.buses = t, a.inputNodes = n.inputNodes, a.onaudioprocess = i.webAudio.outputManager.writeSamples;
        }, i.webAudio.outputManager.unbindAudioProcess = function(e) {
            e.scriptProcessor.node.onaudioprocess = void 0;
        }, i.webAudio.outputManager.writeSamples = function(e) {
            var t, n, r, a = this.inputNodes ? this.inputNodes.length : 0, o = this.nodeList.nodes, u = this.model.audioSettings, s = e.inputBuffer, l = e.outputBuffer, c = u.numBlocks, d = this.buses, f = u.numBuses, p = u.blockSize, m = u.chans, g = s.numberOfChannels;
            if (o.length < 1) for (t = 0; t < m; t++) i.clearBuffer(l.getChannelData(t)); else for (n = 0; n < c; n++) {
                var h = n * p;
                if (i.evaluate.clearBuses(d, f, p), a > 0) for (t = 0; t < g; t++) {
                    var v = s.getChannelData(t), y = d[m + t];
                    for (r = 0; r < p; r++) y[r] = v[r + h];
                }
                for (i.evaluate.synths(o), t = 0; t < m; t++) {
                    var b = d[t], k = l.getChannelData(t);
                    for (r = 0; r < p; r++) k[r + h] = b[r];
                }
            }
        }, i.webAudio.outputManager.iOSStart = function(e, t, n) {
            if (e.model.shouldInitIOS) {
                var r = t.createBufferSource();
                r.connect(n), r.start(0), r.disconnect(0), e.applier.change("shouldInitIOS", !1);
            }
        };
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = r.registerNamespace("jQuery");
        i.ugenDefaults = function(e, t) {
            return 1 === arguments.length ? i.ugenDefaults.store[e] : (i.ugenDefaults.store[e] = t, 
            t);
        }, i.ugenDefaults.store = {}, i.isUGen = function(e) {
            return e && e.tags && e.tags.indexOf("flock.ugen") > -1;
        }, i.aliasUGen = function(t, n, r, a) {
            var o = i.get(t);
            i.set(o, n, function(t, n, r) {
                return r = e.extend(!0, {}, a, r), o(t, n, r);
            }), i.ugenDefaults(t + "." + n, r);
        }, i.aliasUGens = function(e, t) {
            var n, r;
            for (n in t) r = t[n], i.aliasUGen(e, n, {
                inputs: r.inputDefaults
            }, r.options);
        }, i.copyUGenDefinition = function(e, t) {
            var n = i.ugenDefaults(e), a = r.getGlobalValue(e);
            r.setGlobalValue(t, a), i.ugenDefaults(t, r.copy(n));
        }, i.krMul = function(e, t, n) {
            var r, a = n.output[0];
            for (r = 0; r < e; r++) t[r] = t[r] * a;
        }, i.mul = function(e, t, n) {
            var r, a = n.output;
            for (r = 0; r < e; r++) t[r] = t[r] * a[r];
        }, i.krAdd = function(e, t, n, r) {
            var a, o = r.output[0];
            for (a = 0; a < e; a++) t[a] = t[a] + o;
        }, i.add = function(e, t, n, r) {
            var a, o = r.output;
            for (a = 0; a < e; a++) t[a] = t[a] + o[a];
        }, i.krMulAdd = function(e, t, n, r) {
            var a, o = n.output[0], i = r.output;
            for (a = 0; a < e; a++) t[a] = t[a] * o + i[a];
        }, i.mulKrAdd = function(e, t, n, r) {
            var a, o = n.output, i = r.output[0];
            for (a = 0; a < e; a++) t[a] = t[a] * o[a] + i;
        }, i.krMulKrAdd = function(e, t, n, r) {
            var a, o = n.output[0], i = r.output[0];
            for (a = 0; a < e; a++) t[a] = t[a] * o + i;
        }, i.mulAdd = function(e, t, n, r) {
            var a, o = n.output, i = r.output;
            for (a = 0; a < e; a++) t[a] = t[a] * o[a] + i[a];
        }, i.onMulAddInputChanged = function(e) {
            var t, n = e.inputs.mul, r = e.inputs.add;
            n || r ? (t = n ? r ? n.rate !== i.rates.AUDIO ? r.rate !== i.rates.AUDIO ? i.krMulKrAdd : i.krMulAdd : r.rate !== i.rates.AUDIO ? i.mulKrAdd : i.mulAdd : n.rate !== i.rates.AUDIO ? i.krMul : i.mul : r.rate !== i.rates.AUDIO ? i.krAdd : i.add, 
            e.mulAddFn = t, e.mulAdd = function(t) {
                e.mulAddFn(t, e.output, e.inputs.mul, e.inputs.add);
            }) : e.mulAdd = e.mulAddFn = i.noOp;
        }, i.ugen = function(e, t, n) {
            var a = {
                enviro: (n = n || {}).enviro || i.environment,
                rate: n.rate || i.rates.AUDIO,
                inputs: e,
                output: t,
                options: n,
                model: n.model || {
                    unscaledValue: 0,
                    value: 0
                },
                multiInputs: {},
                tags: [ "flock.ugen" ]
            };
            return a.lastOutputIdx = a.output.length - 1, a.get = function(e) {
                return i.input.get(a.inputs, e);
            }, a.set = function(e, t) {
                return i.input.set(a.inputs, e, t, a, function(e) {
                    if (null !== e && void 0 !== e) return i.parse.ugenDef(e, a.enviro, {
                        audioSettings: a.options.audioSettings,
                        buses: a.buses,
                        buffers: a.buffers
                    });
                });
            }, a.input = function(e, t) {
                return e ? "string" == typeof e ? arguments.length < 2 ? a.get(e) : a.set(e, t) : i.isIterable(e) ? a.get(e) : a.set(e, t) : void 0;
            }, a.calculateStrides = function() {
                var e, t, n, o = a.model, u = a.options.strideInputs, s = a.inputs;
                if (o.strides = o.strides || {}, u) for (e = 0; e < u.length; e++) (n = s[t = u[e]]) ? o.strides[t] = n.rate === i.rates.AUDIO ? 1 : 0 : r.log(r.logLevel.WARN, "An invalid input ('" + t + "') was found on a unit generator: " + a);
            }, a.collectMultiInputs = function() {
                var e, t, n, r, o = a.options.multiInputNames, u = a.multiInputs;
                for (e = 0; e < o.length; e++) (n = u[t = o[e]]) ? n.length = 0 : n = u[t] = [], 
                r = a.inputs[t], i.ugen.collectMultiInputs(r, n);
            }, a.onInputChanged = function(e) {
                var t = a.options.multiInputNames;
                i.onMulAddInputChanged(a), a.options.strideInputs && a.calculateStrides(), !t || e && !t.indexOf(e) || a.collectMultiInputs();
            }, a.init = function() {
                var e, t, n, o = r.makeArray(a.options.tags), u = a.model, s = a.options;
                for (e = 0; e < o.length; e++) a.tags.push(o[e]);
                if (t = s.audioSettings = s.audioSettings || a.enviro.audioSystem.model, u.sampleRate = s.sampleRate || t.rates[a.rate], 
                u.nyquistRate = u.sampleRate, u.blockSize = a.rate === i.rates.AUDIO ? t.blockSize : 1, 
                u.sampleDur = 1 / u.sampleRate, a.interpolate = i.interpolate.none, s.interpolation) {
                    var l = i.interpolate[s.interpolation];
                    l ? a.interpolate = l : r.log(r.logLevel.IMPORTANT, "An invalid interpolation type of '" + s.interpolation + "' was specified. Defaulting to none.");
                }
                a.rate === i.rates.DEMAND && a.inputs.freq && (n = i.parse.ugenDefForConstantValue(1), 
                a.inputs.freq = i.parse.ugenDef(n, a.enviro));
            }, a.init(), a;
        }, i.ugen.collectMultiInputs = function(e, t) {
            i.isIterable(e) || (e = e = r.makeArray(e));
            for (var n = 0; n < e.length; n++) {
                var a = e[n];
                i.ugen.collectChannelsForInput(a, t);
            }
            return t;
        }, i.ugen.collectChannelsForInput = function(e, t) {
            var n, r = i.hasTag(e, "flock.ugen.multiChannelOutput") ? e.output : [ e.output ];
            for (n = 0; n < r.length; n++) t.push({
                rate: e.rate,
                output: r[n]
            });
            return t;
        }, i.ugen.lastOutputValue = function(e, t) {
            return t[e - 1];
        }, i.ugen.buffer = function(e) {
            e.onBufferInputChanged = function(t) {
                var n = e.model, r = e.inputs;
                n.bufDef === r.buffer && "buffer" !== t || (n.bufDef = r.buffer, i.parse.bufferForDef(n.bufDef, e, e.enviro));
            }, e.setBuffer = function(t) {
                e.buffer = t, e.onBufferReady && e.onBufferReady(t);
            }, e.initBuffer = function() {
                e.buffer = e.model.bufDef = i.bufferDesc({
                    format: {
                        sampleRate: e.options.audioSettings.rates.audio
                    },
                    data: {
                        channels: [ new Float32Array(e.output.length) ]
                    }
                });
            };
        }, i.ugen.value = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.value = function() {
                return r.model.value;
            }, r.dynamicGen = function(e) {
                for (var t = r.output, n = r.model, a = 0; a < e; a++) t[a] = n.unscaledValue;
                r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, t);
            }, r.onInputChanged = function() {
                var e = r.inputs;
                r.model.unscaledValue = e.value, "constant" !== r.rate ? r.gen = r.dynamicGen : r.gen = void 0, 
                i.onMulAddInputChanged(r), r.dynamicGen(1);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.value", {
            rate: "control",
            inputs: {
                value: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: 1,
                    value: 1
                },
                tags: [ "flock.ugen.valueType" ]
            }
        }), i.ugen.silence = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.onInputChanged = function() {
                for (var e = 0; e < r.output.length; e++) r.output[e] = 0;
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.silence", {
            rate: "constant"
        }), i.ugen.passThrough = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.inputs.source.output, u = r.output;
                for (t = 0; t < o.length; t++) u[t] = n = o[t];
                for (;t < e; t++) u[t] = n = 0;
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, u);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.passThrough", {
            rate: "audio",
            inputs: {
                source: null,
                mul: null,
                add: null
            }
        }), i.ugen.out = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c, d, f, p = r.model, m = r.multiInputs.sources, g = r.options.buses, h = r.inputs.bus.output[0], v = r.inputs.expand.output[0];
                if (t = m.length, n = Math.max(v, t), !(t < 1)) {
                    for (a = 0; a < n; a++) {
                        for (s = (u = m[a % t]).rate, l = g[h + a], c = s === i.rates.AUDIO ? 1 : 0, d = 0, 
                        o = 0; o < e; o++, d += c) f = u.output[d], l[o] = l[o] + f;
                        r.mulAddFn(e, l, r.inputs.mul, r.inputs.add);
                    }
                    p.value = p.unscaledValue = f;
                }
            }, r.init = function() {
                r.sourceBuffers = [], r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.out", {
            rate: "audio",
            inputs: {
                sources: null,
                bus: 0,
                expand: 2
            },
            ugenOptions: {
                tags: [ "flock.ugen.outputType" ],
                multiInputNames: [ "sources" ]
            }
        }), i.ugen.valueOut = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.arraySourceGen = function() {
                var e, t = r.model, n = r.inputs.sources;
                for (e = 0; e < n.length; e++) t.value[e] = n[e].output[0];
            }, r.ugenSourceGen = function() {
                r.model.value = r.model.unscaledValue = r.inputs.sources.output[0];
            }, r.onInputChanged = function() {
                var e = r.model, t = r.inputs.sources;
                i.isIterable(t) ? (r.gen = r.arraySourceGen, e.value = new Float32Array(t.length), 
                e.unscaledValue = e.value) : r.gen = r.ugenSourceGen;
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.valueOut", {
            rate: "control",
            inputs: {
                sources: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: null,
                    value: null
                },
                tags: [ "flock.ugen.outputType", "flock.ugen.valueType" ]
            }
        }), i.ugen.in = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.singleBusGen = function(e) {
                var t = r.model, n = r.output;
                i.ugen.in.readBus(e, n, r.inputs.bus, r.options.buses), t.unscaledValue = i.ugen.lastOutputValue(e, n), 
                r.mulAdd(e), t.value = i.ugen.lastOutputValue(e, n);
            }, r.multiBusGen = function(e) {
                var t, n, a, o = r.model, u = r.inputs.bus, s = r.options.buses, l = r.output;
                for (t = 0; t < e; t++) {
                    for (a = 0, n = 0; n < u.length; n++) a += s[0 | u[n].output[0]][t];
                    l[t] = a;
                }
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, l);
            }, r.onInputChanged = function() {
                r.gen = i.isIterable(r.inputs.bus) ? r.multiBusGen : r.singleBusGen, i.onMulAddInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugen.in.readBus = function(e, t, n, r) {
            var a, o = r[0 | n.output[0]];
            for (a = 0; a < e; a++) t[a] = o[a];
        }, i.ugenDefaults("flock.ugen.in", {
            rate: "audio",
            inputs: {
                bus: 0,
                mul: null,
                add: null
            }
        }), i.ugen.audioIn = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.output, u = r.bus;
                for (t = 0; t < e; t++) o[t] = n = u[t];
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, o);
            }, r.onInputChanged = function() {
                i.onMulAddInputChanged(r);
            }, r.init = function() {
                var e = r.enviro.audioSystem.inputDeviceManager.openAudioDevice(n);
                r.bus = r.options.buses[e], r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.audioIn", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.blit = function(e) {
            var t;
            return e >= 2 ? 0 : e >= 1 ? .16666666666666666 * (t = 2 - e) * t * t : e >= 0 ? .6666666666666666 - (t = e * e) + .5 * t * e : e >= -1 ? .6666666666666666 - (t = e * e) - .5 * t * e : e >= -2 ? .16666666666666666 * (t = 2 + e) * t * t : 0;
        }, i.blit.period = function(e, t) {
            var n = e / t;
            return n < 1 ? 1 : n;
        }, i.blit.updatePeriodState = function(e, t) {
            e.freq = t < 1e-6 ? 1e-6 : t, e.d0 = i.blit.period(e.sampleRate, e.freq);
        }, i.ugen.blit = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.output, u = r.inputs.freq.output[0], s = a.phase;
                for (t = 0; t < e; t++) (s -= 1) < -2 && (i.blit.updatePeriodState(a, u), s += a.d0), 
                n = i.blit(s), o[t] = n;
                a.phase = s, a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, o);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.blit", {
            rate: "audio",
            inputs: {
                freq: 440,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: -2,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.saw = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs.freq.output[0], u = 1 - r.inputs.leakRate.output[0], s = n.phase, l = n.unscaledValue;
                for (void 0 === s && (i.ugen.saw.updatePeriodState(n, o), s = n.d0 / 2), t = 0; t < e; t++) (s -= 1) < -2 && (i.ugen.saw.updatePeriodState(n, o), 
                s += n.d0), a[t] = l = i.blit(s) - n.dcOffset + u * l;
                n.phase = s, n.unscaledValue = l, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugen.saw.updatePeriodState = function(e, t) {
            i.blit.updatePeriodState(e, t), e.dcOffset = 1 / e.d0;
        }, i.ugenDefaults("flock.ugen.saw", {
            rate: "audio",
            inputs: {
                freq: 440,
                leakRate: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: void 0,
                    dcOffset: void 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.square = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs.freq.output[0], u = 1 - r.inputs.leakRate.output[0], s = n.phase, l = n.unscaledValue;
                for (void 0 === s && (i.ugen.square.updatePeriodState(n, o), s = n.phaseResetValue), 
                t = 0; t < e; t++) a[t] = l = i.blit(s) * n.sign + u * l, s < -2 && (i.ugen.square.updatePeriodState(n, o), 
                s += n.phaseResetValue), s -= 1;
                n.phase = s, n.unscaledValue = l, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugen.square.updatePeriodState = function(e, t) {
            i.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.sign *= -1;
        }, i.ugenDefaults("flock.ugen.square", {
            rate: "audio",
            inputs: {
                freq: 440,
                leakRate: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: void 0,
                    unscaledValue: .5,
                    value: .5,
                    sign: 1
                }
            }
        }), i.ugen.tri = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.output, s = r.inputs.freq.output[0], l = 1 - r.inputs.leakRate.output[0], c = o.phase, d = o.unscaledValue, f = o.secondPrevVal;
                for (void 0 === c && (i.ugen.tri.updatePeriodState(o, s), c = o.d0 / 4), t = 0; t < e; t++) d = n = i.blit(c) * o.sign + l * d, 
                f = a = n + l * f, u[t] = a * o.ampScale, (c -= 1) < -2 && (i.ugen.tri.updatePeriodState(o, s), 
                c += o.phaseResetValue);
                o.phase = c, o.unscaledValue = d, o.secondPrevVal = f, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, u);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugen.tri.updatePeriodState = function(e, t) {
            i.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.ampScale = 2 / e.d0, 
            e.sign *= -1;
        }, i.ugenDefaults("flock.ugen.tri", {
            rate: "audio",
            inputs: {
                freq: 440,
                leakRate: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: void 0,
                    value: .5,
                    unscaledValue: .5,
                    secondPrevVal: 0,
                    sign: 1,
                    ampScale: void 0,
                    phaseResetValue: void 0
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.playBuffer = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.defaultKrTriggerGen = function(t) {
                var n, a, o = r.model, u = r.output, s = r.inputs.channel.output[0], l = r.buffer.data.channels[s], c = o.idx, d = r.inputs.loop.output[0], f = e.trigger.output[0];
                for (f > 0 && o.prevTrig <= 0 && (c = 0), o.prevTrig = f, n = 0; n < t; n++) {
                    if (c > o.lastIdx) {
                        if (!(d > 0 && f > 0)) {
                            u[n] = a = 0;
                            continue;
                        }
                        c = 0;
                    }
                    a = r.interpolate(c, l), u[n] = a, c++;
                }
                o.idx = c, o.unscaledValue = a, r.mulAdd(t), o.value = i.ugen.lastOutputValue(t, u);
            }, r.otherwiseGen = function(t) {
                var n, a, o, u, s, l, c, d = r.model, f = r.output, p = r.inputs.channel.output[0], m = r.inputs.speed.output, g = r.buffer.data.channels[p], h = e.trigger.output, v = d.idx, y = r.inputs.loop.output[0], b = r.inputs.start.output[0] * d.lastIdx | 0, k = r.inputs.end.output[0] * d.lastIdx | 0;
                for (n = 0, a = 0, o = 0; n < t; n++, a += d.strides.trigger, o += d.strides.speed) {
                    if (u = h[a], s = d.prevTrig, l = m[o], d.prevTrig = u, u > 0 && s <= 0) v = i.ugen.playBuffer.resetIndex(l, b, k); else if (v < b || v > k) {
                        if (!(y > 0 && u > 0)) {
                            f[n] = c = 0;
                            continue;
                        }
                        v = i.ugen.playBuffer.resetIndex(l, b, k);
                    }
                    c = r.interpolate(v, g), f[n] = c, v += d.stepSize * l;
                }
                d.idx = v, d.unscaledValue = c, r.mulAdd(t), d.value = i.ugen.lastOutputValue(t, f);
            }, r.onInputChanged = function(e) {
                var t = r.inputs, n = t.speed, a = t.start, o = t.end, u = t.trigger;
                r.onBufferInputChanged(e), r.gen = n.rate === i.rates.CONSTANT && 1 === n.output[0] && a.rate === i.rates.CONSTANT && 0 === a.output[0] && o.rate === i.rates.CONSTANT && 1 === o.output[0] && u.rate !== i.rates.AUDIO ? r.defaultKrTriggerGen : r.otherwiseGen, 
                r.calculateStrides(), i.onMulAddInputChanged(r);
            }, r.onBufferReady = function() {
                var e = r.model, t = r.inputs.end.output[0], n = r.inputs.channel.output[0], a = r.buffer.data.channels[n].length;
                e.idx = t * a | 0, e.lastIdx = a - 1, e.stepSize = r.buffer.format.sampleRate / e.sampleRate;
            }, r.init = function() {
                i.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugen.playBuffer.resetIndex = function(e, t, n) {
            return e > 0 ? t : n;
        }, i.ugenDefaults("flock.ugen.playBuffer", {
            rate: "audio",
            inputs: {
                channel: 0,
                loop: 0,
                speed: 1,
                start: 0,
                end: 1,
                trigger: 1,
                buffer: null,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    finished: !1,
                    unscaledValue: 0,
                    value: 0,
                    idx: 0,
                    stepSize: 0,
                    prevTrig: 0,
                    channel: void 0
                },
                strideInputs: [ "trigger", "speed" ],
                interpolation: "linear"
            }
        }), i.ugen.readBuffer = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = u.strides.phase, l = r.output, c = r.inputs.channel.output[0], d = r.inputs.phase.output, f = r.buffer.data.channels[c], p = f.length;
                for (t = a = 0; t < e; t++, a += s) n = d[a] * p, o = r.interpolate(n, f), l[t] = o;
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, l);
            }, r.onInputChanged = function(e) {
                r.onBufferInputChanged(e), r.calculateStrides(), i.onMulAddInputChanged(r);
            }, r.init = function() {
                i.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.readBuffer", {
            rate: "audio",
            inputs: {
                buffer: null,
                channel: 0,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    channel: void 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "phase" ],
                interpolation: "linear"
            }
        }), i.ugen.writeBuffer = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, i = r.output, u = r.inputs, s = r.buffer, l = r.multiInputs.sources, c = l.length, d = s.data.channels, f = s.format.numSampleFrames, p = u.start.output[0], m = u.loop.output[0];
                for (o.prevStart !== p && (o.prevStart = p, o.writeIdx = Math.floor(p)), t = 0; t < c; t++) {
                    var g = l[t].output, h = d[t], v = i[t];
                    for (n = o.writeIdx, a = 0; a < e; a++) {
                        var y = g[a];
                        v && (v[a] = y), n < f ? h[n] = y : m > 0 && (h[n = Math.floor(p)] = y), n++;
                    }
                }
                o.writeIdx = n, r.mulAdd(e);
            }, r.createBuffer = function(e, t) {
                var n, r = e.options, a = r.audioSettings, o = r.buffers, u = e.multiInputs.sources.length, s = Math.round(e.options.duration * a.rates.audio), l = new Array(u);
                for (n = 0; n < u; n++) l[n] = new Float32Array(s);
                var c = i.bufferDesc(l, a.rates.audio, u);
                return t.id && (c.id = t.id, o[t.id] = c), c;
            }, r.setupBuffer = function(e) {
                var t;
                return (e = "string" == typeof e ? {
                    id: e
                } : e).id && (t = r.options.buffers[e.id]), r.buffer = t || r.createBuffer(r, e), 
                r.buffer;
            }, r.onInputChanged = function(e) {
                e ? "sources" === e ? r.collectMultiInputs() : "buffer" === e && r.setupBuffer(r.inputs.buffer) : (r.collectMultiInputs(), 
                r.setupBuffer(r.inputs.buffer)), i.onMulAddInputChanged(r);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.writeBuffer", {
            rate: "audio",
            inputs: {
                sources: null,
                buffer: null,
                start: 0,
                loop: 0
            },
            ugenOptions: {
                model: {
                    prevStart: void 0,
                    writeIdx: 0
                },
                tags: [ "flock.ugen.multiChannelOutput" ],
                numOutputs: 2,
                multiInputNames: [ "sources" ],
                duration: 600
            }
        }), i.ugen.bufferDuration = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.krGen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs.channel.output[0], u = r.buffer.data.channels[o], s = r.buffer.format.sampleRate, l = u.length / s;
                for (t = 0; t < e; t++) a[t] = l;
                n.unscaledValue = l, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.onInputChanged = function(e) {
                i.onMulAddInputChanged(r), r.onBufferInputChanged(e);
            }, r.onBufferReady = function() {
                r.krGen(1);
            }, r.init = function() {
                var e = r.rate;
                r.gen = e === i.rates.CONTROL || e === i.rates.AUDIO ? r.krGen : void 0, r.output[0] = 0, 
                i.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.bufferDuration", {
            rate: "constant",
            inputs: {
                buffer: null,
                channel: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.bufferLength = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.krGen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs.channel.output[0], u = r.buffer.data.channels[o].length;
                for (t = 0; t < e; t++) a[t] = u;
                n.unscaledValue = u, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.onInputChanged = function(e) {
                i.onMulAddInputChanged(r), r.onBufferInputChanged(e);
            }, r.onBufferReady = function() {
                r.krGen(1);
            }, r.init = function() {
                var e = r.rate;
                r.gen = e === i.rates.CONTROL || e === i.rates.AUDIO ? r.krGen : void 0, r.output[0] = 0, 
                i.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.bufferLength", {
            rate: "constant",
            inputs: {
                buffer: null,
                channel: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.bufferPhaseStep = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.krGen = function(e) {
                var t, n = r.model, a = r.output, o = n.unscaledValue;
                for (t = 0; t < e; t++) a[t] = o;
                r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.onInputChanged = function(e) {
                r.onBufferInputChanged(e), i.onMulAddInputChanged(r);
            }, r.onBufferReady = function(e) {
                var t = r.model, n = r.inputs.channel.output[0], a = e.data.channels[n], o = r.options.audioSettings.rates.audio, i = r.buffer.format.sampleRate || o;
                t.scale = i / o, r.output[0] = t.unscaledValue = 1 / (a.length * t.scale);
            }, r.init = function() {
                var e = r.rate;
                r.gen = e === i.rates.CONTROL || e === i.rates.AUDIO ? r.krGen : void 0, r.output[0] = 0, 
                i.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.bufferPhaseStep", {
            rate: "constant",
            inputs: {
                buffer: null,
                channel: 0
            },
            ugenOptions: {
                model: {
                    scale: 1,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.sampleRate = function(e, t, n) {
            var r = i.ugen(e, t, n), a = r.model;
            return r.output[0] = a.value = a.unscaledValue = r.options.audioSettings.rates.audio, 
            r;
        }, i.ugenDefaults("flock.ugen.sampleRate", {
            rate: "constant",
            inputs: {}
        }), i.ugen.triggerBuffers = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c, d, f, p = r.model, m = p.strides, g = r.output, h = r.inputs, v = r.buffers, y = v.length - 1, b = p.prevTrigger, k = p.maxVoices, S = p.activeVoices, x = p.freeVoices, C = h.trigger.output, A = m.trigger, w = 0, I = h.bufferIndex.output, N = m.bufferIndex, M = 0, P = h.speed.output, T = m.speed, O = 0, D = r.inputs.channel.output[0];
                for (t = 0; t < e; t++) {
                    if ((n = C[w]) > 0 && b <= 0 && S.length < k) {
                        if (o = Math.round(I[M] * y), o = Math.max(0, o), o = Math.min(o, y), !(u = v[o])) continue;
                        (a = x.pop()).speed = P[O], a.currentIdx = 0, a.writePos = t, a.buffer = u.data.channels[D], 
                        S.push(a);
                    }
                    w += A, O += T, M += N, g[t] = 0, b = n;
                }
                for (s = 0; s < S.length; ) {
                    for (l = (a = S[s]).buffer, c = Math.min(l.length - a.currentIdx, e), d = a.writePos; d < c; d++) f = r.interpolate ? r.interpolate(a.currentIdx, l) : l[0 | a.currentIdx], 
                    g[d] += f, a.currentIdx += a.speed;
                    a.currentIdx >= l.length ? (x.push(a), S.splice(s, 1)) : (a.writePos = 0, s++);
                }
                p.prevTrigger = b, p.unscaledValue = f, r.mulAdd(e), p.value = i.ugen.lastOutputValue(e, g);
            }, r.init = function() {
                r.buffers = [], r.allocateVoices(), r.onInputChanged();
            }, r.allocateVoices = function() {
                for (var e = 0; e < r.model.maxVoices; e++) r.model.freeVoices.push({});
            }, r.onInputChanged = function() {
                var e, t, n = r.enviro.buffers, a = r.options.bufferIDs;
                for (r.buffers.length = 0, e = 0; e < a.length; e++) t = n[a[e]], r.buffers.push(t);
                i.onMulAddInputChanged(r), r.calculateStrides();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.triggerBuffers", {
            inputs: {
                trigger: 0,
                bufferIndex: 0,
                speed: 1,
                channel: 0
            },
            ugenOptions: {
                model: {
                    prevTrigger: 0,
                    maxVoices: 128,
                    activeVoices: [],
                    freeVoices: [],
                    channel: 0
                },
                bufferIDs: [],
                strideInputs: [ "trigger", "bufferIndex", "speed" ]
            }
        }), i.ugen.chopBuffer = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return i.ugen.buffer(r), r.gen = function(e) {
                var t = r.model, n = r.output;
                i.ugen.chopBuffer.prepareVoices(r, e), i.ugen.chopBuffer.generateSamplesForAllVoices(r, e), 
                t.unscaledValue = i.ugen.lastOutputValue(e, n), r.mulAdd(e), t.value = i.ugen.lastOutputValue(e, n);
            }, r.onInputChanged = function(e) {
                r.onBufferInputChanged(e), r.calculateStrides(), i.onMulAddInputChanged(r);
            }, r.onBufferReady = function() {
                var e = r.model;
                e.stepSize = r.buffer.format.sampleRate / e.sampleRate, e.lastIdx = r.buffer.format.numSampleFrames - 1;
            }, r.init = function() {
                i.ugen.chopBuffer.initVoices(r), r.initBuffer(), r.onInputChanged();
                var e = r.buffer.data.channels[r.inputs.channel.output[0]];
                r.model.lastIdx = e.length - 1;
            }, r.init(), r;
        }, i.ugen.chopBuffer.initVoice = function() {
            return {
                currentStage: 4,
                samplesRemaining: 0,
                duration: 0,
                attackDur: 0,
                releaseDur: 0,
                hasTriggeredNextVoice: !1,
                idx: 0,
                stages: [ {
                    samplesRemaining: 0
                }, {
                    samplesRemaining: 0
                }, {
                    samplesRemaining: 0
                }, {
                    samplesRemaining: 0
                } ]
            };
        }, i.ugen.chopBuffer.initVoices = function(e) {
            for (var t = e.model, n = 0; n < e.options.maxVoices; n++) {
                var r = i.ugen.chopBuffer.initVoice(e);
                t.freeVoices[n] = r;
            }
        }, i.ugen.chopBuffer.randomIndex = i.randomValue, i.ugen.chopBuffer.randomStartIndex = function(e) {
            var t = e.model, n = e.inputs, r = n.end.output[0] - t.inputState.numDurationSamps;
            return r = Math.max(0, r), i.ugen.chopBuffer.randomIndex(n.start.output[0], r) * t.lastIdx;
        }, i.ugen.chopBuffer.allocateVoice = function(e) {
            var t = e.model, n = t.stageSampleState;
            if (!(t.freeVoices.length < 1)) {
                var r = t.freeVoices.pop();
                t.activeVoices.push(r);
                for (var a = 0; a < n.length; a++) r.stages[a].samplesRemaining = n[a];
                return r.hasTriggeredNextVoice = !1, r.currentStage = i.ugen.chopBuffer.stages.WAIT, 
                r.samplesRemaining = t.inputState.numDurationSamps + t.inputState.numGapSamps, r.idx = i.ugen.chopBuffer.randomStartIndex(e), 
                r;
            }
        }, i.ugen.chopBuffer.updateVoiceState = function(e, t) {
            for (var n = e.model, r = n.stageSampleState, a = n.inputState, o = t.currentStage; o < r.length; o++) {
                var i = t.stages[o], u = r[o];
                i.samplesRemaining > u && (i.samplesRemaining = u);
            }
            t.samplesRemaining > a.numDurationSamps && (t.samplesRemaining = a.numDurationSamps, 
            0 === t.currentStage && (t.samplesRemaining += a.numGapSamps));
        }, i.ugen.chopBuffer.triggerNextVoice = function(e, t, n, r, a) {
            var o = t.samplesRemaining + a;
            o < n && (e.model.stageSampleState[0] = o, i.ugen.chopBuffer.allocateVoice(e), t.hasTriggeredNextVoice = !0);
        }, i.ugen.chopBuffer.envLength = function(e, t, n) {
            return Math.floor((e > t ? t : e) * n);
        }, i.ugen.chopBuffer.deactivateVoice = function(e, t) {
            var n = e.model, r = n.activeVoices.indexOf(t);
            r > -1 && n.activeVoices.splice(r, 1), n.freeVoices.push(t);
        }, i.ugen.chopBuffer.prepareVoice = function(e, t, n) {
            i.ugen.chopBuffer.updateVoiceState(e, t), t.currentStage < i.ugen.chopBuffer.stages.DONE ? t.hasTriggeredNextVoice || i.ugen.chopBuffer.triggerNextVoice(e, t, n) : i.ugen.chopBuffer.deactivateVoice(e, t);
        }, i.ugen.chopBuffer.durationSamples = function(e, t, n) {
            return 0 === t ? n.lastIdx : Math.floor(e / t * n.sampleRate);
        }, i.ugen.chopBuffer.updateInputState = function(e, t) {
            var n = t.inputState, r = e.amount.output[0], a = e.minDuration.output[0], o = a / 2;
            return n.numDurationSamps = i.ugen.chopBuffer.durationSamples(a, r, t), n.numAttackSamps = i.ugen.chopBuffer.envLength(e.attack.output[0], o, t.sampleRate), 
            n.numReleaseSamps = i.ugen.chopBuffer.envLength(e.release.output[0], o, t.sampleRate), 
            n.numSustainSamps = n.numDurationSamps - n.numAttackSamps - n.numReleaseSamps, n.numGapSamps = Math.floor(e.gap.output[0] * t.sampleRate), 
            n;
        }, i.ugen.chopBuffer.prepareVoices = function(e, t) {
            var n = e.model;
            i.ugen.chopBuffer.updateInputState(e.inputs, n), n.stageSampleState[0] = n.inputState.numGapSamps, 
            n.stageSampleState[1] = n.inputState.numAttackSamps, n.stageSampleState[3] = n.inputState.numReleaseSamps, 
            n.stageSampleState[2] = n.inputState.numSustainSamps;
            for (var r = 0; r < n.activeVoices.length; r++) {
                var a = n.activeVoices[r];
                i.ugen.chopBuffer.prepareVoice(e, a, t);
            }
            0 === n.activeVoices.length && i.ugen.chopBuffer.allocateVoice(e);
        }, i.ugen.chopBuffer.generateSamplesForVoice = function(e, t, n) {
            for (var r = e.model, a = e.output, o = e.inputs, u = o.speed.output, s = e.buffer.data.channels[o.channel.output[0]], l = 0, c = 0; l < Math.min(n, t.samplesRemaining) && !(t.currentStage >= i.ugen.chopBuffer.stages.DONE); l++, 
            c += r.strides.speed) {
                var d = r.stepSize * u[c], f = t.stages[t.currentStage];
                a[l] += e.interpolate(t.idx, s), t.samplesRemaining -= d, f.samplesRemaining -= d, 
                t.idx += d, f.samplesRemaining <= 0 && t.currentStage++;
            }
            t.samplesRemaining <= 0 && t.currentStage < i.ugen.chopBuffer.stages.DONE && (t.currentStage = i.ugen.chopBuffer.stages.DONE);
        }, i.ugen.chopBuffer.generateSamplesForAllVoices = function(e, t) {
            var n = e.model;
            i.clearBuffer(e.output);
            for (var r = n.activeVoices.length - 1; r >= 0; r--) {
                var a = n.activeVoices[r];
                i.ugen.chopBuffer.generateSamplesForVoice(e, a, t);
            }
        }, i.ugen.chopBuffer.stages = {
            WAIT: 0,
            ATTACK: 1,
            SUSTAIN: 2,
            RELEASE: 3,
            DONE: 4
        }, i.ugenDefaults("flock.ugen.chopBuffer", {
            rate: "audio",
            inputs: {
                buffer: null,
                channel: 0,
                start: 0,
                end: 1,
                speed: 1,
                amount: 1,
                minDuration: .1,
                attack: .01,
                release: .01,
                gap: 0
            },
            ugenOptions: {
                model: {
                    stepSize: 1,
                    activeVoices: [],
                    freeVoices: [],
                    stageSampleState: [ 0, 0, 0, 0 ],
                    lastIdx: 0,
                    inputState: {
                        numAttackSamps: 0,
                        numSustainSamps: 0,
                        numReleaseSamps: 0,
                        numDurationSamps: 0,
                        numGapSamps: 0
                    }
                },
                interpolation: "linear",
                envelopeType: "linear",
                maxVoices: 2,
                strideInputs: [ "speed" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.print = function(e, t, n) {
            var a = i.ugen(e, t, n);
            return a.gen = function(e) {
                var t, n, o, i = a.inputs, u = a.output, s = a.model, l = s.label, c = i.channel, d = c ? i.source.output[c.output[0]] : i.source.output, f = i.trigger.output[0], p = i.freq.output[0];
                for (f > 0 && s.prevTrig <= 0 && r.log(r.logLevel.IMPORTANT, l + d), s.freq !== p && (s.sampInterval = Math.round(s.sampleRate / p), 
                s.freq = p, s.counter = s.sampInterval), t = 0, n = 0; t < e; t++, n += s.strides.source) s.counter >= s.sampInterval && (r.log(r.logLevel.IMPORTANT, l + d[n]), 
                s.counter = 0), s.counter++, u[t] = o = d[t];
                s.value = s.unscaledValue = o;
            }, a.init = function() {
                var e = a.options;
                a.model.label = e.label ? e.label + ": " : "", a.onInputChanged();
            }, a.init(), a;
        }, i.ugenDefaults("flock.ugen.print", {
            rate: "audio",
            inputs: {
                source: null,
                trigger: 0,
                freq: 1
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    counter: 0
                },
                strideInputs: [ "source" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.distortion = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s = r.model, l = r.output, c = r.inputs.source.output, d = s.strides.source, f = r.inputs.gain.output, p = s.strides.gain;
                for (a = o = u = 0; a < e; a++, o += d, u += p) n = 1.5 * (t = c[o] * f[u]) - .5 * t * t * t, 
                l[a] = n;
                s.unscaledValue = n, r.mulAdd(e), s.value = i.ugen.lastOutputValue(e, l);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.distortion", {
            rate: "audio",
            inputs: {
                source: null,
                gain: 1
            },
            ugenOptions: {
                strideInputs: [ "source", "gain" ]
            }
        }), i.ugen.distortion.tanh = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.output, s = r.inputs.source.output, l = o.strides.source;
                for (n = a = 0; n < e; n++, a += l) t = Math.tanh(s[a]), u[n] = t;
                o.unscaledValue = t, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, u);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.distortion.tanh", {
            rate: "audio",
            inputs: {
                source: null
            },
            ugenOptions: {
                strideInputs: [ "source" ]
            }
        }), i.ugen.distortion.deJong = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c = r.model, d = r.output, f = r.inputs.source.output, p = c.strides.source, m = r.inputs.amount.output, g = c.strides.amount;
                for (u = s = l = 0; u < e; u++, s += p, l += g) t = f[s], n = m[l], o = t * ((a = Math.abs(t)) + n) / (t * t + (n - 1) * a + 1), 
                d[u] = o;
                c.unscaledValue = o, r.mulAdd(e), c.value = i.ugen.lastOutputValue(e, d);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.distortion.deJong", {
            rate: "audio",
            inputs: {
                source: null,
                amount: 2
            },
            ugenOptions: {
                strideInputs: [ "source", "amount" ]
            }
        }), i.copyUGenDefinition("flock.ugen.distortion.deJong", "flock.ugen.distortion.deJonge"), 
        i.ugen.distortion.tarrabiaDeJong = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c = r.model, d = r.output, f = r.inputs.source.output, p = c.strides.source, m = r.inputs.amount.output, g = c.strides.amount;
                for (o = u = s = 0; o < e; o++, u += p, s += g) t = f[u], (n = m[s]) >= 1 ? n = .9999999999999999 : n < -1 && (n = -1), 
                a = (1 + (l = 2 * n / (1 - n))) * t / (1 + l * Math.abs(t)), d[o] = a;
                c.unscaledValue = a, r.mulAdd(e), c.value = i.ugen.lastOutputValue(e, d);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.distortion.tarrabiaDeJong", {
            rate: "audio",
            inputs: {
                source: null,
                amount: 1
            },
            ugenOptions: {
                strideInputs: [ "source", "amount" ]
            }
        }), i.copyUGenDefinition("flock.ugen.distortion.tarrabiaDeJong", "flock.ugen.distortion.tarrabiaDeJonge"), 
        i.ugen.distortion.gloubiBoulga = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c = r.model, d = r.output, f = r.inputs.source.output, p = c.strides.source, m = r.inputs.gain.output, g = c.strides.gain;
                for (n = a = o = 0; n < e; n++, a += p, o += g) u = .686306 * (f[a] * m[o]), s = 1 + Math.exp(-.75 * Math.sqrt(Math.abs(u))), 
                t = ((l = Math.exp(u)) - Math.exp(-u * s)) / (l + Math.exp(-u)), d[n] = t;
                c.unscaledValue = t, r.mulAdd(e), c.value = i.ugen.lastOutputValue(e, d);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.distortion.gloubiBoulga", {
            rate: "audio",
            inputs: {
                source: null,
                gain: 1
            },
            ugenOptions: {
                strideInputs: [ "source", "gain" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.normalize = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function() {
                var e = r.model, t = r.output, n = r.inputs.max.output[0], a = r.inputs.source.output;
                i.normalize(a, n, t), e.value = e.unscaledValue = t[t.length - 1];
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.normalize", {
            rate: "audio",
            inputs: {
                max: 1,
                source: null
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = r.registerNamespace("jQuery"), t = i.requireModule("webarraymath", "ArrayMath");
        i.envelope = {}, i.envelope.makeCreator = function(t, n) {
            return function(r) {
                var a = i.ugenDefaults(t), o = e.extend(!0, {}, a, r);
                return n(o);
            };
        }, i.envelope.registerCreators = function(e, t) {
            var n, a;
            for (var o in t) n = r.pathUtil.composePath(e, o), a = t[o], i.ugenDefaults(n, a.defaults), 
            r.setGlobalValue(n, i.envelope.makeCreator(n, a.transformer));
        }, i.envelope.creatorSpecs = {
            line: {
                transformer: function(e) {
                    return {
                        levels: [ e.start, e.end ],
                        times: [ e.duration ]
                    };
                },
                defaults: {
                    start: 0,
                    end: 1,
                    duration: 1
                }
            },
            linear: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.level, e.level, 0 ],
                        times: [ e.attack, e.sustain, e.release ]
                    };
                },
                defaults: {
                    level: 1,
                    attack: .01,
                    sustain: 1,
                    release: 1
                }
            },
            tri: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.level, 0 ],
                        times: [ e.duration, e.duration ]
                    };
                },
                defaults: {
                    level: 1,
                    duration: 1
                }
            },
            sin: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.level, 0 ],
                        times: [ e.duration, e.duration ],
                        curve: "sin"
                    };
                },
                defaults: {
                    level: 1,
                    duration: 1
                }
            },
            asr: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.sustain, 0 ],
                        times: [ e.attack, e.release ],
                        sustainPoint: 1,
                        curve: -4
                    };
                },
                defaults: {
                    sustain: 1,
                    attack: .01,
                    release: 1
                }
            },
            dadsr: {
                transformer: function(e) {
                    var n = [ 0, 0, e.peak, e.peak * e.sustain, 0 ];
                    return t.add(n, e.bias, n), {
                        levels: n,
                        times: [ e.delay, e.attack, e.decay, e.release ],
                        sustainPoint: 3,
                        curve: -4
                    };
                },
                defaults: {
                    delay: .1,
                    attack: .01,
                    decay: .3,
                    sustain: .5,
                    release: 1,
                    peak: 1,
                    bias: 0
                }
            },
            adsr: {
                transformer: function(e) {
                    var n = [ 0, e.peak, e.peak * e.sustain, 0 ];
                    return t.add(n, e.bias, n), {
                        levels: n,
                        times: [ e.attack, e.decay, e.release ],
                        sustainPoint: 2,
                        curve: -4
                    };
                },
                defaults: {
                    attack: .01,
                    decay: .3,
                    sustain: .5,
                    release: 1,
                    peak: 1,
                    bias: 0
                }
            }
        }, i.envelope.registerCreators("flock.envelope", i.envelope.creatorSpecs), i.envelope.validate = function(e, t) {
            var n = e.levels, r = {};
            if (e.times ? !n || n.length < 2 ? r.levels = "An array containing at least two levels must be specified." : (i.envelope.validate.times(e.times, n, r), 
            i.envelope.validate.levels(n, r), i.envelope.validate.curves(e.curve, n, r), i.envelope.validate.sustainPoint(e.sustainPoint, n, r)) : r.times = "An array containing at least one time value must be specified.", 
            !1 !== t) for (var a in r) i.fail(r[a]);
            return r;
        }, i.envelope.validate.times = function(e, t, n) {
            e.length !== t.length - 1 && (n.times = "The envelope specification should provide one fewer time value than the number of level values. times: " + e + " levels: " + t);
            for (var r = 0; r < e.length; r++) {
                var a = e[r];
                isNaN(a) && (n.times = "A NaN time value was specified at index " + r + ". times: " + e), 
                a < 0 && (n.times = "All times should be positive values. times: " + e);
            }
        }, i.envelope.validate.levels = function(e, t) {
            for (var n = 0; n < e.length; n++) isNaN(e[n]) && (t.levels = "A NaN level value was specified at index " + n + ". levels: " + e);
        }, i.envelope.validate.curves = function(e, t, n) {
            if (!e) return n;
            i.isIterable(e) && (e.length !== t.length - 1 && (n.curve = "When curve is specified as an array, there should be one fewer curve value than the number of level values. curve: " + e + " levels: " + t), 
            r.each(e, function(t) {
                i.lineGenerator(t) || (n.curve = "'" + t + "' is not a valid curve type. curve: " + e);
            })), i.lineGenerator(e) || (n.curve = "'" + e + "' is not a valid curve type.");
        }, i.envelope.validate.sustainPoint = function(e, t, n) {
            (e < 0 || e >= t.length) && (n.sustainPoint = "The specified sustainPoint index is out range for the levels array. sustainPoint: " + e + " levels: " + t);
        }, i.envelope.expand = function(e) {
            var t = "string" == typeof e ? r.invokeGlobalFunction(e) : e.type ? r.invokeGlobalFunction(e.type, [ e ]) : e;
            if (t.curves && !t.curve && (t.curve = t.curves), !i.isIterable(t.curve)) {
                var n = t.levels.length - 1;
                t.curve = i.fillBufferWithValue(new Array(n), t.curve);
            }
            return i.envelope.validate(t, !0), t;
        }, i.fillBufferWithLine = function(e, t, n, r, a, o) {
            a = void 0 === a ? 0 : a;
            var u = (o = void 0 === o ? t.length : o) - a, s = i.fillBufferWithLine.singletonModel;
            s.unscaledValue = n, s.destination = r, s.numSegmentSamps = u - 1, "number" == typeof e && (s.currentCurve = e, 
            e = "curve");
            var l = i.line[e];
            return l || i.fail("No line generator could be found for type " + e), l.init(s), 
            l.gen(u, a, t, s);
        }, i.fillBufferWithLine.singletonModel = {
            unscaledValue: 0,
            value: 0,
            destination: 1
        }, i.lineGenerator = function(e) {
            var t = typeof e;
            return "string" === t ? i.line[e] : "number" === t ? i.line.curve : i.line.linear;
        }, i.line = {
            constant: {
                init: function(e) {
                    e.stepSize = 0;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = t; o < e + t; o++) n[o] = a;
                    return n;
                }
            },
            step: {
                init: function(e) {
                    e.arrived = !1;
                },
                gen: function(e, t, n, r) {
                    for (var a = t; a < e + t; a++) n[a] = r.unscaledValue, r.arrived || (r.arrived = !0, 
                    r.unscaledValue = r.destination);
                    return n;
                }
            },
            linear: {
                init: function(e) {
                    e.stepSize = (e.destination - e.unscaledValue) / e.numSegmentSamps;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.stepSize, i = t; i < e + t; i++) n[i] = a, a += o;
                    return r.unscaledValue = a, n;
                }
            },
            exponential: {
                init: function(e) {
                    0 === e.unscaledValue && (e.unscaledValue = 1e-16), e.stepSize = 0 === e.numSegmentSamps ? 0 : Math.pow(e.destination / e.unscaledValue, 1 / e.numSegmentSamps);
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.stepSize, i = t; i < e + t; i++) n[i] = a, a *= o;
                    return r.unscaledValue = a, r.stepSize = o, n;
                }
            },
            curve: {
                init: function(e) {
                    if (Math.abs(e.currentCurve) < .001) return i.line.linear.init(e);
                    var t = (e.destination - e.unscaledValue) / (1 - Math.exp(e.currentCurve));
                    e.a2 = e.unscaledValue + t, e.b1 = t, e.stepSize = Math.exp(e.currentCurve / e.numSegmentSamps);
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.b1, i = t; i < e + t; i++) n[i] = a, o *= r.stepSize, 
                    a = r.a2 - o;
                    return r.unscaledValue = a, r.b1 = o, n;
                }
            },
            sin: {
                init: function(e) {
                    var t = Math.PI / e.numSegmentSamps;
                    e.a2 = .5 * (e.destination + e.unscaledValue), e.b1 = 2 * Math.cos(t), e.y1 = .5 * (e.destination - e.unscaledValue), 
                    e.y2 = e.y1 * Math.sin(i.HALFPI - t), e.unscaledValue = e.a2 - e.y1;
                },
                gen: function(e, t, n, r) {
                    for (var a, o = r.unscaledValue, i = r.y1, u = r.y2, s = t; s < e + t; s++) n[s] = o, 
                    a = r.b1 * i - u, o = r.a2 - a, u = i, i = a;
                    return r.unscaledValue = o, r.y1 = i, r.y2 = u, n;
                }
            },
            welsh: {
                init: function(e) {
                    var t = i.HALFPI / e.numSegmentSamps, n = Math.cos(t);
                    e.b1 = 2 * n, e.destination >= e.unscaledValue ? (e.a2 = e.unscaledValue, e.y1 = 0, 
                    e.y2 = -Math.sin(t) * (e.destination - e.unscaledValue)) : (e.a2 = e.destination, 
                    e.y1 = e.unscaledValue - e.destination, e.y2 = n * (e.unscaledValue - e.destination)), 
                    e.unscaledValue = e.a2 + e.y1;
                },
                gen: function(e, t, n, r) {
                    for (var a, o = r.unscaledValue, i = r.y1, u = r.y2, s = t; s < e + t; s++) n[s] = o, 
                    a = r.b1 * i - u, u = i, i = a, o = r.a2 + a;
                    return r.unscaledValue = o, r.y1 = i, r.y2 = u, n;
                }
            },
            squared: {
                init: function(e) {
                    e.y1 = Math.sqrt(e.unscaledValue), e.y2 = Math.sqrt(e.destination), e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.y1, i = t; i < e + t; i++) n[i] = a, a = (o += r.stepSize) * o;
                    return r.y1 = o, r.unscaledValue = a, n;
                }
            },
            cubed: {
                init: function(e) {
                    e.y1 = Math.pow(e.unscaledValue, .3333333333333333), e.y2 = Math.pow(e.destination, .3333333333333333), 
                    e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.y1, i = t; i < e + t; i++) n[i] = a, a = (o += r.stepSize) * o * o;
                    return r.y1 = o, r.unscaledValue = a, n;
                }
            }
        }, i.ugen.line = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n = r.model, a = n.stepSize, o = n.numSteps, u = o >= e ? e : o, s = e - u, l = n.level, c = r.output;
                for (t = 0; t < u; t++) c[t] = l, o--, l += a;
                if (s > 0) for (t = 0; t < s; t++) c[t] = l;
                n.level = n.unscaledValue = l, n.numSteps = o, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, c);
            }, r.onInputChanged = function() {
                var e = r.model;
                e.start = r.inputs.start.output[0], e.end = r.inputs.end.output[0], e.numSteps = Math.round(r.inputs.duration.output[0] * e.sampleRate), 
                0 === e.numSteps ? (e.stepSize = 0, e.level = e.end) : (e.stepSize = (e.end - e.start) / e.numSteps, 
                e.level = e.start), i.onMulAddInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.line", {
            rate: "control",
            inputs: {
                start: 0,
                end: 1,
                duration: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    start: 0,
                    end: 1,
                    numSteps: 0,
                    stepSize: 0,
                    level: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.xLine = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n = r.model, a = n.multiplier, o = n.numSteps, u = o >= e ? e : o, s = e - u, l = n.level, c = r.output;
                for (t = 0; t < u; t++) c[t] = l, o--, l *= a;
                if (s > 0) for (t = 0; t < s; t++) c[t] = l;
                n.level = n.unscaledValue = l, n.numSteps = o, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, c);
            }, r.onInputChanged = function() {
                var e = r.model;
                i.onMulAddInputChanged(r), e.start = r.inputs.start.output[0], 0 === e.start && (e.start = 1e-101), 
                e.end = r.inputs.end.output[0], e.numSteps = Math.round(r.inputs.duration.output[0] * e.sampleRate), 
                e.multiplier = Math.pow(e.end / e.start, 1 / e.numSteps), e.level = e.start;
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.xLine", {
            rate: "control",
            inputs: {
                start: 0,
                end: 1,
                duration: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    start: 0,
                    end: 1,
                    numSteps: 0,
                    multiplier: 0,
                    level: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.asr = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.output, u = a.previousGate, s = r.inputs.gate.output[0], l = a.level, c = a.stage, d = c.currentStep, f = c.stepInc, p = c.numSteps, m = a.targetLevel, g = !1;
                for (u <= 0 && s > 0 ? (m = r.inputs.sustain.output[0], t = r.inputs.attack.output[0], 
                g = !0) : u >= 0 && s <= 0 && d >= p && (m = r.inputs.start.output[0], t = r.inputs.release.output[0], 
                g = !0), g && (f = (p = Math.round(t * a.sampleRate)) > 0 ? (m - l) / p : 0, d = 0, 
                p < 1 && (l = m)), n = 0; n < e; n++) o[n] = l, l = ++d < p ? l + f : d === p ? m : l;
                a.level = a.unscaledValue = l, a.targetLevel = m, a.previousGate = s, c.currentStep = d, 
                c.stepInc = f, c.numSteps = p, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, o);
            }, r.init = function() {
                var e = r.model;
                e.level = e.unscaledValue = r.inputs.start.output[0], e.targetLevel = r.inputs.sustain.output[0], 
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.asr", {
            rate: "control",
            inputs: {
                start: 0,
                attack: .01,
                sustain: 1,
                release: 1,
                gate: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    level: 0,
                    targetLevel: 0,
                    previousGate: 0,
                    unscaledValue: 0,
                    value: 0,
                    stage: {
                        currentStep: 0,
                        stepInc: 0,
                        numSteps: 0
                    }
                }
            }
        }), i.copyUGenDefinition("flock.ugen.asr", "flock.ugen.env.simpleASR"), i.ugen.envGen = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.krGen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs, u = o.gate.output[0], s = o.timeScale.output[0], l = 0;
                for (i.ugen.envGen.checkGate(r, u, s); l < e; ) t = Math.min(e - l, n.numSegmentSamps), 
                r.lineGen.gen(t, l, a, n), l += t, n.numSegmentSamps -= t, n.numSegmentSamps <= 0 && i.ugen.envGen.nextStage(r, s);
                r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.arGen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs, u = o.gate.output, s = o.timeScale.output[0];
                for (t = 0; t < e; t++) i.ugen.envGen.checkGate(r, u[t], s), r.lineGen.gen(1, t, a, n), 
                n.numSegmentSamps--, n.numSegmentSamps <= 0 && i.ugen.envGen.nextStage(r, s);
                r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.onInputChanged = function(e) {
                e && "envelope" !== e || (r.envelope = i.ugen.envGen.initEnvelope(r, r.inputs.envelope)), 
                e && "gate" !== e || (r.gen = r.inputs.gate.rate === i.rates.AUDIO ? r.arGen : r.krGen), 
                i.onMulAddInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugen.envGen.initEnvelope = function(e, t) {
            var n = e.model, r = i.envelope.expand(t);
            return n.stage = 0, n.numStages = r.times.length, e.lineGen = i.line.constant, i.ugen.envGen.lineGenForStage(e.inputs.timeScale.output[0], r, n), 
            n.unscaledValue = r.levels[n.stage], r;
        }, i.ugen.envGen.checkGate = function(e, t, n) {
            var r = e.model, a = e.envelope;
            t !== r.previousGate && (t > 0 && r.previousGate <= 0 ? (r.stage = 1, e.lineGen = i.ugen.envGen.lineGenForStage(n, a, r)) : t <= 0 && r.previousGate > 0 && (r.stage = r.numStages, 
            e.lineGen = i.ugen.envGen.lineGenForStage(n, a, r))), r.previousGate = t;
        }, i.ugen.envGen.nextStage = function(e, t) {
            var n = e.model, r = e.envelope;
            n.stage === r.sustainPoint ? (e.lineGen = i.line.constant, n.numSegmentSamps = 1 / 0, 
            n.destination = n.unscaledValue) : (n.stage++, e.lineGen = i.ugen.envGen.lineGenForStage(t, r, n));
        }, i.ugen.envGen.setupStage = function(e, t, n) {
            var r, a, o = t.levels[n.stage];
            0 === n.stage || n.stage > n.numStages ? a = 1 / 0 : (r = t.times[n.stage - 1] * e, 
            a = Math.max(1, Math.round(r * n.sampleRate))), n.numSegmentSamps = a, n.destination = o;
        }, i.ugen.envGen.lineGenForStage = function(e, t, n) {
            var r, a, o = t.curve;
            return 0 === n.stage || n.stage > n.numStages ? r = i.line.constant : (a = o[n.stage - 1], 
            n.currentCurve = a, r = i.lineGenerator(a)), i.ugen.envGen.setupStage(e, t, n), 
            r.init(n), r;
        }, i.ugenDefaults("flock.ugen.envGen", {
            rate: "audio",
            inputs: {
                envelope: "flock.envelope.adsr",
                gate: 0,
                timeScale: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    previousGate: 0,
                    stepSize: 0,
                    destination: 0,
                    numSegmentSamps: 1,
                    unscaledValue: 0,
                    value: 0,
                    stage: 0,
                    numStages: 0
                }
            }
        }), i.ugen.phasor = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.inputs, s = r.output, l = u.step.output, c = u.trigger.output;
                for (void 0 === o.unscaledValue && (o.unscaledValue = u.start.output[0]), t = 0, 
                n = 0, a = 0; t < e; t++, n += o.strides.trigger, a += o.strides.step) c[n] > 0 && o.prevTrig <= 0 && (o.unscaledValue = u.reset.output[0]), 
                o.prevTrig = c[n], o.unscaledValue >= u.end.output[0] && (o.unscaledValue = u.start.output[0]), 
                s[t] = o.unscaledValue, o.unscaledValue += l[a];
                r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.phasor", {
            rate: "control",
            inputs: {
                start: 0,
                end: 1,
                reset: 0,
                step: .1,
                trigger: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: void 0,
                    value: 0
                },
                strideInputs: [ "trigger", "step" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = i.requireModule("webarraymath", "Filter");
        i.ugen.lag = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.output, l = r.inputs, c = l.time.output[0], d = l.source.output, f = u.prevSamp, p = u.lagCoef;
                for (c !== u.prevTime && (u.prevtime = c, p = u.lagCoef = 0 === c ? 0 : Math.exp(i.LOG001 / (c * u.sampleRate))), 
                t = n = 0; t < e; t++, n += u.strides.source) o = (a = d[n]) + p * (f - a), s[t] = f = o;
                u.prevSamp = f, r.mulAdd(e);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.lag", {
            rate: "audio",
            inputs: {
                source: null,
                time: .1
            },
            ugenOptions: {
                strideInputs: [ "source" ],
                model: {
                    prevSamp: 0,
                    lagCoef: 0,
                    prevTime: 0
                }
            }
        }), i.ugen.filter = function(t, n, r) {
            var a = i.ugen(t, n, r);
            return a.gen = function() {
                var e = a.model, t = a.output, n = a.inputs, r = n.q.output[0], o = n.freq.output[0];
                e.prevFreq === o && e.prevQ === r || a.updateCoefficients(e, o, r), a.filterEngine.filter(t, a.inputs.source.output), 
                e.prevQ = r, e.prevFreq = o, e.value = e.unscaledValue = t[t.length - 1];
            }, a.init = function() {
                var t = a.options.recipe, n = "string" == typeof t ? i.get(t) : t;
                if (!n) throw new Error("Can't instantiate a flock.ugen.filter() without specifying a filter coefficient recipe.");
                a.filterEngine = new e(n.sizes.b, n.sizes.a), a.model.coeffs = {
                    a: a.filterEngine.a,
                    b: a.filterEngine.b
                }, a.updateCoefficients = i.get(n, a.options.type), a.onInputChanged();
            }, a.init(), a;
        }, i.ugenDefaults("flock.ugen.filter", {
            rate: "audio",
            inputs: {
                freq: 440,
                q: 1,
                source: null
            }
        }), i.ugen.filter.biquad = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.inputs, u = r.output, s = a.coeffs, l = o.freq.output[0], c = o.q.output[0], d = o.source.output;
                for (a.prevFreq === l && a.prevQ === c || r.updateCoefficients(a, l, c), t = 0; t < e; t++) n = d[t] - s.a[0] * a.d0 - s.a[1] * a.d1, 
                u[t] = s.b[0] * n + s.b[1] * a.d0 + s.b[2] * a.d1, a.d1 = a.d0, a.d0 = n;
                a.prevQ = c, a.prevFreq = l, a.value = a.unscaledValue = i.ugen.lastOutputValue(e, u);
            }, r.onInputChanged = function() {
                var e = r.options.type;
                r.updateCoefficients = "string" == typeof e ? i.get(e) : e;
            }, r.init = function() {
                r.model.d0 = 0, r.model.d1 = 0, r.model.coeffs = {
                    a: new Float32Array(2),
                    b: new Float32Array(3)
                }, r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.filter.biquad", {
            inputs: {
                freq: 440,
                q: 1,
                source: null
            }
        }), i.ugen.filter.biquad.types = {
            hp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.butterworth.highPass"
                }
            },
            rhp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.rbj.highPass"
                }
            },
            lp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.butterworth.lowPass"
                }
            },
            rlp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.rbj.lowPass"
                }
            },
            bp: {
                inputDefaults: {
                    freq: 440,
                    q: 4
                },
                options: {
                    type: "flock.coefficients.butterworth.bandPass"
                }
            },
            br: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.butterworth.bandReject"
                }
            }
        }, i.aliasUGens("flock.ugen.filter.biquad", i.ugen.filter.biquad.types), i.coefficients = {
            butterworth: {
                sizes: {
                    a: 2,
                    b: 3
                },
                lowPass: function(e, t) {
                    var n = e.coeffs, r = 1 / Math.tan(Math.PI * t / e.sampleRate), a = r * r, o = i.ROOT2 * r, u = 1 / (1 + o + a);
                    n.b[0] = u, n.b[1] = 2 * u, n.b[2] = u, n.a[0] = 2 * (1 - a) * u, n.a[1] = (1 - o + a) * u;
                },
                highPass: function(e, t) {
                    var n = e.coeffs, r = Math.tan(Math.PI * t / e.sampleRate);
                    r === 1 / 0 && (r = 0);
                    var a = r * r, o = i.ROOT2 * r, u = 1 / (1 + o + a);
                    n.b[0] = u, n.b[1] = -2 * u, n.b[2] = u, n.a[0] = 2 * (a - 1) * u, n.a[1] = (1 - o + a) * u;
                },
                bandPass: function(e, t, n) {
                    var r = e.coeffs, a = t / n, o = 1 / Math.tan(Math.PI * a / e.sampleRate), u = 2 * Math.cos(i.TWOPI * t / e.sampleRate), s = 1 / (1 + o);
                    r.b[0] = s, r.b[1] = 0, r.b[2] = -s, r.a[0] = -o * u * s, r.a[1] = s * (o - 1);
                },
                bandReject: function(e, t, n) {
                    var r = e.coeffs, a = t / n, o = Math.tan(Math.PI * a / e.sampleRate), u = 1 / (1 + o), s = -(2 * Math.cos(i.TWOPI * t / e.sampleRate)) * u;
                    r.b[0] = u, r.b[1] = s, r.b[2] = u, r.a[0] = s, r.a[1] = (1 - o) * u;
                }
            },
            rbj: {
                sizes: {
                    a: 2,
                    b: 3
                },
                lowPass: function(e, t, n) {
                    var r = e.coeffs, a = i.TWOPI * t / e.sampleRate, o = Math.cos(a), u = Math.sin(a) / (2 * n), s = 1 - o, l = 1 + u, c = s / 2 / l;
                    r.b[0] = c, r.b[1] = s / l, r.b[2] = c, r.a[0] = -2 * o / l, r.a[1] = (1 - u) / l;
                },
                highPass: function(e, t, n) {
                    var r = e.coeffs, a = i.TWOPI * t / e.sampleRate, o = Math.cos(a), u = Math.sin(a) / (2 * n), s = 1 + o, l = 1 + u, c = s / 2 / l;
                    r.b[0] = c, r.b[1] = -s / l, r.b[2] = c, r.a[0] = -2 * o / l, r.a[1] = (1 - u) / l;
                },
                bandPass: function(e, t, n) {
                    var r = e.coeffs, a = i.TWOPI * t / e.sampleRate, o = Math.cos(a), u = Math.sin(a) / (2 * n), s = 1 + u, l = n * u;
                    r.b[0] = l / s, r.b[1] = 0, r.b[2] = -l / s, r.a[0] = -2 * o / s, r.a[1] = (1 - u) / s;
                },
                bandReject: function(e, t, n) {
                    var r = e.coeffs, a = i.TWOPI * t / e.sampleRate, o = Math.cos(a), u = Math.sin(a) / (2 * n), s = 1 + u, l = 1 / s, c = -2 * o / s;
                    r.b[0] = l, r.b[1] = c, r.b[2] = l, r.a[0] = c, r.a[1] = (1 - u) / s;
                }
            }
        }, i.ugen.filter.moog = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c = r.model, d = r.inputs, f = r.output, p = d.source.output, m = c.strides.source, g = d.resonance.output, h = c.strides.resonance, v = d.cutoff.output, y = c.strides.cutoff, b = c.f, k = c.fSq, S = c.fSqSq, x = c.oneMinusF, C = c.fb;
                for (t = n = a = o = 0; t < e; t++, n += m, a += h, o += y) u = v[o], s = g[a], 
                u !== c.prevCutoff && (u > c.nyquistRate && (u = c.nyquistRate), b = c.f = u / c.nyquistRate * 1.16, 
                k = c.fSq = b * b, S = c.fSqSq = k * k, x = c.oneMinusF = 1 - b, c.prevRes = void 0), 
                s !== c.prevRes && (s > 4 ? s = 4 : s < 0 && (s = 0), C = c.fb = s * (1 - .15 * k)), 
                l = p[n] - c.out4 * C, l *= .35013 * S, c.out1 = l + .3 * c.in1 + x * c.out1, c.in1 = l, 
                c.out2 = c.out1 + .3 * c.in2 + x * c.out2, c.in2 = c.out1, c.out3 = c.out2 + .3 * c.in3 + x * c.out3, 
                c.in3 = c.out2, c.out4 = c.out3 + .3 * c.in4 + x * c.out4, c.in4 = c.out3, f[t] = c.out4;
                c.unscaledValue = c.out4, r.mulAdd(e), c.value = i.ugen.lastOutputValue(e, f);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.filter.moog", {
            rate: "audio",
            inputs: {
                cutoff: 3e3,
                resonance: 3.99,
                source: null
            },
            ugenOptions: {
                model: {
                    in1: 0,
                    in2: 0,
                    in3: 0,
                    in4: 0,
                    out1: 0,
                    out2: 0,
                    out3: 0,
                    out4: 0,
                    prevCutoff: void 0,
                    prevResonance: void 0,
                    f: void 0,
                    fSq: void 0,
                    fSqSq: void 0,
                    oneMinusF: void 0,
                    fb: void 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "source", "cutoff", "resonance" ]
            }
        }), i.ugen.delay = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.inputs, u = r.output, s = o.source.output, l = o.time.output[0], c = r.delayBuffer;
                for (l !== a.time && (a.time = l, a.delaySamps = l * r.model.sampleRate), t = 0; t < e; t++) a.pos >= a.delaySamps && (a.pos = 0), 
                u[t] = n = c[a.pos], c[a.pos] = s[t], a.pos++;
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, u);
            }, r.onInputChanged = function(e) {
                if (i.onMulAddInputChanged(r), !e || "maxTime" === e) {
                    var t = r.model.sampleRate * r.inputs.maxTime.output[0];
                    r.delayBuffer = new Float32Array(t);
                }
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.delay", {
            rate: "audio",
            inputs: {
                maxTime: 1,
                time: 1,
                source: null
            },
            ugenOptions: {
                model: {
                    pos: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.delay1 = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.inputs, u = r.output, s = o.source.output, l = a.prevVal;
                for (t = 0; t < e; t++) u[t] = n = l, l = s[t];
                a.prevVal = l, a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, u);
            }, r.onInputChanged = function() {
                i.onMulAddInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.delay1", {
            rate: "audio",
            inputs: {
                source: null
            },
            ugenOptions: {
                model: {
                    prevVal: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.freeverb = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.tunings = r.options.tunings, r.allpassTunings = r.options.allpassTunings, 
            r.gen = function(e) {
                var t, n, a, o = r.model, u = r.inputs, s = r.output, l = u.source.output, c = u.mix.output[0], d = 1 - c, f = .28 * u.room.output[0] + .7, p = .4 * u.damp.output[0], m = 1 - p;
                for (t = 0; t < e; t++) {
                    var g = l[t], h = .015 * g;
                    for (n = 0; n < r.buffers_a.length; n++) ++r.bufferindices_a[n] === r.allpassTunings[n] && (r.bufferindices_a[n] = 0), 
                    r.readsamp_a[n] = r.buffers_a[n][r.bufferindices_a[n]];
                    for (n = 0; n < r.buffers_c.length; n++) {
                        ++r.bufferindices_c[n] === r.tunings[n] && (r.bufferindices_c[n] = 0);
                        var v = r.bufferindices_c[n], y = r.buffers_c[n][v];
                        r.filterx_c[n] = m * r.filtery_c[n] + p * r.filterx_c[n], r.buffers_c[n][v] = h + f * r.filterx_c[n], 
                        r.filtery_c[n] = y;
                    }
                    var b = r.filtery_c[6] + r.filtery_c[7];
                    r.buffers_a[3][r.bufferindices_a[3]] = .5 * r.filterx_a[3] + r.filtery_c[0] + (r.filtery_c[1] + r.filtery_c[2]) + (r.filtery_c[3] + r.filtery_c[4] + (r.filtery_c[5] + b)), 
                    r.filterx_a[3] = r.readsamp_a[3], r.filtery_a[3] = r.filterx_a[3] - (r.filtery_c[0] + r.filtery_c[1] + (r.filtery_c[2] + r.filtery_c[3]) + (r.filtery_c[4] + r.filtery_c[5] + b)), 
                    r.buffers_a[2][r.bufferindices_a[2]] = .5 * r.filterx_a[2] + r.filtery_a[3], r.filterx_a[2] = r.readsamp_a[2], 
                    r.filtery_a[2] = r.filterx_a[2] - r.filtery_a[3], r.buffers_a[1][r.bufferindices_a[1]] = .5 * r.filterx_a[1] + r.filtery_a[2], 
                    r.filterx_a[1] = r.readsamp_a[1], r.filtery_a[1] = r.filterx_a[1] - r.filtery_a[2], 
                    r.buffers_a[0][r.bufferindices_a[0]] = .5 * r.filterx_a[0] + r.filtery_a[1], r.filterx_a[0] = r.readsamp_a[0], 
                    r.filtery_a[0] = r.filterx_a[0] - r.filtery_a[1], a = d * g + c * r.filtery_a[0], 
                    s[t] = a;
                }
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r.initDelayLines = function() {
                r.buffers_c = new Array(8), r.bufferindices_c = new Int32Array(8), r.filterx_c = new Float32Array(8), 
                r.filtery_c = new Float32Array(8);
                var e, t, n = r.model.spread;
                for (e = 0; e < r.buffers_c.length; e++) for (r.buffers_c[e] = new Float32Array(r.tunings[e] + n), 
                r.bufferindices_c[e] = 0, r.filterx_c[e] = 0, r.filtery_c[e] = 0, t = 0; t < r.tunings[e] + n; t++) r.buffers_c[e][t] = 0;
                for (r.buffers_a = new Array(4), r.bufferindices_a = new Int32Array(4), r.filterx_a = new Float32Array(4), 
                r.filtery_a = new Float32Array(4), r.readsamp_a = new Float32Array(4), e = 0; e < r.buffers_a.length; e++) {
                    for (r.bufferindices_a[e] = 0, r.filterx_a[e] = 0, r.filtery_a[e] = 0, r.readsamp_a[e] = 0, 
                    t = 0; t < r.allpassTunings.length; t++) r.allpassTunings[t] += n;
                    for (r.buffers_a[e] = new Float32Array(r.allpassTunings[e]), t = 0; t < r.allpassTunings[e]; t++) r.buffers_a[e][t] = 0;
                }
            }, r.init = function() {
                r.initDelayLines(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.freeverb", {
            rate: "audio",
            inputs: {
                source: null,
                mix: .33,
                room: .5,
                damp: .5
            },
            ugenOptions: {
                model: {
                    spread: 0,
                    unscaledValue: 0,
                    value: 0
                },
                tunings: [ 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 ],
                allpassTunings: [ 556, 441, 341, 225 ]
            }
        }), i.ugen.decay = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.inputs, u = r.output, s = o.source.output, l = o.time.output[0];
                if (l !== a.time && (a.time = l, a.coeff = 0 === l ? 0 : Math.exp(i.LOG001 / (l * r.model.sampleRate))), 
                0 === a.coeff) for (t = 0; t < e; t++) u[t] = n = s[t]; else for (t = 0; t < e; t++) a.lastSamp = s[t] + a.coeff * a.lastSamp, 
                u[t] = n = a.lastSamp;
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, u);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.decay", {
            rate: "audio",
            inputs: {
                source: null,
                time: 1
            },
            ugenOptions: {
                model: {
                    time: 0,
                    lastSamp: 0,
                    coeff: 0,
                    value: 0
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.gate = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = u.strides, l = r.output, c = r.inputs, d = c.source.output, f = c.sideChain.output, p = s.sideChain, m = c.threshold.output, g = s.threshold, h = r.options.holdLastValue, v = u.lastValue;
                for (t = n = a = 0; t < e; t++, n += p, a += g) f[n] >= m[a] ? l[t] = o = v = d[t] : l[t] = o = h ? v : 0;
                u.lastValue = v, u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, l);
            }, r.onInputChanged = function() {
                r.inputs.sideChain || (r.inputs.sideChain = r.inputs.source), i.onMulAddInputChanged(r), 
                r.calculateStrides();
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.gate", {
            rate: "audio",
            inputs: {
                source: null,
                sideChain: null,
                threshold: Number.MIN_VALUE,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    lastValue: 0
                },
                holdLastValue: !1,
                strideInputs: [ "sideChain", "threshold" ]
            }
        }), i.ugen.timedGate = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.output, l = r.inputs.trigger.output, c = r.inputs.duration.output[0];
                for (c !== u.duration && (u.duration = c, u.durationSamps = Math.floor(c * u.sampleRate)), 
                n = a = 0; n < e; n++, a += u.strides.trigger) (t = l[a]) > 0 && u.prevTrigger <= 0 ? (o = r.options.resetOnTrigger && u.sampsRemaining > 0 ? 0 : 1, 
                u.sampsRemaining = u.durationSamps) : o = u.sampsRemaining > 0 ? 1 : 0, s[n] = o, 
                u.sampsRemaining--, u.prevTrigger = t;
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, s);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.timedGate", {
            rate: "audio",
            inputs: {
                trigger: 0,
                duration: 1
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    prevTrigger: 0,
                    sampsRemaining: 0,
                    durationSamps: 0,
                    duration: 0
                },
                resetOnTrigger: !0,
                strideInputs: [ "trigger" ]
            }
        }), i.ugen.latch = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.arGen = function(e) {
                var t, n, a, o, u = r.model, s = r.inputs, l = s.source.output, c = s.trigger, d = u.strides.source, f = r.output;
                for (void 0 === u.holdVal && (u.holdVal = l[0]), t = 0, n = 0; t < e; t++, n += d) (a = c.output[t]) > 0 && u.prevTrig <= 0 && (u.holdVal = l[n]), 
                o = u.holdVal, f[t] = o, u.prevTrig = a;
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, f);
            }, r.krGen = function(e) {
                var t, n = r.model, a = r.output, o = r.inputs.trigger.output[0];
                for ((void 0 === n.holdVal || o > 0 && n.prevTrig <= 0) && (n.holdVal = r.inputs.source.output[0]), 
                n.prevTrig = o, t = 0; t < e; t++) a[t] = n.holdVal;
                n.unscaledValue = n.holdVal, r.mulAdd(e), n.value = i.ugen.lastOutputValue(e, a);
            }, r.onInputChanged = function() {
                r.calculateStrides(), r.gen = r.inputs.trigger.rate === i.rates.AUDIO ? r.arGen : r.krGen, 
                i.onMulAddInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.latch", {
            rate: "audio",
            inputs: {
                source: null,
                trigger: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "source" ],
                model: {
                    prevTrig: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.triggerGrains = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c = r.model, d = r.inputs, f = r.output, p = d.channel.output[0], m = r.buffer.data.channels[p], g = r.buffer.format.sampleRate, h = d.dur.output[0], v = d.amp.output, y = d.centerPos.output, b = d.trigger.output, k = d.speed.output, S = r.options.grainEnv, x = e - 1, C = 0, A = 0, w = 0, I = 0;
                for (t = 0; t < e; t++) {
                    if (b[A] > 0 && c.prevTrigger <= 0 && c.activeGrains.length < c.maxNumGrains) {
                        for ((o = c.freeGrains.pop()).numSamps = c.sampleRate * h, o.centerIdx = o.numSamps / 2 * c.stepSize, 
                        o.envScale = r.options.grainEnv.length / o.numSamps, o.sampIdx = 0, o.amp = v[w], 
                        u = y[C] * g - o.centerIdx; u < 0; ) u += m.length;
                        o.readPos = u, o.writePos = t, o.speed = k[I], c.activeGrains.push(o);
                    }
                    c.prevTrigger = b[A], f[t] = 0, C += c.strides.centerPos, A += c.strides.trigger, 
                    w += c.strides.amp, I += c.strides.speed;
                }
                for (n = 0; n < c.activeGrains.length; ) {
                    for (a = (o = c.activeGrains[n]).writePos; a < Math.min(a + (o.numSamps - o.sampIdx), e); a++) s = r.interpolate(o.readPos, m), 
                    l = i.interpolate.linear(o.sampIdx * o.envScale, S), f[a] += s * l * o.amp, o.readPos = (o.readPos + c.stepSize * o.speed) % m.length, 
                    o.sampIdx++;
                    o.sampIdx >= o.numSamps ? (c.freeGrains.push(o), c.activeGrains.splice(n, 1)) : (n++, 
                    o.writePos = a % e);
                }
                c.unscaledValue = f[x], r.mulAdd(e), c.value = f[x];
            }, r.onBufferReady = function() {
                var e = r.model;
                e.stepSize = r.buffer.format.sampleRate / e.sampleRate;
            }, r.onInputChanged = function(e) {
                r.onBufferInputChanged(e), r.calculateStrides(), i.onMulAddInputChanged(r);
            }, r.allocateGrains = function(e) {
                e = e || r.model.maxNumGrains;
                for (var t = 0; t < e; t++) r.model.freeGrains.push({
                    numSamps: 0,
                    centerIdx: 0,
                    envScale: 0,
                    sampIdx: 0,
                    amp: 0,
                    readPos: 0,
                    writePos: 0,
                    speed: 0
                });
            }, r.init = function() {
                i.ugen.buffer(r), r.allocateGrains(), r.initBuffer(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.triggerGrains", {
            rate: "audio",
            inputs: {
                centerPos: 0,
                channel: 0,
                amp: 1,
                dur: .1,
                speed: 1,
                trigger: 0,
                buffer: null,
                mul: null,
                add: null
            },
            ugenOptions: {
                grainEnv: i.fillTable(8192, i.tableGenerators.hann),
                model: {
                    unscaledValue: 0,
                    value: 0,
                    maxNumGrains: 512,
                    activeGrains: [],
                    freeGrains: [],
                    env: null,
                    strides: {}
                },
                strideInputs: [ "centerPos", "trigger", "amp", "speed" ],
                interpolation: "cubic"
            }
        }), i.ugen.granulator = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s, l, c = r.model, d = r.options, f = r.inputs, p = r.output, m = r.delayLine, g = f.grainDur.output[0], h = f.delayDur.output[0], v = f.numGrains.output[0], y = f.source.output, b = d.maxDelayDur, k = d.grainEnv;
                for (c.delayDur !== h && (c.delayDur = h, h > b && (h = b), c.delayLength = h * c.sampleRate | 0, 
                c.writePos = c.writePos % c.delayLength), c.grainDur !== g && (c.grainDur = g, c.grainLength = c.sampleRate * c.grainDur | 0, 
                c.envScale = k.length / c.grainLength), v = v > d.maxNumGrains ? d.maxNumGrains : Math.round(v), 
                t = 0; t < e; t++) {
                    for (m[c.writePos] = y[t], c.writePos = ++c.writePos % c.delayLength, a = 0, n = 0; n < v; n++) o = c.grainIdx[n], 
                    u = c.delayLineIdx[n], o > c.grainLength && (o = 0, u = Math.random() * c.delayLength | 0), 
                    s = m[u], l = o * c.envScale, a += s * i.interpolate.linear(l, k), c.delayLineIdx[n] = ++u % c.delayLength, 
                    c.grainIdx[n] = ++o;
                    a /= v, p[t] = a;
                }
                c.unscaledValue = a, r.mulAdd(e), c.value = i.ugen.lastOutputValue(e, p);
            }, r.initGrains = function() {
                for (var e = r.model, t = 0; t < r.options.maxNumGrains; t++) e.grainIdx[t] = 0, 
                e.delayLineIdx[t] = Math.random() * e.delayLength;
            }, r.init = function() {
                var e = r.model, t = r.options, n = t.maxDelayDur * e.sampleRate | 0;
                r.delayLine = new Float32Array(n), e.delayLength = n, e.delayLineIdx = new Uint32Array(t.maxNumGrains), 
                e.grainIdx = new Uint32Array(t.maxNumGrains), r.initGrains(), r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.granulator", {
            rate: "audio",
            inputs: {
                source: null,
                grainDur: .1,
                delayDur: 1,
                numGrains: 5,
                mul: null,
                add: null
            },
            ugenOptions: {
                maxNumGrains: 512,
                maxDelayDur: 30,
                grainEnv: i.fillTable(8192, i.tableGenerators.sinWindow),
                model: {
                    unscaledValue: 0,
                    value: 0,
                    grainLength: 0,
                    writePos: 0
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.amplitude = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.inputs.source.output, s = r.output, l = o.attackTime, c = r.inputs.attack.output[0], d = o.releaseTime, f = r.inputs.release.output[0], p = o.prevVal, m = o.attackCoef, g = o.releaseCoef;
                for (c !== l && (o.attackTime = c, m = o.attackCoef = 0 === c ? 0 : Math.exp(i.LOG01 / (c * o.sampleRate))), 
                f !== d && (o.releaseTime = f, g = o.releaseCoef = 0 === f ? 0 : Math.exp(i.LOG01 / (f * o.sampleRate))), 
                t = 0; t < e; t++) a = (n = Math.abs(u[t])) < p ? g : m, s[t] = p = n + (p - n) * a;
                o.unscaledValue = o.prevVal = p, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.amplitude", {
            rate: "audio",
            inputs: {
                source: null,
                attack: .01,
                release: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    prevVal: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = i.requireModule("webarraymath", "ArrayMath");
        i.ugen.math = function(t, n, r) {
            var a = i.ugen(t, n, r);
            return a.expandedRight = new Float32Array(a.options.audioSettings.blockSize), a.krSourceKrInputGen = function() {
                var t = a.model, n = a.activeInput, r = a.inputs[n], o = a.output, u = a.inputs.source.output[0], s = i.fillBufferWithValue(a.expandedRight, r.output[0]);
                e[n](o, u, s), t.value = t.unscaledValue = o[o.length - 1];
            }, a.krSourceArInputGen = function() {
                var t = a.model, n = a.activeInput, r = a.inputs[n], o = a.output, i = a.inputs.source.output[0], u = r.output;
                e[n](o, i, u), t.value = t.unscaledValue = o[o.length - 1];
            }, a.arSourceKrInputGen = function() {
                var t = a.model, n = a.activeInput, r = a.inputs[n], o = a.output, u = a.inputs.source.output, s = i.fillBufferWithValue(a.expandedRight, r.output[0]);
                e[n](o, u, s), t.value = t.unscaledValue = o[o.length - 1];
            }, a.arSourceArInputGen = function() {
                var t = a.model, n = a.activeInput, r = a.inputs[n], o = a.output, i = a.inputs.source.output, u = r.output;
                e[n](o, i, u), t.value = t.unscaledValue = o[o.length - 1];
            }, a.onInputChanged = function() {
                var e, t, n, r = Object.keys(a.inputs);
                for (e = 0; e < r.length; e++) if ("source" !== (t = r[e])) {
                    a.activeInput = t, n = "audio" === a.inputs[t].rate, a.gen = "audio" === a.inputs.source.rate ? n ? a.arSourceArInputGen : a.arSourceKrInputGen : n ? a.krSourceArInputGen : a.krSourceKrInputGen;
                    break;
                }
            }, a.init = function() {
                if (void 0 === e) throw new Error("ArrayMath is undefined. Please include webarraymath.js to use the flock.math unit generator.");
                a.onInputChanged();
            }, a.init(), a;
        }, i.ugenDefaults("flock.ugen.math", {
            rate: "audio",
            inputs: {
                source: null
            }
        }), i.ugen.sum = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.copyGen = function(e) {
                var t, n, a = r.model, o = r.output, u = r.inputs.sources.output;
                for (t = 0; t < e; t++) n = u[t], o[t] = n;
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, o);
            }, r.sumGen = function(e) {
                var t, n, a, o = r.model, u = r.inputs.sources, s = r.output;
                for (i.clearBuffer(s), n = 0; n < u.length; n++) for (a = u[n].output, t = 0; t < e; t++) s[t] += a[t];
                o.unscaledValue = i.ugen.lastOutputValue(e, s), r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged = function() {
                "number" == typeof r.inputs.sources.length ? r.gen = r.sumGen : r.gen = r.copyGen, 
                i.onMulAddInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.sum", {
            rate: "audio",
            inputs: {
                sources: null
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.midiFreq = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = o.a4, s = u.freq, l = u.noteNum, c = o.notesPerOctave, d = r.inputs.note.output, f = r.output;
                for (t = 0, n = 0; t < e; t++, n += o.strides.note) f[t] = a = i.midiFreq(d[n], s, l, c);
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, f);
            }, r.init = function() {
                r.model.octaveScale = 1 / r.model.notesPerOctave, r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.midiFreq", {
            rate: "control",
            inputs: {
                note: 69
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    a4: {
                        noteNum: 69,
                        freq: 440
                    },
                    notesPerOctave: 12
                },
                strideInputs: [ "note" ]
            }
        }), i.ugen.midiAmp = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.inputs.velocity.output, s = r.output;
                for (t = 0, n = 0; t < e; t++, n += o.strides.velocity) s[t] = a = u[n] / 127;
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.midiAmp", {
            rate: "control",
            inputs: {
                velocity: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "velocity" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.pan2 = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.output, l = s[0], c = s[1], d = r.inputs, f = d.source.output, p = d.pan.output;
                for (t = 0, n = 0; t < e; t++, n += u.strides.pan) a = f[t], o = .5 * p[n] + .5, 
                c[t] = a * Math.sin(o * i.HALFPI), l[t] = a * Math.cos(o * i.HALFPI);
                var m = e - 1;
                u.value[0] = s[0][m], u.value[1] = s[1][m];
            }, r.init = function() {
                r.onInputChanged(), r.model.unscaledValue = r.model.value;
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.pan2", {
            rate: "audio",
            inputs: {
                source: null,
                pan: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: [ 0, 0 ],
                    value: [ 0, 0 ]
                },
                tags: [ "flock.ugen.multiChannelOutput" ],
                strideInputs: [ "pan" ],
                numOutputs: 2
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.osc = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s = r.model, l = r.inputs, c = l.freq.output, d = l.phase.output, f = l.table, p = s.tableLen, m = s.tableIncHz, g = s.tableIncRad, h = r.output, v = s.phase;
                for (t = 0, n = 0, a = 0; t < e; t++, n += s.strides.phase, a += s.strides.freq) (o = v + d[n] * g) >= p ? o -= p : o < 0 && (o += p), 
                h[t] = u = r.interpolate(o, f), (v += c[a] * m) >= p ? v -= p : v < 0 && (v += p);
                s.phase = v, s.unscaledValue = u, r.mulAdd(e), s.value = i.ugen.lastOutputValue(e, h);
            }, r.onInputChanged = function(e) {
                if (i.ugen.osc.onInputChanged(r), !e || "table" === e) {
                    var t = r.model, n = r.inputs.table;
                    n.length < 1 && (n = r.inputs.table = i.ugen.osc.emptyTable), t.tableLen = n.length, 
                    t.tableIncHz = t.tableLen / t.sampleRate, t.tableIncRad = t.tableLen / i.TWOPI;
                }
            }, r.onInputChanged(), r;
        }, i.ugen.osc.emptyTable = new Float32Array([ 0, 0, 0 ]), i.ugen.osc.onInputChanged = function(e) {
            e.calculateStrides(), i.onMulAddInputChanged(e);
        }, i.ugenDefaults("flock.ugen.osc", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                table: [],
                mul: null,
                add: null
            },
            ugenOptions: {
                interpolation: "linear",
                model: {
                    phase: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq", "phase" ]
            },
            tableSize: 8192
        }), i.ugen.osc.define = function(e, t) {
            var n = e.lastIndexOf("."), a = e.substring(0, n), o = e.substring(n + 1);
            i.get(a)[o] = function(e, n, a) {
                var o = i.ugenDefaults("flock.ugen.osc"), u = r.merge(null, o, a).tableSize;
                return e.table = i.fillTable(u, t), i.ugen.osc(e, n, a);
            }, i.ugenDefaults(e, i.ugenDefaults("flock.ugen.osc"));
        }, i.ugen.osc.define("flock.ugen.sinOsc", i.tableGenerators.sin), i.ugen.osc.define("flock.ugen.triOsc", i.tableGenerators.tri), 
        i.ugen.osc.define("flock.ugen.sawOsc", i.tableGenerators.saw), i.ugen.osc.define("flock.ugen.squareOsc", i.tableGenerators.square), 
        i.ugen.sin = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.inputs.freq.output, l = r.inputs.phase.output, c = r.output, d = u.phase, f = u.sampleRate;
                for (t = 0, n = 0, a = 0; t < e; t++, n += u.strides.phase, a += u.strides.freq) c[t] = o = Math.sin(d + l[n]), 
                d += s[a] / f * i.TWOPI;
                u.phase = d, u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, c);
            }, r.onInputChanged = function() {
                i.ugen.osc.onInputChanged(r);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.sin", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq", "phase" ]
            }
        }), i.ugen.lfSaw = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.inputs.freq.output, s = r.output, l = o.scale, c = r.inputs.phase.output[0], d = o.phase;
                for (t = 0, n = 0; t < e; t++, n += o.strides.freq) s[t] = a = d + c, (d += u[n] * l) >= 1 ? d -= 2 : d <= -1 && (d += 2);
                o.phase = d, o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged = function() {
                var e = r.model;
                e.freqInc = r.inputs.freq.rate === i.rates.AUDIO ? 1 : 0, e.phase = 0, r.calculateStrides(), 
                i.onMulAddInputChanged(r);
            }, r.init = function() {
                r.model.scale = 1 / r.options.sampleRate * 2, r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.lfSaw", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    freqInc: 1,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq" ]
            }
        }), i.ugen.lfPulse = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.inputs, u = r.model, s = o.freq.output, l = u.freqInc, c = o.width.output[0], d = r.output, f = u.scale, p = void 0 !== u.phase ? u.phase : o.phase.output[0];
                for (t = 0, n = 0; t < e; t++, n += l) p >= 1 ? (p -= 1, d[t] = a = c < .5 ? 1 : -1) : d[t] = a = p < c ? 1 : -1, 
                p += s[n] * f;
                u.phase = p, u.unscaledValue = a, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, d);
            }, r.onInputChanged = function() {
                r.model.freqInc = r.inputs.freq.rate === i.rates.AUDIO ? 1 : 0, i.onMulAddInputChanged(r);
            }, r.init = function() {
                r.model.scale = 1 / r.options.sampleRate, r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.lfPulse", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                width: .5,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    freqInc: 1,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.impulse = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.inputs, u = r.model, s = r.output, l = o.freq.output, c = u.strides.freq, d = o.phase.output[0], f = u.phase, p = u.scale;
                for (f += d, t = 0, n = 0; t < e; t++, n += c) f >= 1 ? (f -= 1, a = 1) : a = 0, 
                s[t] = a, f += l[n] * p;
                u.phase = f - d, u.unscaledValue = a, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged = function() {
                r.calculateStrides(), i.onMulAddInputChanged(r);
            }, r.init = function() {
                r.model.scale = 1 / r.model.sampleRate, r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.impulse", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    scale: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = i.requireModule("Random");
        i.ugen.dust = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(t) {
                var n, a, o, u, s, l = r.model, c = r.output, d = e.density.output[0];
                for (d !== l.density ? (l.density = d, n = l.threshold = d * l.sampleDur, a = l.scale = n > 0 ? 1 / n : 0) : (n = l.threshold, 
                a = l.scale), s = 0; s < t; s++) u = (o = Math.random()) < n ? o * a : 0, c[s] = u;
                l.unscaledValue = u, r.mulAdd(t), l.value = i.ugen.lastOutputValue(t, c);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.dust", {
            rate: "audio",
            inputs: {
                density: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    density: 0,
                    scale: 0,
                    threshold: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.whiteNoise = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.output;
                for (t = 0; t < e; t++) o[t] = n = i.randomAudioValue();
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, o);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.whiteNoise", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            }
        }), i.ugen.pinkNoise = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = u.state, l = r.a, c = r.p, d = u.offset, f = r.output;
                for (t = 0; t < e; t++) {
                    for (o = 0, n = 0; n < s.length; n++) a = Math.random(), s[n] = c[n] * (s[n] - a) + a, 
                    o += l[n] * s[n];
                    o = 2 * o - d, f[t] = o;
                }
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, f);
            }, r.init = function() {
                r.a = new Float32Array(r.options.coeffs.a), r.p = new Float32Array(r.options.coeffs.p), 
                r.model.state = new Float32Array(r.a.length);
                for (var e = 0; e < r.a.length; e++) r.model.offset += r.a[e];
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.pinkNoise", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    state: 0,
                    unscaledValue: 0,
                    value: 0,
                    offset: 0
                },
                coeffs: {
                    a: [ .02109238, .07113478, .68873558 ],
                    p: [ .319, .7756, .9613 ]
                }
            }
        }), i.ugen.lfNoise = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(t) {
                var n, a, o = r.model, u = e.freq.output[0], s = t, l = r.output, c = 0;
                u = u > .001 ? u : .001;
                do {
                    for (o.counter <= 0 && (o.counter = o.sampleRate / u, o.counter = o.counter > 1 ? o.counter : 1, 
                    "linear" === r.options.interpolation ? (o.start = o.unscaledValue = o.end, o.end = Math.random(), 
                    o.ramp = o.ramp = (o.end - o.start) / o.counter) : (o.start = o.unscaledValue = Math.random(), 
                    o.ramp = 0)), s -= n = s < o.counter ? s : o.counter, o.counter -= n, a = 0; a < n; a++) l[c] = o.unscaledValue, 
                    o.unscaledValue += o.ramp, c++;
                } while (s);
                r.mulAdd(t), o.value = i.ugen.lastOutputValue(t, l);
            }, r.input = function() {
                r.model.end = Math.random(), r.onInputChanged();
            }, r.input(), r;
        }, i.ugenDefaults("flock.ugen.lfNoise", {
            rate: "audio",
            inputs: {
                freq: 440,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    counter: 0,
                    level: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), i.ugen.random = function(t, n, r) {
            var a = i.ugen(t, n, r);
            return a.gen = function(e) {
                var t, n, r = a.model, o = a.generator, u = a.output;
                for (t = 0; t < e; t++) u[t] = n = o.uniform(-1, 1);
                r.unscaledValue = n, a.mulAdd(e), r.value = i.ugen.lastOutputValue(e, u);
            }, a.onInputChanged = function(e) {
                "seed" === e && a.initGenerator(), i.onMulAddInputChanged(a);
            }, a.initGenerator = function() {
                var t = a.inputs.seed;
                a.generator = t ? new e(t) : new e();
            }, a.init = function() {
                a.initGenerator(), a.calculateStrides(), a.onInputChanged();
            }, a.init(), a;
        }, i.ugenDefaults("flock.ugen.random", {
            rate: "audio",
            inputs: {
                seed: null,
                mul: null,
                add: null
            }
        }), i.ugen.random.exponential = function(e, t, n) {
            var r = i.ugen.random(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.generator, s = r.output, l = r.inputs.lambda.output, c = r.model.strides.lambda;
                for (t = n = 0; t < e; t++, n += c) s[t] = a = u.exponential(l[n]);
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r;
        }, i.ugenDefaults("flock.ugen.random.exponential", {
            rate: "audio",
            inputs: {
                seed: null,
                lambda: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "lambda" ]
            }
        }), i.ugen.random.gamma = function(e, t, n) {
            var r = i.ugen.random(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.inputs, l = r.generator, c = r.output, d = u.strides.alpha, f = s.alpha.output, p = u.strides.beta, m = s.beta.output;
                for (t = n = a = 0; t < e; t++, n += d, a += p) c[t] = o = l.gamma(f[n], m[a]);
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, c);
            }, r;
        }, i.ugenDefaults("flock.ugen.random.gamma", {
            rate: "audio",
            inputs: {
                seed: null,
                alpha: 1,
                beta: 2,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "alpha", "beta" ]
            }
        }), i.ugen.random.normal = function(e, t, n) {
            var r = i.ugen.random(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.output, l = r.inputs, c = r.generator, d = u.strides.mu, f = l.mu.output, p = u.strides.sigma, m = l.sigma.output;
                for (t = n = a = 0; t < e; t++, n += d, a += p) s[t] = o = c.normal(f[n], m[a]);
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, s);
            }, r;
        }, i.ugenDefaults("flock.ugen.random.normal", {
            rate: "audio",
            inputs: {
                seed: null,
                mu: 0,
                sigma: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "mu", "sigma" ]
            }
        }), i.ugen.random.pareto = function(e, t, n) {
            var r = i.ugen.random(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.generator, s = r.output, l = r.model.strides.alpha, c = r.inputs.alpha.output;
                for (t = n = 0; t < e; t++, n += l) s[t] = a = u.pareto(c[n]);
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r;
        }, i.ugenDefaults("flock.ugen.random.pareto", {
            rate: "audio",
            inputs: {
                seed: null,
                alpha: 5,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "alpha" ]
            }
        }), i.ugen.random.triangular = function(e, t, n) {
            var r = i.ugen.random(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, u = r.generator, s = r.output, l = r.model.strides.mode, c = r.inputs.mode.output;
                for (t = n = 0; t < e; t++, n += l) s[t] = a = u.triangular(-1, 1, c[n]);
                o.unscaledValue = a, r.mulAdd(e), o.value = i.ugen.lastOutputValue(e, s);
            }, r;
        }, i.ugenDefaults("flock.ugen.random.triangular", {
            rate: "audio",
            inputs: {
                seed: null,
                mode: .5,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "mode" ]
            }
        }), i.ugen.random.weibull = function(e, t, n) {
            var r = i.ugen.random(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.inputs, l = r.generator, c = r.output, d = u.strides.alpha, f = s.alpha.output, p = u.strides.beta, m = s.beta.output;
                for (t = n = a = 0; t < e; t++, n += d, a += p) c[t] = o = l.weibull(f[n], m[a]);
                u.unscaledValue = o, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, c);
            }, r;
        }, i.ugenDefaults("flock.ugen.random.weibull", {
            rate: "audio",
            inputs: {
                seed: null,
                alpha: 1,
                beta: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "alpha", "beta" ]
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.change = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                for (var t, n = r.model, a = r.inputs.initial.output, o = n.strides.initial, i = r.inputs.target.output, u = n.strides.target, s = r.output, l = n.samplesLeft, c = n.crossfadeLevel, d = 0, f = 0, p = 0; d < e; d++, 
                f += o, p += u) l > 0 ? (t = a[f], l--) : c > 0 ? (t = a[f] * c + i[p] * (1 - c), 
                c -= n.crossfadeStepSize) : t = i[p], s[d] = t;
                n.samplesLeft = l, n.crossfadeLevel = c, n.value = n.unscaledValue = t;
            }, r.onInputChanged = function(e) {
                var t = r.model, n = r.inputs;
                "time" !== e && e || (t.samplesLeft = Math.round(n.time.output[0] * t.sampleRate)), 
                "crossfade" !== e && e || (t.crossfadeStepSize = 1 / Math.round(n.crossfade.output[0] * t.sampleRate), 
                t.crossfadeLevel = n.crossfade.output[0] > 0 ? 1 : 0), r.calculateStrides();
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.change", {
            rate: "audio",
            inputs: {
                initial: 0,
                target: 0,
                time: 0,
                crossfade: 0
            },
            ugenOptions: {
                model: {
                    samplesLeft: 0,
                    crossfadeStepSize: 0,
                    crossfadeLevel: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "initial", "target" ]
            }
        }), i.ugen.listItem = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u = r.model, s = r.output, l = r.inputs.list, c = l.length - 1, d = r.inputs.index.output;
                for (t = 0, a = 0; t < e; t++, a += u.strides.index) o = Math.round(d[a] * c), o = Math.max(0, o), 
                n = l[o = Math.min(o, c)], s[t] = n;
                u.unscaledValue = n, r.mulAdd(e), u.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged(), r;
        }, i.ugenDefaults("flock.ugen.listItem", {
            rate: "control",
            inputs: {
                index: 0,
                list: [ 0 ]
            },
            ugenOptions: {
                strideInputs: [ "index" ]
            }
        }), i.ugen.sequence = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.inputs.values, u = r.inputs, s = u.freq.output, l = u.loop.output[0], c = r.model, d = c.scale, f = r.output, p = u.start ? Math.round(u.start.output[0]) : 0, m = u.end ? Math.round(u.end.output[0]) : o.length;
                for (void 0 === c.unscaledValue && (t = o[p], c.unscaledValue = void 0 === t ? 0 : t), 
                void 0 === c.nextIdx && (c.nextIdx = p), n = 0, a = 0; n < e; n++, a += c.strides.freq) {
                    if (c.nextIdx >= m) {
                        if (!(l > 0)) {
                            f[n] = c.unscaledValue;
                            continue;
                        }
                        c.nextIdx = p;
                    }
                    f[n] = c.unscaledValue = o[c.nextIdx], c.phase += s[a] * d, c.phase >= 1 && (c.phase = 0, 
                    c.nextIdx++);
                }
                r.mulAdd(e), c.value = i.ugen.lastOutputValue(e, f);
            }, r.onInputChanged = function() {
                r.model.scale = r.rate !== i.rates.DEMAND ? r.model.sampleDur : 1, r.inputs.values && 0 !== r.inputs.values.length || !r.inputs.list || (i.log.warn("The 'list' input to flock.ugen.sequence is deprecated. Use 'values' instead."), 
                r.inputs.values = r.inputs.list), r.inputs.values || (r.inputs.values = []), r.calculateStrides(), 
                i.onMulAddInputChanged(r);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.sequence", {
            rate: "control",
            inputs: {
                start: 0,
                freq: 1,
                loop: 0,
                values: []
            },
            ugenOptions: {
                model: {
                    unscaledValue: void 0,
                    value: 0,
                    phase: 0
                },
                strideInputs: [ "freq" ]
            }
        }), i.ugen.sequencer = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a = r.model, o = r.options, u = o.resetOnNext, s = r.output, l = r.inputs.loop.output[0], c = r.inputs.durations, d = r.inputs.values;
                for (a.shouldValidateSequences && (a.shouldValidateSequences = !1, i.ugen.sequencer.validateSequences(c, d)), 
                t = 0; t < e; t++) 0 !== d.length && 0 !== c.length ? (a.samplesRemaining <= 0 ? a.idx < c.length - 1 ? (a.idx++, 
                n = i.ugen.sequencer.nextStage(c, d, u, a)) : l > 0 ? (a.idx = 0, n = i.ugen.sequencer.nextStage(c, d, u, a)) : n = o.holdLastValue ? a.unscaledValue : 0 : (n = d[a.idx], 
                a.samplesRemaining--), s[t] = n) : s[t] = n = 0;
                a.unscaledValue = n, r.mulAdd(e), a.value = i.ugen.lastOutputValue(e, s);
            }, r.onInputChanged = function(e) {
                var t = r.model, n = r.inputs;
                "durations" !== e && n.durations === t.prevDurations || (t.idx = 0, i.ugen.sequencer.calcDurationsSamps(n.durations, r.model), 
                i.ugen.sequencer.validateInput("durations", r), t.prevDurations = n.durations), 
                "values" !== e && n.values === t.prevValues || (t.idx = 0, i.ugen.sequencer.validateInput("values", r), 
                t.prevValues = n.values), r.model.shouldValidateSequences = !0, i.onMulAddInputChanged(r);
            }, r.init = function() {
                r.onInputChanged();
            }, r.init(), r;
        }, i.ugen.sequencer.validateInput = function(e, t) {
            var n = t.inputs[e];
            n && i.isIterable(n) || i.fail("No " + e + " array input was specified for flock.ugen.sequencer: " + r.prettyPrintJSON(t.options.ugenDef));
        }, i.ugen.sequencer.validateSequences = function(e, t) {
            e.length !== t.length && i.fail("Mismatched durations and values array lengths for flock.ugen.sequencer. Durations: " + r.prettyPrintJSON(e) + ", values: " + r.prettyPrintJSON(t));
        }, i.ugen.sequencer.calcDurationsSamps = function(e, t) {
            t.samplesRemaining = Math.floor(e[t.idx] * t.sampleRate);
        }, i.ugen.sequencer.nextStage = function(e, t, n, r) {
            return i.ugen.sequencer.calcDurationsSamps(e, r), r.samplesRemaining--, n ? 0 : t[r.idx];
        }, i.ugenDefaults("flock.ugen.sequencer", {
            rate: "audio",
            inputs: {
                durations: [],
                values: [],
                loop: 0
            },
            ugenOptions: {
                model: {
                    idx: 0,
                    samplesRemaining: 0,
                    unscaledValue: 0,
                    value: 0,
                    prevDurations: [],
                    prevValues: []
                },
                resetOnNext: !1,
                holdLastvalue: !1
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        i.ugen.valueChangeTrigger = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o = r.model, i = r.inputs.source.output, u = r.output;
                for (t = 0, n = 0; t < e; t++, n += o.strides.source) a = i[n], u[t] = a !== o.prevVal ? 1 : 0, 
                o.prevVal = a;
                o.value = o.unscaledValue = a;
            }, r.onInputChanged = function(e) {
                r.calculateStrides(), "source" === e && r.options.triggerOnSetSameValue && (r.model.prevVal = null);
            }, r.calculateStrides(), r;
        }, i.ugenDefaults("flock.ugen.valueChangeTrigger", {
            rate: "control",
            inputs: {
                source: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    prevVal: 0
                },
                triggerOnSetSameValue: !0,
                strideInputs: [ "source" ]
            }
        }), i.ugen.inputChangeTrigger = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n, a, o, u, s = r.model, l = r.inputs.source.output, c = s.strides.source, d = r.inputs.duration.output, f = s.strides.duration, p = s.prevDur, m = r.output;
                for (t = n = a = 0; t < e; t++, n += c, a += f) o = l[n], (u = d[a]) !== p && (s.prevDur = u, 
                s.remainingOpenSamples = o > 0 ? u > 0 ? s.sampleRate * u : 1 : 0), s.remainingOpenSamples > 0 ? (m[t] = o, 
                s.remainingOpenSamples--) : m[t] = 0;
                s.value = s.unscaledValue = i.ugen.lastOutputValue(e, m);
            }, r.onInputChanged = function(e) {
                r.calculateStrides(), "source" === e && (r.model.prevDur = null);
            }, r.calculateStrides(), r;
        }, i.ugenDefaults("flock.ugen.inputChangeTrigger", {
            rate: "control",
            inputs: {
                source: 0,
                duration: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    prevDuration: 0,
                    remainingOpenSamples: 0
                },
                strideInputs: [ "source", "duration" ]
            }
        }), i.ugen.triggerCallback = function(e, t, n) {
            var a = i.ugen(e, t, n);
            return a.gen = function(e) {
                var t, n, r, o, i, u = a.model, s = a.options, l = a.output, c = a.inputs, d = u.strides.trigger, f = u.strides.source, p = c.trigger.output, m = c.source.output, g = s.callback, h = g.func, v = g.args, y = g.this, b = u.lastArgIdx, k = u.prevTrig;
                for (t = n = r = 0; t < e; t++, n += d, r += f) o = p[n], i = m[r], o > 0 && k <= 0 && h && (v[b] = i, 
                h.apply(y, v)), l[t] = i, k = o;
                u.prevTrig = k, u.value = u.unscaledValue = i;
            }, a.onInputChanged = function() {
                var e = a.options, t = a.model, n = e.callback, o = n.funcName;
                if (o) n.func = r.getGlobalValue(o); else if (n.this && n.method) {
                    if ("string" != typeof n.this) throw new Error("flock.ugen.triggerCallback doesn't support raw 'this' objects.Use a global key path instead.");
                    n.this = "string" == typeof n.this ? r.getGlobalValue(n.this) : n.this, n.func = r.get(n.this, n.method);
                }
                t.lastArgIdx = n.args.length, a.calculateStrides();
            }, a.onInputChanged(), a;
        }, i.ugenDefaults("flock.ugen.triggerCallback", {
            rate: "audio",
            inputs: {
                source: 0,
                trigger: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    funcName: void 0,
                    lastArgIdx: 0
                },
                callback: {
                    this: void 0,
                    method: void 0,
                    func: void 0,
                    args: []
                },
                strideInputs: [ "source", "trigger" ]
            }
        }), i.ugen.t2a = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function() {
                for (var e, t = r.model, n = r.inputs.source.output[0], a = 0 | r.inputs.offset.output[0], o = r.output, i = 0; i < o.length; i++) o[i] = e = 0;
                n > 0 && t.prevTrig <= 0 && (o[a] = e = n), t.prevTrig = n, t.value = t.unscaledValue = e;
            }, r;
        }, i.ugenDefaults("flock.ugen.t2a", {
            rate: "audio",
            inputs: {
                source: null,
                offset: 0
            },
            ugenOptions: {
                model: {
                    prevTrig: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        });
    }();
    i = (r = r || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var e = r.registerNamespace("jQuery");
        r.registerNamespace("flock.view"), i.view.scope = function(t, n) {
            var r = {
                model: n || {
                    values: []
                },
                canvas: e(t)[0]
            };
            return r.refreshView = function() {
                var e, t, n, a = r.ctx, o = r.model.height, i = r.model.halfHeight, u = r.model.width, s = r.model.values, l = s.length, c = r.model.scaleX * (u / l);
                for (a.clearRect(0, 0, u, o), a.beginPath(), e = 0; e < l; e++) t = e * c, n = s[e] * r.model.scaleY * i + i, 
                a.lineTo(t, n);
                a.stroke();
            }, r.init = function() {
                r.ctx = r.canvas.getContext("2d"), r.ctx.fillStyle = r.model.fill || r.ctx.fillStyle, 
                r.ctx.strokeStyle = r.model.strokeColor || r.ctx.strokeStyle, r.ctx.lineWidth = r.model.strokeWidth || r.ctx.lineWidth, 
                r.model.min = r.model.min || -1, r.model.max = r.model.max || 1, r.model.height = r.canvas.height, 
                r.model.halfHeight = r.model.height / 2, r.model.width = r.canvas.width, r.model.scaleX = r.model.scaleX || r.model.scale || 1, 
                r.model.scaleY = r.model.scaleY || r.model.scale || 1, r.refreshView();
            }, r.init(), r;
        }, i.view.drawBuffer = function(t, n) {
            (n = n || {}).height = n.height || 200, n.width = n.width || 1e3;
            var a = r.stringTemplate(i.view.drawBuffer.markupTemplate, n), o = e(a);
            return i.view.scope(o[0], {
                values: t
            }), o;
        }, i.view.drawBuffer.markupTemplate = "<canvas height='%height' width='%width'></canvas>";
    }();
    var i = (r = r || require("infusion")).registerNamespace("flock");
    return function() {
        "use strict";
        var e = r.registerNamespace("jQuery");
        r.registerNamespace("flock.ugen"), i.ugen.scope = function(e, t, n) {
            var r = i.ugen(e, t, n);
            return r.gen = function(e) {
                var t, n = r.model, a = r.inputs.source.output, o = n.spf, u = n.bufIdx, s = n.scope.values;
                for (t = 0; t < e; t++) s[u] = a[t], u < o ? u += 1 : (u = 0, r.scopeView.refreshView());
                n.bufIdx = u, n.value = n.unscaledValue = i.ugen.lastOutputValue(e, a);
            }, r.onInputChanged = function() {
                r.output = r.inputs.source.output;
            }, r.init = function() {
                r.model.spf = Math.round(r.model.sampleRate / r.options.fps), r.model.bufIdx = 0, 
                r.model.scope = r.options.styles, r.model.scope.values = new Float32Array(r.model.spf), 
                r.scopeView = i.view.scope(r.options.canvas, r.model.scope), r.onInputChanged(), 
                r.scopeView.refreshView();
            }, r.init(), r;
        }, i.ugenDefaults("flock.ugen.scope", {
            rate: "audio",
            inputs: {
                source: null
            },
            ugenOptions: {
                fps: 60,
                styles: {
                    strokeColor: "#777777",
                    strokeWidth: 1
                }
            }
        }), i.ugen.mouse = {}, i.ugen.mouse.cursor = function(t, n, r) {
            var a = i.ugen(t, n, r);
            return a.exponentialGen = function(e) {
                var t, n, r = a.model, o = i.ugen.mouse.cursor.normalize(a.target, r), u = r.movingAvg, s = a.inputs.lag.output[0], l = a.inputs.add.output[0], c = a.inputs.mul.output[0], d = r.lagCoef, f = a.output;
                for (s !== d && (d = 0 === s ? 0 : Math.exp(i.LOG001 / (s * r.sampleRate)), r.lagCoef = d), 
                t = 0; t < e; t++) n = c + l, u = (o = Math.pow(n / l, o) * l) + d * (u - o), f[t] = u;
                r.movingAvg = u, r.value = r.unscaledValue = u;
            }, a.linearGen = function(e) {
                var t, n = a.model, r = i.ugen.mouse.cursor.normalize(a.target, n), o = n.movingAvg, u = a.inputs.lag.output[0], s = a.inputs.add.output[0], l = a.inputs.mul.output[0], c = n.lagCoef, d = a.output;
                for (u !== c && (c = 0 === u ? 0 : Math.exp(i.LOG001 / (u * n.sampleRate)), n.lagCoef = c), 
                t = 0; t < e; t++) o = r + c * (o - r), d[t] = o * l + s;
                n.movingAvg = n.unscaledValue = o, n.value = i.ugen.lastOutputValue(e, d);
            }, a.noInterpolationGen = function(e) {
                var t, n = a.model, r = a.output, o = i.ugen.mouse.cursor.normalize(a.target, n);
                for (t = 0; t < e; t++) r[t] = o * a.inputs.mul.output[0] + a.inputs.add.output[0];
                n.value = n.unscaledValue = i.ugen.lastOutputValue(e, r);
            }, a.moveListener = function(e) {
                var t = a.model;
                t.mousePosition = e[t.eventProp];
            }, a.overListener = function() {
                a.model.isWithinTarget = !0;
            }, a.outListener = function() {
                var e = a.model;
                e.isWithinTarget = !1, e.mousePosition = 0;
            }, a.downListener = function() {
                a.model.isMouseDown = !0;
            }, a.upListener = function() {
                var e = a.model;
                e.isMouseDown = !1, e.mousePosition = 0;
            }, a.moveWhileDownListener = function(e) {
                a.model.isMouseDown && a.moveListener(e);
            }, a.bindEvents = function() {
                var e = a.target, t = a.moveListener;
                a.options.onlyOnMouseDown && (e.mousedown(a.downListener), e.mouseup(a.upListener), 
                t = a.moveWhileDownListener), e.mouseover(a.overListener), e.mouseout(a.outListener), 
                e.mousemove(t);
            }, a.onInputChanged = function() {
                i.onMulAddInputChanged(a);
                var e = a.options.interpolation;
                a.gen = "none" === e ? a.noInterpolationGen : "exponential" === e ? a.exponentialGen : a.linearGen;
            }, a.init = function() {
                var t = a.model, n = a.options, r = n.axis, o = e(n.target || window);
                "x" === r || "width" === r || "horizontal" === r ? (t.eventProp = "clientX", t.offsetProp = "left", 
                t.dimension = "width") : (t.eventProp = "clientY", t.offsetProp = "top", t.dimension = "height"), 
                a.target = o, t.mousePosition = 0, t.movingAvg = 0, a.bindEvents(), a.onInputChanged();
            }, a.init(), a;
        }, i.ugen.mouse.cursor.normalize = function(e, t) {
            if (!t.isWithinTarget) return 0;
            var n = e.getClientRects ? e.offset() : void 0, r = t.mousePosition, a = e[t.dimension]();
            return n && (r -= n[t.offsetProp]), r / a;
        }, i.ugenDefaults("flock.ugen.mouse.cursor", {
            rate: "control",
            inputs: {
                lag: .5,
                add: 0,
                mul: 1
            },
            ugenOptions: {
                axis: "x",
                interpolation: "linear",
                model: {
                    mousePosition: 0,
                    movingAvg: 0,
                    value: 0
                }
            }
        }), i.ugen.mouse.click = function(t, n, r) {
            var a = i.ugen(t, n, r);
            return a.gen = function(e) {
                var t, n = a.output, r = a.model;
                for (t = 0; t < e; t++) n[t] = r.unscaledValue;
                a.mulAdd(e), r.value = i.ugen.lastOutputValue(e, n);
            }, a.mouseDownListener = function() {
                a.model.unscaledValue = 1;
            }, a.mouseUpListener = function() {
                a.model.unscaledValue = 0;
            }, a.init = function() {
                var t = a.model;
                t.target = e(a.options.target ? a.options.target : window), t.target.mousedown(a.mouseDownListener), 
                t.target.mouseup(a.mouseUpListener), a.onInputChanged();
            }, a.onInputChanged = function() {
                i.onMulAddInputChanged(a);
            }, a.init(), a;
        }, i.ugenDefaults("flock.ugen.mouse.click", {
            rate: "control"
        }), i.ugen.mediaIn = function(t, n, r) {
            var a = i.ugen(t, n, r);
            return a.gen = function(e) {
                for (var t, n = a.model, r = a.output, o = a.bus, u = 0; u < e; u++) r[u] = t = o[u];
                n.unscaledValue = t, a.mulAdd(e), n.value = i.ugen.lastOutputValue(e, r);
            }, a.onInputChanged = function() {
                i.onMulAddInputChanged(a);
            }, a.init = function() {
                var t = a.enviro.audioSystem.nativeNodeManager, n = e(a.options.element), r = t.createMediaElementInput(n[0]);
                a.bus = a.options.buses[r], a.onInputChanged(), i.platform.browser.safari && i.platform.browser.majorVersionNumber < 601 ? i.log.warn("MediaElementSourceNode only works on Safari 9 or higher. For more information, see https://bugs.webkit.org/show_bug.cgi?id=84743 and https://bugs.webkit.org/show_bug.cgi?id=125031") : i.platform.isAndroid && i.log.warn("MediaElementSourceNode does not work on Android. For more information, see https://code.google.com/p/chromium/issues/detail?id=419446");
            }, a.init(), a;
        }, i.ugenDefaults("flock.ugen.mediaIn", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            },
            ugenOptions: {
                element: "audio"
            }
        });
    }(), window.fluid = r, i;
});