/*! Flocking 0.2.0, Copyright 2017 Colin Clark | flockingjs.org */


"use strict";

!function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.ArrayMath) {
        var t = {};
        t.add = function(e, t, n) {
            var o;
            if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; o >= 0; --o) e[o] = t[o] + n[o]; else for (o = Math.min(e.length, n.length) - 1; o >= 0; --o) e[o] = t + n[o];
        }, t.sub = function(e, t, n) {
            var o;
            if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; o >= 0; --o) e[o] = t[o] - n[o]; else for (o = Math.min(e.length, n.length) - 1; o >= 0; --o) e[o] = t - n[o];
        }, t.mul = function(e, t, n) {
            var o;
            if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; o >= 0; --o) e[o] = t[o] * n[o]; else for (o = Math.min(e.length, n.length) - 1; o >= 0; --o) e[o] = t * n[o];
        }, t.mulCplx = function(e, t, n, o, r, a) {
            var i, l, u, s, f;
            if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, o.length, r.length, a.length) - 1; i >= 0; --i) l = n[i], 
            u = o[i], s = r[i], f = a[i], e[i] = l * s - u * f, t[i] = l * f + u * s; else for (i = Math.min(e.length, t.length, r.length, a.length) - 1; i >= 0; --i) s = r[i], 
            f = a[i], e[i] = n * s - o * f, t[i] = n * f + o * s;
        }, t.div = function(e, t, n) {
            var o;
            if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; o >= 0; --o) e[o] = t[o] / n[o]; else for (o = Math.min(e.length, n.length) - 1; o >= 0; --o) e[o] = t / n[o];
        }, t.divCplx = function(e, t, n, o, r, a) {
            var i, l, u, s, f, c;
            if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, o.length, r.length, a.length) - 1; i >= 0; --i) l = n[i], 
            u = o[i], c = 1 / ((s = r[i]) * s + (f = a[i]) * f), e[i] = (l * s + u * f) * c, 
            t[i] = (u * s - l * f) * c; else for (i = Math.min(e.length, t.length, r.length, a.length) - 1; i >= 0; --i) c = 1 / ((s = r[i]) * s + (f = a[i]) * f), 
            e[i] = (n * s + o * f) * c, t[i] = (o * s - n * f) * c;
        }, t.madd = function(e, t, n, o) {
            var r;
            if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length, o.length) - 1; r >= 0; --r) e[r] = t[r] * n[r] + o[r]; else for (r = Math.min(e.length, n.length, o.length) - 1; r >= 0; --r) e[r] = t * n[r] + o[r];
        }, t.abs = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.abs(t[n]);
        }, t.absCplx = function(e, t, n) {
            for (var o = Math.min(e.length, t.length, n.length) - 1; o >= 0; --o) e[o] = Math.sqrt(t[o] * t[o] + n[o] * n[o]);
        }, t.acos = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.acos(t[n]);
        }, t.asin = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.asin(t[n]);
        }, t.atan = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.atan(t[n]);
        }, t.atan2 = function(e, t, n) {
            for (var o = Math.min(e.length, n.length, t.length) - 1; o >= 0; --o) e[o] = Math.atan2(t[o], n[o]);
        }, t.ceil = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.ceil(t[n]);
        }, t.cos = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.cos(t[n]);
        }, t.exp = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.exp(t[n]);
        }, t.floor = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.floor(t[n]);
        }, t.log = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.log(t[n]);
        }, t.max = function(e) {
            for (var t = -1 / 0, n = e.length - 1; n >= 0; --n) {
                var o = e[n];
                o > t && (t = o);
            }
            return t;
        }, t.min = function(e) {
            for (var t = 1 / 0, n = e.length - 1; n >= 0; --n) {
                var o = e[n];
                o < t && (t = o);
            }
            return t;
        }, t.pow = function(e, t, n) {
            var o;
            if (n instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; o >= 0; --o) e[o] = Math.pow(t[o], n[o]); else for (o = Math.min(e.length, t.length) - 1; o >= 0; --o) e[o] = Math.pow(t[o], n);
        }, t.random = function(e, t, n) {
            t || (t = 0), isNaN(parseFloat(n)) && (n = 1);
            for (var o = n - t, r = e.length - 1; r >= 0; --r) e[r] = Math.random() * o + t;
        }, t.round = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.round(t[n]);
        }, t.sin = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.sin(t[n]);
        }, t.sqrt = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.sqrt(t[n]);
        }, t.tan = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.tan(t[n]);
        }, t.clamp = function(e, t, n, o) {
            for (var r = Math.min(e.length, t.length) - 1; r >= 0; --r) {
                var a = t[r];
                e[r] = a < n ? n : a > o ? o : a;
            }
        }, t.fract = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) {
                var o = t[n];
                e[n] = o - Math.floor(o);
            }
        }, t.fill = function(e, t) {
            for (var n = e.length - 1; n >= 0; --n) e[n] = t;
        }, t.ramp = function(e, t, n) {
            var o = e.length - 1;
            if (o >= 0 && (e[0] = t), o > 0) for (var r = (n - t) / o, a = 1; a <= o; ++a) e[a] = t + r * a;
        }, t.sign = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = t[n] < 0 ? -1 : 1;
        }, t.sum = function(e) {
            for (var t = 0, n = e.length - 1; n >= 0; --n) t += e[n];
            return t;
        }, t.sampleLinear = function(e, t, n) {
            for (var o = t.length - 1, r = Math.min(e.length, n.length) - 1; r >= 0; --r) {
                var a = n[r];
                a = a < 0 ? 0 : a > o ? o : a;
                var i = Math.floor(a), l = a - i, u = t[i], s = t[i < o ? i + 1 : o];
                e[r] = u + l * (s - u);
            }
        }, t.sampleLinearRepeat = function(e, t, n) {
            for (var o = t.length, r = o - 1, a = Math.min(e.length, n.length) - 1; a >= 0; --a) {
                var i = n[a];
                i -= Math.floor(i / o) * o;
                var l = Math.floor(i), u = i - l, s = t[l], f = t[l < r ? l + 1 : 0];
                e[a] = s + u * (f - s);
            }
        }, t.sampleCubic = function(e, t, n) {
            for (var o = t.length - 1, r = Math.min(e.length, n.length) - 1; r >= 0; --r) {
                var a = n[r];
                a = a < 0 ? 0 : a > o ? o : a;
                var i = Math.floor(a), l = a - i, u = l * l, s = u * l, f = -2 * s + 3 * u, c = 1 - f, d = s - u, m = d - u + l, h = t[i > 0 ? i - 1 : 0], p = t[i], k = t[i < o ? i + 1 : o], g = t[i < o - 1 ? i + 2 : o];
                e[r] = c * p + f * k + .5 * (m * (k - h) + d * (g - p));
            }
        }, t.sampleCubicRepeat = function(e, t, n) {
            for (var o = t.length, r = o - 1, a = Math.min(e.length, n.length) - 1; a >= 0; --a) {
                var i = n[a];
                i -= Math.floor(i / o) * o;
                var l = Math.floor(i), u = i - l, s = u * u, f = s * u, c = -2 * f + 3 * s, d = 1 - c, m = f - s, h = m - s + u, p = t[l > 0 ? l - 1 : r], k = t[l], g = t[l < r ? l + 1 : 0], v = t[l < r - 1 ? l + 2 : l + 2 - Math.floor((l + 2) / o) * o];
                e[a] = d * k + c * g + .5 * (h * (g - p) + m * (v - k));
            }
        }, t.pack = function(e, t, n, o, r, a, i) {
            var l = Math.floor(Math.max(0, e.length - t) / n), u = Math.min(l, o.length);
            if (r) {
                u = Math.min(u, r.length);
                if (a) {
                    u = Math.min(u, a.length);
                    if (i) for (var u = Math.min(u, i.length), s = 0; s < u; ++s) e[t] = o[s], e[t + 1] = r[s], 
                    e[t + 2] = a[s], e[t + 3] = i[s], t += n; else for (s = 0; s < u; ++s) e[t] = o[s], 
                    e[t + 1] = r[s], e[t + 2] = a[s], t += n;
                } else for (s = 0; s < u; ++s) e[t] = o[s], e[t + 1] = r[s], t += n;
            } else for (s = 0; s < u; ++s) e[t] = o[s], t += n;
        }, t.unpack = function(e, t, n, o, r, a, i) {
            var l = Math.floor(Math.max(0, e.length - t) / n), u = Math.min(l, o.length);
            if (r) {
                u = Math.min(u, r.length);
                if (a) {
                    u = Math.min(u, a.length);
                    if (i) for (var u = Math.min(u, i.length), s = 0; s < u; ++s) o[s] = e[t], r[s] = e[t + 1], 
                    a[s] = e[t + 2], i[s] = e[t + 3], t += n; else for (s = 0; s < u; ++s) o[s] = e[t], 
                    r[s] = e[t + 1], a[s] = e[t + 2], t += n;
                } else for (s = 0; s < u; ++s) o[s] = e[t], r[s] = e[t + 1], t += n;
            } else for (s = 0; s < u; ++s) o[s] = e[t], t += n;
        }, e.ArrayMath = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.Filter) {
        var t = function(e, t) {
            !isNaN(parseFloat(e)) && isFinite(e) || (e = 1), t || (t = 0), this._b = new Float32Array(e), 
            this._b[0] = 1, this._a = new Float32Array(t), this._bHist = new Float32Array(e), 
            this._aHist = new Float32Array(t);
        };
        t.prototype.filter = function(e, t) {
            var n, o = this._a, r = o.length, a = this._b, i = a.length, l = this._aHist, u = this._bHist, s = t.length, f = e.length, c = i - 1, d = r;
            for (n = 0; (c || d) && n < s; ++n) {
                var m;
                m = i - c, c && c--;
                I = a[0] * t[n];
                for (S = 1; S < m; ++S) I += a[S] * t[n - S];
                for (;S < i; ++S) I += a[S] * u[S - m];
                for (m = r - d, d && d--, S = 0; S < m; ++S) I -= o[S] * e[n - 1 - S];
                for (;S < r; ++S) I -= o[S] * l[S - m];
                e[n] = I;
            }
            if (3 == i && 2 == r) for (var h, p, k = a[0], g = a[1], v = a[2], b = o[0], y = o[1], w = t[n - 1], A = t[n - 2], N = e[n - 1], M = e[n - 2]; n < s; ++n) h = A, 
            A = w, p = M, N = k * (w = t[n]) + g * A + v * h - b * (M = N) - y * p, e[n] = N; else for (;n < s; ++n) {
                var S, I = a[0] * t[n];
                for (S = 1; S < i; ++S) I += a[S] * t[n - S];
                for (S = 0; S < r; ++S) I -= o[S] * e[n - 1 - S];
                e[n] = I;
            }
            var C = Math.min(i - 1, s);
            for (n = i - 2; n >= C; --n) u[n] = u[n - C];
            for (n = 0; n < C; ++n) u[n] = t[s - 1 - n];
            for (C = Math.min(r, f), n = r - 1; n >= C; --n) l[n] = l[n - C];
            for (n = 0; n < C; ++n) l[n] = e[s - 1 - n];
        }, t.prototype.clearHistory = function() {
            for (e = this._bHist.length - 1; e >= 0; --e) this._bHist[e] = 0;
            for (var e = this._aHist.length - 1; e >= 0; --e) this._aHist[e] = 0;
        }, t.prototype.setB = function(e) {
            for (var t = Math.min(this._b.length, e.length), n = 0; n < t; ++n) this._b[n] = e[n];
        }, t.prototype.setA = function(e) {
            for (var t = Math.min(this._a.length, e.length), n = 0; n < t; ++n) this._a[n] = e[n];
        }, e.Filter = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.FFT) {
        var t = function(e, t, n, o, r, a, i) {
            for (var l, u, s, f, c, d, m, h, p = 0, k = n, g = n + i, v = .7071067811865475, b = k + i; k < b; ) s = e[k] * v, 
            f = t[k] * v, c = e[g] * v, d = t[g] * v, l = c * (m = r[p]) - d * (h = a[p]), u = c * h + d * m, 
            e[g] = s - l, t[g] = f - u, e[k] = s + l, t[k] = f + u, p += o, ++k, ++g;
        }, n = function(e, t, n, o, r, a, i) {
            for (var l, u, s, f, c, d, m, h, p, k, g, v, b, y, w, A, N = 0, M = 0, S = 2 * o, I = n, C = n + i, x = n + 2 * i, L = a[o * i], D = .5773502691896258, F = I + i; I < F; ) p = e[I] * D, 
            k = t[I] * D, g = e[C] * D, v = t[C] * D, b = e[x] * D, y = t[x] * D, w = r[N], 
            f = g * (A = a[N]) + v * w, l = (s = g * w - v * A) - (c = b * (w = r[M]) - y * (A = a[M])), 
            u = f - (d = b * A + y * w), g = p - .5 * (m = s + c), v = k - .5 * (h = f + d), 
            l *= L, u *= L, e[I] = p + m, t[I] = k + h, e[x] = g + u, t[x] = v - l, e[C] = g - u, 
            t[C] = v + l, N += o, M += S, ++I, ++C, ++x;
        }, o = function(e, t, n, o, r, a, i, l) {
            for (var u, s, f, c, d, m, h, p, k, g, v, b, y, w, A, N, M, S, I, C, x, L, D = 0, F = 0, P = 0, O = 2 * o, R = 3 * o, T = n, B = n + i, E = n + 2 * i, V = n + 3 * i, U = T + i; T < U; ) y = .5 * e[T], 
            w = .5 * t[T], A = .5 * e[B], N = .5 * t[B], M = .5 * e[E], S = .5 * t[E], I = .5 * e[V], 
            C = .5 * t[V], u = A * (x = r[D]) - N * (L = a[D]), s = A * L + N * x, v = y - (f = M * (x = r[F]) - S * (L = a[F])), 
            b = w - (c = M * L + S * x), y += f, w += c, h = u + (d = I * (x = r[P]) - C * (L = a[P])), 
            p = s + (m = I * L + C * x), k = u - d, g = s - m, e[E] = y - h, t[E] = w - p, e[T] = y + h, 
            t[T] = w + p, l ? (e[B] = v - g, t[B] = b + k, e[V] = v + g, t[V] = b - k) : (e[B] = v + g, 
            t[B] = b - k, e[V] = v - g, t[V] = b + k), D += o, F += O, P += R, ++T, ++B, ++E, 
            ++V;
        }, r = function(e, t, n, o, r, a, i) {
            for (var l, u, s, f, c, d, m, h, p, k, g, v, b, y, w, A, N, M, S, I, C, x, L, D, F, P, O, R, T, B, E, V, U, G, q, _, W, z, j = 0, H = 0, K = 0, J = 0, Q = 2 * o, X = 3 * o, Y = 4 * o, $ = n, Z = n + i, ee = n + 2 * i, te = n + 3 * i, ne = n + 4 * i, oe = r[o * i], re = a[o * i], ae = r[2 * o * i], ie = a[2 * o * i], le = .4472135954999579, ue = $ + i; $ < ue; ) O = e[$] * le, 
            R = t[$] * le, T = e[Z] * le, B = t[Z] * le, E = e[ee] * le, V = t[ee] * le, U = e[te] * le, 
            G = t[te] * le, q = e[ne] * le, _ = t[ne] * le, l = O, u = R, s = T * (W = r[j]) - B * (z = a[j]), 
            f = T * z + B * W, c = E * (W = r[H]) - V * (z = a[H]), d = E * z + V * W, m = U * (W = r[K]) - G * (z = a[K]), 
            h = U * z + G * W, w = s + (p = q * (W = r[J]) - _ * (z = a[J])), A = f + (k = q * z + _ * W), 
            C = s - p, x = f - k, N = c + m, M = d + h, S = c - m, I = d - h, e[$] = O + w + N, 
            t[$] = R + A + M, g = l + w * oe + N * ae, v = u + A * oe + M * ae, b = x * re + I * ie, 
            y = -C * re - S * ie, e[Z] = g - b, t[Z] = v - y, e[ne] = g + b, t[ne] = v + y, 
            L = l + w * ae + N * oe, D = u + A * ae + M * oe, F = -x * ie + I * re, P = C * ie - S * re, 
            e[ee] = L + F, t[ee] = D + P, e[te] = L - F, t[te] = D - P, j += o, H += Q, K += X, 
            J += Y, ++$, ++Z, ++ee, ++te, ++ne;
        }, a = function(e, t, n, o, r, a, i, l, u) {
            var s, f, c, d, m, h, p, k, g, v, b = new Float32Array(l), y = new Float32Array(l), w = Math.sqrt(1 / l);
            for (s = 0; s < i; ++s) {
                for (d = n + s, f = 0; f < l; ++f) b[f] = e[d] * w, y[f] = t[d] * w, d += i;
                d = n + s;
                var A = o * s;
                for (f = 0; f < l; ++f) {
                    m = b[0], h = y[0];
                    var N = 0;
                    for (c = 1; c < l; ++c) (N += A) >= u && (N -= u), p = b[c], k = y[c], m += p * (g = r[N]) - k * (v = a[N]), 
                    h += p * v + k * g;
                    e[d] = m, t[d] = h, d += i, A += o;
                }
            }
        }, i = function(e, l, u, s, f, c, d, m, h, p, k, g, v, b) {
            var y = h[p++], w = h[p++], A = u, N = u + y * w, M = d * m;
            if (1 == w) do {
                e[u] = s[c], l[u] = f[c], c += M, ++u;
            } while (u != N); else do {
                i(e, l, u, s, f, c, d * y, m, h, p, k, g, v, b), c += M, u += w;
            } while (u != N);
            switch (u = A, y) {
              case 2:
                t(e, l, u, d, k, g, w);
                break;

              case 3:
                n(e, l, u, d, k, g, w);
                break;

              case 4:
                o(e, l, u, d, k, g, w, b);
                break;

              case 5:
                r(e, l, u, d, k, g, w);
                break;

              default:
                a(e, l, u, d, k, g, w, y, v);
            }
        }, l = function(e, t) {
            var n = 4, o = Math.floor(Math.sqrt(e)), r = 0;
            do {
                for (;e % n; ) {
                    switch (n) {
                      case 4:
                        n = 2;
                        break;

                      case 2:
                        n = 3;
                        break;

                      default:
                        n += 2;
                    }
                    n > o && (n = e);
                }
                e = Math.floor(e / n), t[r++] = n, t[r++] = e;
            } while (e > 1);
        }, u = function(e) {
            e || (e = 256), Object.defineProperty(this, "size", {
                configurable: !1,
                writable: !1,
                value: e
            }), this._twiddlesFwdRe = new Float32Array(e), this._twiddlesFwdIm = new Float32Array(e), 
            this._twiddlesInvRe = this._twiddlesFwdRe, this._twiddlesInvIm = new Float32Array(e);
            for (var t = 0; t < e; ++t) {
                var n = -2 * Math.PI * t / e, o = Math.cos(n), r = Math.sin(n);
                this._twiddlesFwdRe[t] = o, this._twiddlesFwdIm[t] = r, this._twiddlesInvIm[t] = -r;
            }
            this._factors = new Int32Array(64), l(e, this._factors);
        };
        u.prototype.forwardCplx = function(e, t, n, o) {
            var r = this._twiddlesFwdRe, a = this._twiddlesFwdIm;
            i(e, t, 0, n, o, 0, 1, 1, this._factors, 0, r, a, this.size, !1);
        }, u.prototype.forward = function(e, t, n) {
            this.forwardCplx(e, t, n, new Float32Array(this.size));
        }, u.prototype.inverseCplx = function(e, t, n, o) {
            var r = this._twiddlesInvRe, a = this._twiddlesInvIm;
            i(e, t, 0, n, o, 0, 1, 1, this._factors, 0, r, a, this.size, !0);
        }, u.prototype.inverse = function(e, t, n) {
            this.inverseCplx(e, new Float32Array(this.size), t, n);
        }, e.FFT = u;
    }
}();

var Random = function(e) {
    if ("number" != typeof (e = void 0 === e ? new Date().getTime() : e) || Math.ceil(e) != Math.floor(e)) throw new TypeError("seed value must be an integer");
    this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, 
    this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, 
    this.init_by_array([ e ], 1);
};

Random.prototype.init_genrand = function(e) {
    for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
        var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, 
        this.mt[this.mti] >>>= 0;
    }
}, Random.prototype.init_by_array = function(e, t) {
    var n, o, r;
    for (this.init_genrand(19650218), n = 1, o = 0, r = this.N > t ? this.N : t; r; r--) {
        a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1664525 * ((4294901760 & a) >>> 16) << 16) + 1664525 * (65535 & a)) + e[o] + o, 
        this.mt[n] >>>= 0, o++, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), 
        o >= t && (o = 0);
    }
    for (r = this.N - 1; r; r--) {
        var a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1566083941 * ((4294901760 & a) >>> 16) << 16) + 1566083941 * (65535 & a)) - n, 
        this.mt[n] >>>= 0, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1);
    }
    this.mt[0] = 2147483648;
}, Random.prototype.genrand_int32 = function() {
    var e, t = new Array(0, this.MATRIX_A);
    if (this.mti >= this.N) {
        var n;
        for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[1 & e];
        for (;n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
        e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], 
        this.mti = 0;
    }
    return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, 
    (e ^= e >>> 18) >>> 0;
}, Random.prototype.genrand_int31 = function() {
    return this.genrand_int32() >>> 1;
}, Random.prototype.genrand_real1 = function() {
    return this.genrand_int32() * (1 / 4294967295);
}, Random.prototype.random = function() {
    return this.pythonCompatibility && (this.skip && this.genrand_int32(), this.skip = !0), 
    this.genrand_int32() * (1 / 4294967296);
}, Random.prototype.genrand_real3 = function() {
    return (this.genrand_int32() + .5) * (1 / 4294967296);
}, Random.prototype.genrand_res53 = function() {
    return (67108864 * (this.genrand_int32() >>> 5) + (this.genrand_int32() >>> 6)) * (1 / 9007199254740992);
}, Random.prototype.LOG4 = Math.log(4), Random.prototype.SG_MAGICCONST = 1 + Math.log(4.5), 
Random.prototype.exponential = function(e) {
    if (1 != arguments.length) throw new SyntaxError("exponential() must  be called with 'lambda' parameter");
    var t = this.random();
    return -Math.log(t) / e;
}, Random.prototype.gamma = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("gamma() must be called with alpha and beta parameters");
    if (!(e > 1)) {
        if (1 == e) {
            for (n = this.random(); n <= 1e-7; ) n = this.random();
            return -Math.log(n) * t;
        }
        for (;;) {
            var n = this.random(), o = (Math.E + e) / Math.E, r = o * n;
            if (r <= 1) a = Math.pow(r, 1 / e); else var a = -Math.log((o - r) / e);
            var i = this.random();
            if (r > 1) {
                if (i <= Math.pow(a, e - 1)) break;
            } else if (i <= Math.exp(-a)) break;
        }
        return a * t;
    }
    for (var l = Math.sqrt(2 * e - 1), u = e - this.LOG4, s = e + l; ;) if (!((i = this.random()) < 1e-7 || n > .9999999)) {
        var f = 1 - this.random(), c = Math.log(i / (1 - i)) / l, d = i * i * f, m = u + s * c - (a = e * Math.exp(c));
        if (m + this.SG_MAGICCONST - 4.5 * d >= 0 || m >= Math.log(d)) return a * t;
    }
}, Random.prototype.normal = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("normal() must be called with mu and sigma parameters");
    var n = this.lastNormal;
    if (this.lastNormal = NaN, !n) {
        var o = 2 * this.random() * Math.PI, r = Math.sqrt(-2 * Math.log(1 - this.random()));
        n = Math.cos(o) * r, this.lastNormal = Math.sin(o) * r;
    }
    return e + n * t;
}, Random.prototype.pareto = function(e) {
    if (1 != arguments.length) throw new SyntaxError("pareto() must be called with alpha parameter");
    var t = this.random();
    return 1 / Math.pow(1 - t, 1 / e);
}, Random.prototype.triangular = function(e, t, n) {
    if (3 != arguments.length) throw new SyntaxError("triangular() must be called with lower, upper and mode parameters");
    var o = (n - e) / (t - e), r = this.random();
    return r <= o ? e + Math.sqrt(r * (t - e) * (n - e)) : t - Math.sqrt((1 - r) * (t - e) * (t - n));
}, Random.prototype.uniform = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("uniform() must be called with lower and upper parameters");
    return e + this.random() * (t - e);
}, Random.prototype.weibull = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("weibull() must be called with alpha and beta parameters");
    var n = 1 - this.random();
    return e * Math.pow(-Math.log(n), 1 / t);
}, "undefined" == typeof window && "undefined" != typeof module && module.exports && (module.exports = Random);

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var e = fluid.registerNamespace("jQuery");
    if (flock.fluid = fluid, flock.init = function(e) {
        var t = e ? {
            components: {
                audioSystem: {
                    options: {
                        model: e
                    }
                }
            }
        } : void 0;
        return flock.enviro(t);
    }, flock.ALL_CHANNELS = 32, flock.OUT_UGEN_ID = "flocking-out", flock.PI = Math.PI, 
    flock.TWOPI = 2 * Math.PI, flock.HALFPI = Math.PI / 2, flock.LOG01 = Math.log(.1), 
    flock.LOG001 = Math.log(.001), flock.ROOT2 = Math.sqrt(2), flock.rates = {
        AUDIO: "audio",
        CONTROL: "control",
        SCHEDULED: "scheduled",
        DEMAND: "demand",
        CONSTANT: "constant"
    }, fluid.registerNamespace("flock.debug"), flock.debug.failHard = !0, flock.browser = function() {
        if ("undefined" == typeof navigator) return {};
        var e, t, n = navigator.userAgent.toLowerCase(), o = {};
        return e = /(chrome)[ \/]([\w.]+)/.exec(n) || /(webkit)[ \/]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || [], 
        (t = {
            browser: e[1] || "",
            version: e[2] || "0"
        }).browser && (o[t.browser] = !0, o.version = t.version), o.chrome ? o.webkit = !0 : o.webkit && (o.safari = !0), 
        o;
    }, fluid.registerNamespace("flock.platform"), flock.platform.isBrowser = "undefined" != typeof window, 
    flock.platform.hasRequire = "undefined" != typeof require, flock.platform.os = flock.platform.isBrowser ? window.navigator.platform : require("os").platform(), 
    flock.platform.isLinux = flock.platform.os.indexOf("Linux") > -1, flock.platform.isAndroid = flock.platform.isLinux && flock.platform.os.indexOf("arm") > -1, 
    flock.platform.isIOS = "iPhone" === flock.platform.os || "iPad" === flock.platform.os || "iPod" === flock.platform.os, 
    flock.platform.isMobile = flock.platform.isAndroid || flock.platform.isIOS, flock.platform.browser = flock.browser(), 
    flock.platform.isWebAudio = "undefined" != typeof AudioContext || "undefined" != typeof webkitAudioContext, 
    flock.platform.audioEngine = flock.platform.isBrowser ? "webAudio" : "nodejs", flock.platform.browser && void 0 !== flock.platform.browser.version) {
        var t = flock.platform.browser.version.indexOf(".");
        flock.platform.browser.majorVersionNumber = Number(t < 0 ? flock.platform.browser.version : flock.platform.browser.version.substring(0, t));
    }
    flock.shim = {
        URL: flock.platform.isBrowser ? window.URL || window.webkitURL || window.msURL : void 0
    }, flock.requireModule = function(e, t) {
        if (flock.platform.isBrowser) return window[t || e];
        if (flock.platform.hasRequire) {
            var n = flock.requireModule.paths[e] || e, o = require(n);
            return t ? o[t] : o;
        }
    }, flock.requireModule.paths = {
        webarraymath: "../third-party/webarraymath/js/webarraymath.js",
        Random: "../third-party/simjs/js/random-0.26.js"
    }, flock.noOp = function() {}, flock.isIterable = function(e) {
        var t = typeof e;
        return e && void 0 !== e.length && "string" !== t && "function" !== t;
    }, flock.hasValue = function(e, t) {
        var n = !1;
        for (var o in e) if (e[o] === t) {
            n = !0;
            break;
        }
        return n;
    }, flock.hasTag = function(e, t) {
        return !(!e || !t) && (e.tags && e.tags.indexOf(t) > -1);
    }, flock.randomValue = function(e, t) {
        var n = t - e;
        return Math.random() * n + e;
    }, flock.randomAudioValue = function() {
        return 2 * Math.random() - 1;
    }, flock.fillBuffer = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t(n, e);
        return e;
    }, flock.fillBufferWithValue = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t;
        return e;
    }, flock.generateBuffer = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBuffer(n, t);
    }, flock.generateBufferWithValue = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBufferWithValue(n, t);
    }, flock.generate = function(e, t) {
        var n = "number" == typeof e;
        return ("function" == typeof t ? n ? flock.generateBuffer : flock.fillBuffer : n ? flock.generateBufferWithValue : flock.fillBufferWithValue)(e, t);
    }, flock.generate.silence = function(e) {
        return new Float32Array(e);
    }, flock.clearBuffer = function(e) {
        for (var t = 0; t < e.length; t++) e[t] = 0;
        return e;
    }, flock.reverse = function(e) {
        if (!e || !flock.isIterable(e) || e.length < 2) return e;
        if ("function" == typeof e.reverse) return e.reverse();
        for (var t, n = 0, o = e.length - 1; n < o; n++, o--) t = e[n], e[n] = e[o], e[o] = t;
        return e;
    }, flock.randomIndex = function(e) {
        var t = e.length - 1;
        return Math.round(Math.random() * t);
    }, flock.arrayChoose = function(e, t) {
        return t = t || flock.randomIndex, (e = fluid.makeArray(e))[t(e)];
    }, flock.choose = function(e, t) {
        var n;
        return flock.isIterable(e) ? flock.arrayChoose(e, t) : (n = flock.arrayChoose(e.keys, t), 
        e[n]);
    }, flock.shuffle = function(e) {
        for (var t = e.length - 1; t > 0; t -= 1) {
            var n = Math.floor(Math.random() * (t + 1)), o = e[t];
            e[t] = e[n], e[n] = o;
        }
        return e;
    }, flock.normalize = function(e, t, n) {
        n = n || e;
        var o, r, a, i = 0;
        for (t = void 0 === t ? 1 : t, o = 0; o < e.length; o++) (r = Math.abs(e[o])) > i && (i = r);
        if (i > 0) for (o = 0; o < e.length; o++) a = e[o], n[o] = a / i * t;
        return n;
    }, flock.generateFourierTable = function(e, t, n, o, r) {
        return o *= flock.TWOPI, flock.generateBuffer(e, function(e) {
            var a, i, l, u = 0;
            for (a = 0; a < n; a++) i = r ? r[a] : 1, l = (a + 1) * (e * t), u += i * Math.cos(l + o);
            return u;
        });
    }, flock.generateNormalizedFourierTable = function(e, t, n, o, r) {
        var a = flock.generateBuffer(n, function(e) {
            return r(e + 1);
        }), i = flock.generateFourierTable(e, t, n, o, a);
        return flock.normalize(i);
    }, flock.fillTable = function(e, t) {
        var n = "number" == typeof e ? e : e.length;
        return t(e, flock.TWOPI / n);
    }, flock.tableGenerators = {
        sin: function(e, t) {
            return flock.generateBuffer(e, function(e) {
                return Math.sin(e * t);
            });
        },
        tri: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 1e3, 1, function(e) {
                return e % 2 == 0 ? 0 : 1 / (e * e);
            });
        },
        saw: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return 1 / e;
            });
        },
        square: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return e % 2 == 0 ? 0 : 1 / e;
            });
        },
        hann: function(e) {
            return flock.generateBuffer(e, function(t) {
                var n = Math.sin(Math.PI * t / e);
                return n * n;
            });
        },
        sinWindow: function(e) {
            return flock.generateBuffer(e, function(t) {
                return Math.sin(Math.PI * t / e);
            });
        }
    }, flock.range = function(e) {
        var t, n, o = {
            max: Number.NEGATIVE_INFINITY,
            min: 1 / 0
        };
        for (t = 0; t < e.length; t++) (n = e[t]) > o.max && (o.max = n), n < o.min && (o.min = n);
        return o;
    }, flock.scale = function(e) {
        if (e) {
            var t, n = flock.range(e), o = (n.max - n.min) / 2, r = (n.max + n.min) / 2;
            for (t = 0; t < e.length; t++) e[t] = (e[t] - r) / o;
            return e;
        }
    }, flock.copyBuffer = function(e, t, n) {
        void 0 === n && (n = e.length);
        var o, r, a = n - t, i = new Float32Array(a);
        for (o = t, r = 0; o < n; o++, r++) i[r] = e[o];
        return i;
    }, flock.copyToBuffer = function(e, t) {
        for (var n = Math.min(e.length, t.length), o = 0; o < n; o++) t[o] = e[o];
    }, flock.parseMidiString = function(e) {
        if (!e || e.length < 2) return NaN;
        var t = (e = e.toLowerCase()).charAt(1), n = "#" === t || "b" === t ? 2 : 1, o = e.substring(0, n);
        return 12 * Number(e.substring(n)) + flock.midiFreq.noteNames[o];
    }, flock.midiFreq = function(e, t, n, o) {
        return t = void 0 === t ? 440 : t, n = void 0 === n ? 69 : n, o = o || 12, "string" == typeof e && (e = flock.parseMidiString(e)), 
        t * Math.pow(2, 1 * (e - n) / o);
    }, flock.midiFreq.noteNames = {
        "b#": 0,
        c: 0,
        "c#": 1,
        db: 1,
        d: 2,
        "d#": 3,
        eb: 3,
        e: 4,
        "e#": 5,
        f: 5,
        "f#": 6,
        gb: 6,
        g: 7,
        "g#": 8,
        ab: 8,
        a: 9,
        "a#": 10,
        bb: 10,
        b: 11,
        cb: 11
    }, flock.interpolate = {
        none: function(e, t) {
            return e %= t.length, t[0 | e];
        },
        linear: function(e, t) {
            var n = t.length, o = 0 | (e %= n), r = (o + 1) % n, a = e - o, i = t[o];
            return i + a * (t[r] - i);
        },
        hermite: function(e, t) {
            var n = t.length, o = Math.floor(e), r = o % n, a = e - o, i = (r + 1) % n, l = (r + 2) % n, u = t[r > 0 ? r - 1 : n - 1], s = t[r], f = t[i], c = .5 * (f - u), d = s - f, m = c + d, h = m + d + .5 * (t[l] - s);
            return ((h * a - (m + h)) * a + c) * a + s;
        }
    }, flock.interpolate.cubic = flock.interpolate.hermite, flock.log = {
        fail: function(e) {
            fluid.log(fluid.logLevel.FAIL, e);
        },
        warn: function(e) {
            fluid.log(fluid.logLevel.WARN, e);
        },
        debug: function(e) {
            fluid.log(fluid.logLevel.INFO, e);
        }
    }, flock.fail = function(e) {
        if (flock.debug.failHard) throw new Error(e);
        flock.log.fail(e);
    }, flock.pathParseError = function(e, t, n) {
        var o = "Error parsing path '" + t + "'. Segment '" + n + "' could not be resolved.";
        flock.fail(o);
    }, flock.get = function(e, t) {
        if (!e) return fluid.getGlobalValue(t);
        if (1 === arguments.length && "string" == typeof e) return fluid.getGlobalValue(e);
        if (t && "" !== t) {
            var n, o = "" === t ? [] : String(t).split("."), r = e[o[0]];
            for (n = 1; n < o.length; n++) {
                if (null === r || void 0 === r) return void flock.pathParseError(e, t, o[n - 1]);
                r = r[o[n]];
            }
            return r;
        }
    }, flock.set = function(e, t, n) {
        if (e && t && "" !== t) {
            var o, r = String(t).split("."), a = r.length, i = r[0];
            for (o = 1; o < a; o++) {
                if (e = e[i], "object" !== typeof e) return void flock.fail("Error while setting a value at path '" + t + "'. A non-container object was found at segment '" + i + "'. Value: " + e);
                void 0 === e[i = r[o]] && (e[i] = {});
            }
            return e[i] = n, n;
        }
    }, flock.invoke = function(e, t, n) {
        var o = "function" == typeof e ? e : flock.get(e, t);
        {
            if ("function" == typeof o) return o.apply(null, n);
            flock.fail("Path '" + t + "' does not resolve to a function.");
        }
    }, flock.input = {}, flock.input.shouldExpand = function(e) {
        return flock.parse.specialInputs.indexOf(e) < 0;
    }, flock.input.pathExpander = function(e) {
        var t, n = fluid.model.parseEL(e), o = n.length - 1, r = [];
        for (t = 0; t < o; t++) {
            var a = n[t], i = n[t + 1];
            if (r.push(a), "model" === i || "options" === i) {
                r = r.concat(n.slice(t + 1, o));
                break;
            }
            isNaN(Number(i)) && r.push("inputs");
        }
        return r.push(n[o]), r.join(".");
    }, flock.input.expandPaths = function(e) {
        var t, n, o, r = {};
        for (t in e) n = flock.input.pathExpander(t), o = e[t], r[n] = o;
        return r;
    }, flock.input.expandPath = function(e) {
        return "string" == typeof e ? flock.input.pathExpander(e) : flock.input.expandPaths(e);
    }, flock.input.getValueForPath = function(e, t) {
        t = flock.input.expandPath(t);
        var n = flock.get(e, t);
        return flock.hasTag(n, "flock.ugen.valueType") ? n.inputs.value : n;
    }, flock.input.getValuesForPathArray = function(e, t) {
        var n, o, r = {};
        for (n = 0; n < t.length; n++) r[o = t[n]] = flock.input.get(e, o);
        return r;
    }, flock.input.getValuesForPathObject = function(e, t) {
        var n;
        for (n in t) t[n] = flock.input.get(e, n);
        return t;
    }, flock.input.get = function(e, t) {
        return "string" == typeof t ? flock.input.getValueForPath(e, t) : flock.isIterable(t) ? flock.input.getValuesForPathArray(e, t) : flock.input.getValuesForPathObject(e, t);
    }, flock.input.resolveValue = function(e, t, n, o, r, a, i) {
        if ("string" == typeof n) {
            var l = fluid.extractEL(n, flock.input.valueExpressionSpec);
            if (l) {
                var u = flock.input.getValueForPath(e, l);
                return void 0 === u && flock.log.debug("The value expression '" + n + "' resolved to undefined. If this isn't expected, check to ensure that your path is valid."), 
                u;
            }
        }
        return flock.input.shouldExpand(r) && i ? i(n, t, o, a) : n;
    }, flock.input.valueExpressionSpec = {
        ELstyle: "${}"
    }, flock.input.setValueForPath = function(e, t, n, o, r) {
        t = flock.input.expandPath(t);
        var a = flock.get(e, t), i = t.lastIndexOf("."), l = t.slice(i + 1), u = i > -1 ? flock.get(e, t.slice(0, t.lastIndexOf(".inputs"))) : o, s = flock.input.resolveValue(e, t, n, u, l, a, r);
        return flock.set(e, t, s), u && u.onInputChanged && u.onInputChanged(l), s;
    }, flock.input.setValuesForPaths = function(e, t, n, o) {
        var r, a, i, l = {};
        for (r in t) a = t[r], i = flock.input.set(e, r, a, n, o), l[r] = i;
        return l;
    }, flock.input.set = function(e, t, n, o, r) {
        return "string" == typeof t ? flock.input.setValueForPath(e, t, n, o, r) : flock.input.setValuesForPaths(e, t, o, r);
    }, fluid.defaults("flock.audioSystem", {
        gradeNames: [ "fluid.modelComponent" ],
        channelRange: {
            min: 1,
            max: 32
        },
        outputBusRange: {
            min: 2,
            max: 1024
        },
        inputBusRange: {
            min: 1,
            max: 32
        },
        model: {
            rates: {
                audio: 44100,
                control: 689.0625,
                scheduled: 0,
                demand: 0,
                constant: 0
            },
            blockSize: 64,
            numBlocks: 16,
            chans: 2,
            numInputBuses: 2,
            numBuses: 8,
            bufferSize: "@expand:flock.audioSystem.defaultBufferSize()"
        },
        modelRelay: [ {
            target: "rates.control",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.rates.audio",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "numBlocks",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.bufferSize",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "chans",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.chans",
                min: "{that}.options.channelRange.min",
                max: "{that}.options.channelRange.max"
            }
        }, {
            target: "numInputBuses",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.numInputBuses",
                min: "{that}.options.inputBusRange.min",
                max: "{that}.options.inputBusRange.max"
            }
        }, {
            target: "numBuses",
            singleTransform: {
                type: "fluid.transforms.free",
                func: "flock.audioSystem.clampNumBuses",
                args: [ "{that}.model.numBuses", "{that}.options.outputBusRange", "{that}.model.chans" ]
            }
        } ]
    }), flock.audioSystem.clampNumBuses = function(e, t, n) {
        return e = Math.max(e, Math.max(n, t.min)), e = Math.min(e, t.max);
    }, flock.audioSystem.defaultBufferSize = function() {
        return flock.platform.isMobile ? 8192 : flock.platform.browser.mozilla ? 2048 : 1024;
    }, fluid.defaults("flock.busManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            nextAvailableBus: {
                input: 0,
                interconnect: 0
            }
        },
        members: {
            buses: {
                expander: {
                    funcName: "flock.enviro.createAudioBuffers",
                    args: [ "{audioSystem}.model.numBuses", "{audioSystem}.model.blockSize" ]
                }
            }
        },
        invokers: {
            acquireNextBus: {
                funcName: "flock.busManager.acquireNextBus",
                args: [ "{arguments}.0", "{that}.buses", "{that}.applier", "{that}.model", "{audioSystem}.model.chans", "{audioSystem}.model.numInputBuses" ]
            },
            reset: {
                changePath: "nextAvailableBus",
                value: {
                    input: 0,
                    interconnect: 0
                }
            }
        },
        listeners: {
            "onDestroy.reset": "{that}.reset()"
        }
    }), flock.busManager.acquireNextBus = function(e, t, n, o, r, a) {
        var i = o.nextAvailableBus[e];
        if (void 0 !== i) {
            var l = i + r, u = r + a;
            if ("interconnect" === e && (l += a, u = t.length), !(l >= u)) return n.change("nextAvailableBus." + e, ++i), 
            l;
            flock.fail("Unable to aquire a bus. There are insufficient buses available. Please use an existing bus or configure additional buses using the enviroment's numBuses and numInputBuses parameters.");
        } else flock.fail("An invalid bus type was specified when invoking flock.busManager.acquireNextBus(). Type was: " + e);
    }, fluid.defaults("flock.outputManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            audioSettings: "{audioSystem}.model"
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            stop: "{that}.events.onStop.fire()",
            reset: "{that}.events.onReset.fire"
        },
        events: {
            onStart: "{enviro}.events.onStart",
            onStop: "{enviro}.events.onStop",
            onReset: "{enviro}.events.onReset"
        }
    }), fluid.defaults("flock.nodeListComponent", {
        gradeNames: "fluid.component",
        members: {
            nodeList: "@expand:flock.nodeList()"
        },
        invokers: {
            insert: "flock.nodeList.insert({that}.nodeList, {arguments}.0, {arguments}.1)",
            head: "flock.nodeList.head({that}.nodeList, {arguments}.0)",
            tail: "flock.nodeList.tail({that}.nodeList, {arguments}.0)",
            before: "flock.nodeList.before({that}.nodeList, {arguments}.0, {arguments}.1)",
            after: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)",
            remove: "flock.nodeList.remove({that}.nodeList, {arguments}.0)",
            replace: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)"
        }
    }), fluid.defaults("flock.enviro", {
        gradeNames: [ "fluid.modelComponent", "flock.nodeListComponent", "fluid.resolveRootSingle" ],
        singleRootType: "flock.enviro",
        isGlobalSingleton: !0,
        members: {
            buffers: {},
            bufferSources: {}
        },
        components: {
            asyncScheduler: {
                type: "flock.scheduler.async"
            },
            audioSystem: {
                type: "flock.audioSystem"
            },
            busManager: {
                type: "flock.busManager"
            }
        },
        model: {
            isPlaying: !1
        },
        invokers: {
            gen: {
                funcName: "flock.enviro.gen",
                args: [ "{busManager}.buses", "{audioSystem}.model", "{that}.nodeList.nodes" ]
            },
            start: "flock.enviro.start({that}.model, {that}.events.onStart.fire)",
            play: "{that}.start",
            stop: "flock.enviro.stop({that}.model, {that}.events.onStop.fire)",
            reset: "{that}.events.onReset.fire()",
            registerBuffer: "flock.enviro.registerBuffer({arguments}.0, {that}.buffers)",
            releaseBuffer: "flock.enviro.releaseBuffer({arguments}.0, {that}.buffers)",
            saveBuffer: {
                funcName: "flock.enviro.saveBuffer",
                args: [ "{arguments}.0", "{that}.buffers", "{audioSystem}" ]
            }
        },
        events: {
            onStart: null,
            onPlay: "{that}.events.onStart",
            onStop: null,
            onReset: null
        },
        listeners: {
            onCreate: [ "flock.enviro.registerGlobalSingleton({that})" ],
            onStart: [ "{that}.applier.change(isPlaying, true)" ],
            onStop: [ "{that}.applier.change(isPlaying, false)" ],
            onReset: [ "{that}.stop()", "{asyncScheduler}.clearAll()", "flock.nodeList.clearAll({that}.nodeList)", "{busManager}.reset()", "fluid.clear({that}.buffers)" ]
        }
    }), flock.enviro.registerGlobalSingleton = function(e) {
        e.options.isGlobalSingleton && (flock.environment = flock.enviro.shared = e);
    }, flock.enviro.registerBuffer = function(e, t) {
        e.id && (t[e.id] = e);
    }, flock.enviro.releaseBuffer = function(e, t) {
        e && delete t["string" == typeof e ? e : e.id];
    }, flock.enviro.saveBuffer = function(e, t, n) {
        if ("string" == typeof e && (e = {
            buffer: e
        }), "string" == typeof e.buffer) {
            var o = e.buffer;
            e.buffer = t[o], e.buffer.id = o;
        }
        return e.type = e.type || "wav", e.path = e.path || e.buffer.id + "." + e.type, 
        e.format = e.format || "int16", n.bufferWriter.save(e, e.buffer);
    }, flock.enviro.gen = function(e, t, n) {
        flock.evaluate.clearBuses(e, t.numBuses, t.blockSize), flock.evaluate.synths(n);
    }, flock.enviro.start = function(e, t) {
        e.isPlaying || t();
    }, flock.enviro.stop = function(e, t) {
        e.isPlaying && t();
    }, flock.enviro.createAudioBuffers = function(e, t) {
        var n, o = [];
        for (n = 0; n < e; n++) o[n] = new Float32Array(t);
        return o;
    }, fluid.defaults("flock.autoEnviro", {
        gradeNames: [ "fluid.component" ],
        members: {
            enviro: "@expand:flock.autoEnviro.initEnvironment()"
        }
    }), flock.autoEnviro.initEnvironment = function() {
        return flock.environment ? flock.environment : flock.init();
    }, fluid.defaults("flock.silentEnviro", {
        gradeNames: "flock.enviro",
        listeners: {
            onCreate: [ "flock.silentEnviro.insertOutputGainNode({that})" ]
        }
    }), flock.silentEnviro.insertOutputGainNode = function(e) {
        e.audioSystem.nativeNodeManager && e.audioSystem.nativeNodeManager.createOutputNode({
            node: "Gain",
            params: {
                gain: 0
            }
        });
    }, fluid.defaults("flock.node", {
        gradeNames: [ "flock.autoEnviro", "fluid.modelComponent" ],
        addToEnvironment: "tail",
        model: {},
        components: {
            enviro: "{flock.enviro}"
        },
        invokers: {
            play: {
                funcName: "flock.node.play",
                args: [ "{that}", "{that}.enviro", "{that}.addToEnvironment" ]
            },
            pause: "{that}.removeFromEnvironment()",
            addToEnvironment: {
                funcName: "flock.node.addToEnvironment",
                args: [ "{that}", "{arguments}.0", "{that}.enviro.nodeList" ]
            },
            removeFromEnvironment: {
                funcName: "flock.node.removeFromEnvironment",
                args: [ "{that}", "{that}.enviro.nodeList" ]
            },
            isPlaying: {
                funcName: "flock.nodeList.isNodeActive",
                args: [ "{that}.enviro.nodeList", "{that}" ]
            }
        },
        listeners: {
            onCreate: [ "{that}.addToEnvironment({that}.options.addToEnvironment)" ],
            onDestroy: [ "{that}.removeFromEnvironment()" ]
        }
    }), flock.node.addToEnvironment = function(e, t, n) {
        if (void 0 === t && (t = e.options.addToEnvironment), void 0 !== t && null !== t && !1 !== t) {
            var o = typeof t;
            "string" === o && "head" === t || "tail" === t ? flock.nodeList[t](n, e) : "number" === o ? flock.nodeList.insert(n, e, t) : flock.nodeList.tail(n, e);
        }
    }, flock.node.removeFromEnvironment = function(e, t) {
        flock.nodeList.remove(t, e);
    }, flock.node.play = function(e, t, n) {
        -1 === t.nodeList.nodes.indexOf(e) && n(e.options.addToEnvironment || "tail"), t.model.isPlaying || t.play();
    }, fluid.defaults("flock.noteTarget", {
        gradeNames: "fluid.component",
        noteChanges: {
            on: {
                "env.gate": 1
            },
            off: {
                "env.gate": 0
            }
        },
        invokers: {
            set: {
                funcName: "fluid.notImplemented"
            },
            noteOn: {
                func: "{that}.events.noteOn.fire"
            },
            noteOff: {
                func: "{that}.events.noteOff.fire"
            },
            noteChange: {
                funcName: "flock.noteTarget.change",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            }
        },
        events: {
            noteOn: null,
            noteOff: null
        },
        listeners: {
            "noteOn.handleChange": [ "{that}.noteChange(on, {arguments}.0)" ],
            "noteOff.handleChange": [ "{that}.noteChange(off, {arguments}.0)" ]
        }
    }), flock.noteTarget.change = function(t, n, o) {
        var r = t.options.noteChanges[n], a = e.extend({}, r, o);
        t.set(a);
    }, fluid.defaults("flock.synth", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        rate: flock.rates.AUDIO,
        addToEnvironment: !0,
        mergePolicy: {
            ugens: "nomerge"
        },
        ugens: {
            expander: {
                funcName: "flock.makeUGens",
                args: [ "{that}.options.synthDef", "{that}.rate", "{that}.nodeList", "{that}.enviro", "{that}.audioSettings" ]
            }
        },
        members: {
            rate: "{that}.options.rate",
            audioSettings: "{that}.enviro.audioSystem.model",
            nodeList: "@expand:flock.nodeList()",
            out: "{that}.options.ugens",
            genFn: "@expand:fluid.getGlobalValue(flock.evaluate.ugens)"
        },
        model: {
            blockSize: "@expand:flock.synth.calcBlockSize({that}.rate, {that}.enviro.audioSystem.model)"
        },
        invokers: {
            set: {
                funcName: "flock.synth.set",
                args: [ "{that}", "{that}.nodeList.namedNodes", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            get: {
                funcName: "flock.input.get",
                args: [ "{that}.nodeList.namedNodes", "{arguments}.0" ]
            },
            input: {
                funcName: "flock.synth.input",
                args: [ "{arguments}", "{that}.get", "{that}.set" ]
            }
        }
    }), flock.synth.createUGenTree = function(e, t, n) {
        return new flock.UGenTree(e, t, n);
    }, flock.synth.calcBlockSize = function(e, t) {
        return e === flock.rates.AUDIO ? t.blockSize : 1;
    }, flock.synth.set = function(e, t, n, o, r) {
        return flock.input.set(t, n, o, void 0, function(t, n, o, a) {
            return flock.synth.ugenValueParser(e, t, a, r);
        });
    }, flock.synth.input = function(e, t, n) {
        var o = e[0];
        return o ? "string" == typeof o ? e.length < 2 ? t(o) : n.apply(null, e) : flock.isIterable(o) ? t(o) : n.apply(null, e) : void 0;
    }, flock.synth.ugenValueParser = function(e, t, n, o) {
        if (null === t || void 0 === t) return n;
        var r, a, i, l = flock.parse.ugenDef(t, e.enviro, {
            audioSettings: e.audioSettings,
            buses: e.enviro.busManager.buses,
            buffers: e.enviro.buffers
        }), u = flock.isIterable(l) ? l : void 0 !== l ? [ l ] : [], s = flock.isIterable(n) ? n : void 0 !== n ? [ n ] : [], f = Math.min(u.length, s.length), c = o ? "swapTree" : "replaceTree";
        for (r = 0; r < f; r++) a = flock.ugenNodeList[c](e.nodeList, u[r], s[r]);
        for (i = r; i < u.length; i++) a++, flock.ugenNodeList.insertTree(e.nodeList, u[i], a);
        for (i = r; i < s.length; i++) flock.ugenNodeList.removeTree(e.nodeList, s[i]);
        return l;
    }, fluid.defaults("flock.synth.value", {
        gradeNames: [ "flock.synth" ],
        rate: "demand",
        addToEnvironment: !1,
        invokers: {
            value: {
                funcName: "flock.evaluate.synthValue",
                args: [ "{that}" ]
            }
        }
    }), fluid.defaults("flock.synth.frameRate", {
        gradeNames: [ "flock.synth.value" ],
        rate: "scheduled",
        fps: 60,
        members: {
            audioSettings: {
                rates: {
                    scheduled: "{that}.options.fps"
                }
            }
        }
    }), flock.bufferDesc = function() {
        throw new Error("flock.bufferDesc is not defined. Did you forget to include the buffers.js file?");
    };
}();

var fluid = fluid || require("infusion");

(flock = fluid.registerNamespace("flock")).nodeList = function() {
    return {
        nodes: [],
        namedNodes: {}
    };
}, flock.nodeList.insert = function(e, t, n) {
    return n < 0 && (n = 0), e.nodes.splice(n, 0, t), flock.nodeList.registerNode(e, t), 
    n;
}, flock.nodeList.registerNode = function(e, t) {
    var n = t.name || t.id;
    n && (e.namedNodes[n] = t);
}, flock.nodeList.head = function(e, t) {
    return flock.nodeList.insert(e, t, 0);
}, flock.nodeList.before = function(e, t, n) {
    var o = e.nodes.indexOf(n);
    return flock.nodeList.insert(e, t, o);
}, flock.nodeList.after = function(e, t, n) {
    var o = e.nodes.indexOf(n) + 1;
    return flock.nodeList.insert(e, t, o);
}, flock.nodeList.tail = function(e, t) {
    var n = e.nodes.length;
    return flock.nodeList.insert(e, t, n);
}, flock.nodeList.unregisterNode = function(e, t) {
    var n = t.name || t.id;
    n && delete e.namedNodes[n];
}, flock.nodeList.isNodeActive = function(e, t) {
    return e.nodes.indexOf(t) > -1;
}, flock.nodeList.remove = function(e, t) {
    if (e) {
        var n = e.nodes.indexOf(t);
        return n > -1 && (e.nodes.splice(n, 1), flock.nodeList.unregisterNode(e, t)), n;
    }
}, flock.nodeList.replace = function(e, t, n) {
    var o = e.nodes.indexOf(n);
    return o < 0 ? flock.nodeList.tail(e, t) : (e.nodes[o] = t, flock.nodeList.unregisterNode(e, n), 
    flock.nodeList.registerNode(e, t), o);
}, flock.nodeList.clearAll = function(e) {
    e.nodes.length = 0;
    for (var t in e.namedNodes) delete e.namedNodes[t];
}, flock.ugenNodeList = function() {
    return flock.nodeList();
}, flock.ugenNodeList.insertTree = function(e, t, n) {
    var o, r, a = t.inputs;
    for (o in a) r = a[o], flock.isUGen(r) && (n = flock.ugenNodeList.insertTree(e, r, n), 
    n++);
    return flock.nodeList.insert(e, t, n);
}, flock.ugenNodeList.removeTree = function(e, t) {
    var n, o, r = t.inputs;
    for (n in r) o = r[n], flock.isUGen(o) && flock.ugenNodeList.removeTree(e, o);
    return flock.nodeList.remove(e, t);
}, flock.ugenNodeList.tailTree = function(e, t) {
    var n = e.nodes.length;
    return flock.ugenNodeList.insertTree(e, t, n);
}, flock.ugenNodeList.replaceTree = function(e, t, n) {
    if (!n) return flock.ugenNodeList.tailTree(e, t);
    var o = flock.ugenNodeList.removeTree(e, n);
    return flock.ugenNodeList.insertTree(e, t, o), o;
}, flock.ugenNodeList.swapTree = function(e, t, n, o) {
    return o ? (flock.ugenNodeList.reattachInputs(e, t, n, o), flock.ugenNodeList.replaceInputs(e, t, n, o)) : t.inputs = n.inputs, 
    flock.nodeList.replace(e, t, n);
}, flock.ugenNodeList.reattachInputs = function(e, t, n, o) {
    for (var r in n.inputs) o.indexOf(r) < 0 ? flock.ugenNodeList.removeTree(e, n.inputs[r]) : t.inputs[r] = n.inputs[r];
}, flock.ugenNodeList.replaceInputs = function(e, t, n, o) {
    for (var r in t.inputs) o.indexOf(r) < 0 && flock.ugenNodeList.replaceTree(e, t.inputs[r], n.inputs[r]);
}, flock.makeUGens = function(e, t, n, o, r) {
    e || fluid.log(fluid.logLevel.IMPORTANT, "Warning: An empy synthDef was found while instantiating a unit generator tree.Did you forget to include a 'synthDef' option for your Synth?");
    var a = t === flock.rates.SCHEDULED || t === flock.rates.DEMAND;
    return flock.parse.synthDef(e, o, {
        rate: t,
        overrideRate: a,
        visitors: [ flock.makeUGens.visitor(n) ],
        buffers: o.buffers,
        buses: o.busManager.buses,
        audioSettings: r || o.audioSystem.model
    });
}, flock.makeUGens.visitor = function(e) {
    return function(t) {
        flock.nodeList.tail(e, t);
    };
};

var fluid = fluid || require("infusion");

(flock = fluid.registerNamespace("flock")).evaluate = {
    synth: function(e) {
        e.genFn(e.nodeList.nodes), e.out && (e.model.value = e.out.model.value);
    },
    synthValue: function(e) {
        return flock.evaluate.synth(e), e.model.value;
    },
    synths: function(e) {
        for (var t = 0; t < e.length; t++) flock.evaluate.synth(e[t]);
    },
    clearBuses: function(e, t, n) {
        for (var o = 0; o < t; o++) for (var r = e[o], a = 0; a < n; a++) r[a] = 0;
    },
    ugens: function(e) {
        for (var t, n = 0; n < e.length; n++) void 0 !== (t = e[n]).gen && t.gen(t.model.blockSize);
    }
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.modelSynth", {
    gradeNames: "flock.synth",
    model: {
        inputs: {}
    },
    modelListeners: {
        inputs: [ {
            funcName: "flock.modelSynth.updateUGens",
            args: [ "{that}.set", "{that}.options.ugens", "{change}" ]
        } ]
    },
    invokers: {
        value: "{that}.events.onEvaluate.fire()"
    },
    events: {
        onEvaluate: null
    },
    listeners: {
        onEvaluate: [ "{that}.genFn({that}.nodeList.nodes)", {
            changePath: "value",
            value: "{that}.out.model.value"
        } ]
    }
}), flock.modelSynth.updateUGens = function(e, t, n) {
    var o = {};
    flock.modelSynth.flattenModel("", n.value, o), e(o);
}, flock.modelSynth.shouldFlattenValue = function(e) {
    return fluid.isPrimitive(e) || flock.isIterable(e) || e.ugen;
}, flock.modelSynth.flattenModel = function(e, t, n) {
    for (var o in t) {
        var r = t[o], a = fluid.pathUtil.composePath(e, o.toString());
        flock.modelSynth.shouldFlattenValue(r) ? n[a] = r : flock.modelSynth.flattenModel(a, r, n);
    }
    return n;
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.synth.group", {
    gradeNames: [ "flock.node", "flock.noteTarget" ],
    methodEventMap: {
        onSet: "set"
    },
    members: {
        nodeList: "@expand:flock.nodeList()",
        genFn: "@expand:fluid.getGlobalValue(flock.evaluate.synths)"
    },
    invokers: {
        play: "{that}.events.onPlay.fire",
        pause: "{that}.events.onPause.fire",
        set: "{that}.events.onSet.fire",
        get: "flock.synth.group.get({arguments}, {that}.nodeList.nodes)",
        head: "flock.synth.group.head({arguments}.0, {that})",
        tail: "flock.synth.group.tail({arguments}.0, {that})",
        insert: "flock.synth.group.insert({arguments}.0, {arguments}.1, {that})",
        before: "flock.synth.group.before({arguments}.0, {arguments}.1, {that})",
        after: "flock.synth.group.after({arguments}.0, {arguments}.1, {that})",
        remove: "{that}.events.onRemove.fire",
        input: {
            funcName: "flock.synth.group.input",
            args: [ "{arguments}", "{that}.get", "{that}.events.onSet.fire" ]
        }
    },
    events: {
        onSet: null,
        onGen: null,
        onPlay: null,
        onPause: null,
        onInsert: null,
        onRemove: null
    },
    listeners: {
        onInsert: [ {
            funcName: "flock.synth.group.bindMethods",
            args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "addListener" ]
        }, "flock.synth.group.removeNodeFromEnvironment({arguments}.0)" ],
        onRemove: [ {
            funcName: "flock.synth.group.bindMethods",
            args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "removeListener" ]
        }, {
            this: "{that}.nodeList",
            method: "remove",
            args: [ "{arguments}.0" ]
        } ]
    }
}), flock.synth.group.head = function(e, t) {
    flock.nodeList.head(t.nodeList, e), t.events.onInsert.fire(e);
}, flock.synth.group.tail = function(e, t) {
    flock.nodeList.tail(t.nodeList, e), t.events.onInsert.fire(e);
}, flock.synth.group.insert = function(e, t, n) {
    flock.nodeList.insert(n.nodeList, e, t), n.events.onInsert.fire(e);
}, flock.synth.group.before = function(e, t, n) {
    flock.nodeList.before(n.nodeList, e, t), n.events.onInsert.fire(e);
}, flock.synth.group.after = function(e, t, n) {
    flock.nodeList.after(n.nodeList, e, t), n.events.onInsert.fire(e);
}, flock.synth.group.removeNodeFromEnvironment = function(e) {
    e.removeFromEnvironment();
}, flock.synth.group.get = function(e, t) {
    var n = t[t.length - 1];
    return n.get.apply(n, e);
}, flock.synth.group.input = function(e, t, n) {
    return (e.length > 1 ? n : t).apply(null, e);
}, flock.synth.group.bindMethods = function(e, t, n, o) {
    for (var r in t) {
        var a = e[t[r]];
        (0, n[r][o])(a);
    }
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var e = fluid.registerNamespace("jQuery");
    fluid.defaults("flock.synth.polyphonic", {
        gradeNames: [ "flock.synth.group" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        noteSpecs: "{that}.options.noteChanges",
        distributeOptions: {
            source: "{that}.options.voiceAllocatorOptions",
            target: "{that flock.synth.voiceAllocator}.options",
            removeSource: !0
        },
        voiceAllocatorOptions: {
            synthDef: "{polyphonic}.options.synthDef",
            maxVoices: "{polyphonic}.options.maxVoices",
            amplitudeNormalizer: "{polyphonic}.options.amplitudeNormalizer",
            amplitudeKey: "{polyphonic}.options.amplitudeKey",
            listeners: {
                onCreateVoice: {
                    funcName: "flock.nodeList.tail",
                    args: [ "{polyphonic}.nodeList", "{arguments}.0" ]
                }
            }
        },
        components: {
            voiceAllocator: {
                type: "flock.synth.voiceAllocator.lazy"
            }
        },
        invokers: {
            noteChange: {
                funcName: "flock.synth.polyphonic.noteChange",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            createVoice: {
                func: "{voiceAllocator}.createVoice",
                args: [ "{that}.options", "{that}.insert" ]
            }
        },
        listeners: {
            "noteOn.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOn",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ],
            "noteOff.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOff",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ]
        }
    }), flock.synth.polyphonic.noteChange = function(t, n, o, r) {
        var a = t.options.noteChanges[n], i = e.extend({}, a, r);
        o.set(i);
    }, flock.synth.polyphonic.noteOn = function(e, t, n) {
        var o = e.voiceAllocator.getFreeVoice();
        return e.voiceAllocator.activeVoices[t] && e.noteOff(t), e.voiceAllocator.activeVoices[t] = o, 
        e.noteChange("on", o, n), o;
    }, flock.synth.polyphonic.noteOff = function(e, t, n) {
        var o = e.voiceAllocator.activeVoices[t];
        return o ? (e.noteChange("off", o, n), delete e.voiceAllocator.activeVoices[t], 
        e.voiceAllocator.freeVoices.push(o), o) : null;
    }, fluid.defaults("flock.synth.voiceAllocator", {
        gradeNames: [ "fluid.component" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        members: {
            activeVoices: {},
            freeVoices: []
        },
        invokers: {
            createVoice: {
                funcName: "flock.synth.voiceAllocator.createVoice",
                args: [ "{that}.options", "{that}.events.onCreateVoice.fire" ]
            }
        },
        events: {
            onCreateVoice: null
        }
    }), flock.synth.voiceAllocator.createVoice = function(e, t) {
        var n, o = flock.synth({
            synthDef: e.synthDef,
            addToEnvironment: !1
        }), r = e.amplitudeNormalizer, a = e.amplitudeKey;
        return r && ("function" == typeof r ? r(o, a) : "static" === r && (n = 1 / e.maxVoices, 
        o.input(a, n))), t(o), o;
    }, fluid.defaults("flock.synth.voiceAllocator.lazy", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: {
                funcName: "flock.synth.voiceAllocator.lazy.get",
                args: [ "{that}.freeVoices", "{that}.activeVoices", "{that}.createVoice", "{that}.options.maxVoices" ]
            }
        }
    }), flock.synth.voiceAllocator.lazy.get = function(e, t, n, o) {
        return e.length > 1 ? e.pop() : Object.keys(t).length > o ? null : n();
    }, fluid.defaults("flock.synth.voiceAllocator.pool", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: "flock.synth.voiceAllocator.pool.get({that}.freeVoices)"
        }
    }), flock.synth.voiceAllocator.pool.get = function(e) {
        if (e.length > 0) return e.pop();
    }, flock.synth.voiceAllocator.pool.allocateVoices = function(e, t, n) {
        for (var o = 0; o < n; o++) e[o] = t();
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.band", {
    gradeNames: [ "fluid.component" ],
    synthGrade: "flock.noteTarget",
    invokers: {
        play: {
            func: "{that}.events.onPlay.fire"
        },
        pause: {
            func: "{that}.events.onPause.fire"
        },
        set: {
            func: "{that}.events.onSet.fire"
        },
        getSynths: {
            funcName: "fluid.queryIoCSelector",
            args: [ "{that}", "{that}.options.synthGrade" ]
        }
    },
    events: {
        onPlay: null,
        onPause: null,
        onSet: null
    },
    distributeOptions: [ {
        source: "{that}.options.synthListeners",
        removeSource: !0,
        target: "{that flock.synth}.options.listeners"
    } ],
    synthListeners: {
        "{band}.events.onPlay": {
            func: "{that}.play"
        },
        "{band}.events.onPause": {
            func: "{that}.pause"
        },
        "{band}.events.onSet": {
            func: "{that}.set"
        }
    }
});

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    function e() {
        function e(e, n) {
            o.value = n, o.then = "reject" === e ? function(e, t) {
                return t(n), this;
            } : function(e) {
                return e(n), this;
            }, o.resolve = o.reject = function() {
                throw new Error("Promise already completed");
            }, t(e, n);
        }
        function t(e, t) {
            var o, r;
            for (o = 0; o < n.length; o++) (r = n[o])[e] && r[e](t);
            n = null;
        }
        var n = [], o = {
            state: "pending",
            value: void 0,
            resolve: function(t) {
                e("resolve", t), o.state = "fulfilled";
            },
            reject: function(t) {
                e("reject", t), o.state = "rejected";
            },
            then: function(e, t) {
                return n ? n.push({
                    resolve: e,
                    reject: t
                }) : ("fulfilled" === o.state ? e : t)(o.value), this;
            },
            safe: {
                then: function(e, t) {
                    return o.then(e, t), this;
                }
            }
        };
        return o;
    }
    fluid.defaults("flock.promise", {
        gradeNames: [ "fluid.component" ],
        members: {
            promise: {
                expander: {
                    funcName: "flock.promise.make"
                }
            }
        }
    }), flock.promise.make = function() {
        return new e();
    }, flock.bufferDesc = function(e, t, n) {
        return (flock.platform.isWebAudio && e instanceof AudioBuffer ? flock.bufferDesc.fromAudioBuffer : flock.isIterable(e) ? flock.bufferDesc.fromChannelArray : flock.bufferDesc.expand)(e, t, n);
    }, flock.bufferDesc.inferFormat = function(e, t, n) {
        var o = e.format, r = e.data;
        return o.sampleRate = t || o.sampleRate || 44100, o.numChannels = n || o.numChannels || e.data.channels.length, 
        o.numSampleFrames = o.numSampleFrames || r.channels.length > 0 ? r.channels[0].length : 0, 
        o.duration = o.numSampleFrames / o.sampleRate, e;
    }, flock.bufferDesc.fromChannelArray = function(e, t, n) {
        e instanceof Float32Array && (e = [ e ]);
        var o = {
            container: {},
            format: {
                numChannels: n,
                sampleRate: t,
                numSampleFrames: e[0].length
            },
            data: {
                channels: e
            }
        };
        return flock.bufferDesc.inferFormat(o, t, n);
    }, flock.bufferDesc.expand = function(e, t, n) {
        if (e = e || {
            data: {
                channels: []
            }
        }, e.container = e.container || {}, e.format = e.format || {}, e.format.numChannels = n || e.format.numChannels || e.data.channels.length, 
        e.data && e.data.channels && (1 === e.format.numChannels && 1 !== e.data.channels.length && (e.data.channels = [ e.data.channels ]), 
        e.format.numChannels !== e.data.channels.length)) throw new Error("The specified number of channels does not match the actual channel data. numChannels was: " + e.format.numChannels + " but the sample data contains " + e.data.channels.length + " channels.");
        return flock.bufferDesc.inferFormat(e, t, n);
    }, flock.bufferDesc.fromAudioBuffer = function(e) {
        var t, n = {
            container: {},
            format: {
                sampleRate: e.sampleRate,
                numChannels: e.numberOfChannels,
                numSampleFrames: e.length,
                duration: e.duration
            },
            data: {
                channels: []
            }
        };
        for (t = 0; t < e.numberOfChannels; t++) n.data.channels.push(e.getChannelData(t));
        return n;
    }, flock.bufferDesc.toAudioBuffer = function(e, t) {
        for (var n = e.createBuffer(t.format.numChannels, t.format.numSampleFrames, t.format.sampleRate), o = 0; o < t.format.numChannels; o++) n.copyToChannel(t.data.channels[o], o);
        return n;
    }, fluid.defaults("flock.bufferSource", {
        gradeNames: [ "fluid.modelComponent" ],
        sampleRate: "{enviro}.audioSystem.model.sampleRate",
        model: {
            state: "start",
            src: null
        },
        components: {
            bufferPromise: {
                createOnEvent: "onRefreshPromise",
                type: "flock.promise",
                options: {
                    listeners: {
                        onCreate: {
                            this: "{that}.promise",
                            method: "then",
                            args: [ "{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire" ]
                        }
                    }
                }
            }
        },
        invokers: {
            get: {
                funcName: "flock.bufferSource.get",
                args: [ "{that}", "{arguments}.0" ]
            },
            set: {
                funcName: "flock.bufferSource.set",
                args: [ "{that}", "{arguments}.0" ]
            },
            error: {
                funcName: "flock.bufferSource.error",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                funcName: "{that}.events.onRefreshPromise.fire"
            },
            onRefreshPromise: {
                changePath: "state",
                value: "start"
            },
            onFetch: {
                changePath: "state",
                value: "in-progress"
            },
            afterFetch: [ {
                changePath: "state",
                value: "fetched"
            }, {
                funcName: "{that}.events.onBufferUpdated.fire",
                args: [ "{arguments}.0" ]
            } ],
            onBufferUpdated: "{enviro}.registerBuffer({arguments}.0)",
            onError: {
                changePath: "state",
                value: "error"
            }
        },
        events: {
            onRefreshPromise: null,
            onError: null,
            onFetch: null,
            afterFetch: null,
            onBufferUpdated: null
        }
    }), flock.bufferSource.get = function(e, t) {
        return "in-progress" === e.model.state || t.src === e.model.src && !t.replace ? e.bufferPromise.promise : (t.src && ("fetched" !== e.model.state && "errored" !== e.model.state || e.model.src === t.src && !t.replace || e.events.onRefreshPromise.fire(), 
        "start" === e.model.state && (e.model.src = t.src, e.events.onFetch.fire(t), flock.audio.decode({
            src: t.src,
            sampleRate: e.options.sampleRate,
            success: function(n) {
                t.id && (n.id = t.id), e.set(n);
            },
            error: e.error
        }))), e.bufferPromise.promise);
    }, flock.bufferSource.set = function(e, t) {
        var n = e.model.state;
        return "start" !== n && "in-progress" !== n || e.bufferPromise.promise.resolve(t), 
        e.bufferPromise.promise;
    }, flock.bufferSource.error = function(e, t) {
        return e.bufferPromise.promise.reject(t), e.bufferPromise.promise;
    }, fluid.defaults("flock.bufferLoader", {
        gradeNames: [ "fluid.component" ],
        bufferDefs: [],
        members: {
            buffers: [],
            bufferDefs: "@expand:flock.bufferLoader.expandBufferDefs({that}.options.bufferDefs)"
        },
        components: {
            enviro: "{flock.enviro}"
        },
        events: {
            afterBuffersLoaded: null,
            onError: null
        },
        listeners: {
            "onCreate.loadBuffers": {
                funcName: "flock.bufferLoader.loadBuffers",
                args: [ "{that}" ]
            },
            "onError.logError": {
                funcName: "flock.log.fail"
            }
        }
    }), flock.bufferLoader.idFromURL = function(e) {
        var t = e.lastIndexOf("/"), n = t > -1 ? t + 1 : 0, o = e.lastIndexOf("."), r = o > -1 ? o : e.length;
        return e.substring(n, r);
    }, flock.bufferLoader.idsFromURLs = function(e) {
        return fluid.transform(e, flock.bufferLoader.idFromURL);
    }, flock.bufferLoader.expandFileSequence = function(e) {
        e = e || [];
        var t, n, o, r = [];
        for (t = 0; t < e.length; t++) n = e[t], o = flock.bufferLoader.idFromURL(n), r.push({
            id: o,
            url: n
        });
        return r;
    }, flock.bufferLoader.expandBufferDef = function(e) {
        return "string" == typeof e && (e = {
            url: e
        }), void 0 === e.id && void 0 !== e.url && (e.id = flock.bufferLoader.idFromURL(e.url)), 
        e;
    }, flock.bufferLoader.expandBufferDefs = function(e) {
        return e ? (e = fluid.makeArray(e), fluid.transform(e, flock.bufferLoader.expandBufferDef)) : [];
    }, flock.bufferLoader.loadBuffer = function(e, t, n) {
        try {
            flock.parse.bufferForDef(e, t, n.enviro);
        } catch (e) {
            n.events.onError.fire(e.message);
        }
    }, flock.bufferLoader.loadBuffers = function(e) {
        var t = 1, n = {
            setBuffer: function(o) {
                if (e.buffers.push(o), e.buffers.length === e.options.bufferDefs.length) e.events.afterBuffersLoaded.fire(e.buffers); else if (t < e.bufferDefs.length) {
                    var r = e.bufferDefs[t];
                    flock.bufferLoader.loadBuffer(r, n, e), t++;
                }
            }
        };
        flock.bufferLoader.loadBuffer(e.bufferDefs[0], n, e);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var e = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.parse"), flock.parse.synthDef = function(e, t, n) {
        return e || (e = []), flock.parse.synthDef.hasOutUGen(e) || (e = flock.parse.synthDef.makeOutUGenDef(e, n)), 
        flock.parse.ugenForDef(e, t, n);
    }, flock.parse.synthDef.hasOutUGen = function(e) {
        return !flock.isIterable(e) && (e.id === flock.OUT_UGEN_ID || "flock.ugen.out" === e.ugen || "flock.ugen.valueOut" === e.ugen);
    }, flock.parse.synthDef.makeOutUGenDef = function(e, t) {
        return e = {
            id: flock.OUT_UGEN_ID,
            ugen: "flock.ugen.valueOut",
            inputs: {
                sources: e
            }
        }, t.rate === flock.rates.AUDIO && (e.ugen = "flock.ugen.out", e.inputs.bus = 0, 
        e.inputs.expand = t.audioSettings.chans), e;
    }, flock.parse.makeUGen = function(t, n, o, r) {
        var a = r.audioSettings.rates, i = r.audioSettings.blockSize;
        if (t.rate || (t.rate = flock.rates.AUDIO), !flock.hasValue(flock.rates, t.rate) && (flock.fail("An invalid rate was specified for a unit generator. ugenDef was: " + fluid.prettyPrintJSON(t)), 
        !flock.debug.failHard)) {
            var l = t.rate;
            t.rate = flock.rates.AUDIO, flock.log.warn("Overriding invalid unit generator rate. Rate is now '" + t.rate + "'; was: " + fluid.prettyPrintJSON(l));
        }
        var u;
        u = t.options && void 0 !== t.options.sampleRate ? t.options.sampleRate : a[t.rate], 
        t.options = e.extend(!0, {}, t.options, {
            sampleRate: u,
            rate: t.rate,
            audioSettings: {
                rates: a,
                blockSize: i
            }
        });
        var s, f = t.rate === flock.rates.AUDIO ? i : 1;
        if (flock.hasTag(t.options, "flock.ugen.multiChannelOutput")) {
            var c = t.options.numOutputs || 1;
            s = [];
            for (var d = 0; d < c; d++) s.push(new Float32Array(f));
        } else s = new Float32Array(f);
        var m = fluid.copy(t.options);
        return m.buffers = r.buffers, m.buses = r.buses, m.enviro = o, flock.invoke(void 0, t.ugen, [ n, s, m ]);
    }, flock.parse.reservedWords = [ "id", "ugen", "rate", "inputs", "options" ], flock.parse.specialInputs = [ "value", "buffer", "list", "table", "envelope", "durations", "values" ], 
    flock.parse.expandInputs = function(e) {
        if (e.inputs) return e;
        var t, n = {};
        for (t in e) -1 === flock.parse.reservedWords.indexOf(t) && (n[t] = e[t], delete e[t]);
        return e.inputs = n, e;
    }, flock.parse.ugenDefForConstantValue = function(e) {
        return {
            ugen: "flock.ugen.value",
            rate: flock.rates.CONSTANT,
            inputs: {
                value: e
            }
        };
    }, flock.parse.expandValueDef = function(e) {
        var t = typeof e;
        if ("number" === t) return flock.parse.ugenDefForConstantValue(e);
        if ("object" === t) return e;
        throw new Error("Invalid value type found in ugen definition. UGenDef was: " + fluid.prettyPrintJSON(e));
    }, flock.parse.rateMap = {
        ar: flock.rates.AUDIO,
        kr: flock.rates.CONTROL,
        sr: flock.rates.SCHEDULED,
        dr: flock.rates.DEMAND,
        cr: flock.rates.CONSTANT
    }, flock.parse.expandRate = function(e, t) {
        return e.rate = flock.parse.rateMap[e.rate] || e.rate, t.overrideRate && e.rate !== flock.rates.CONSTANT && (e.rate = t.rate), 
        e;
    }, flock.parse.ugenDef = function(e, t, n) {
        return (flock.isIterable(e) ? flock.parse.ugensForDefs : flock.parse.ugenForDef)(e, t, n);
    }, flock.parse.ugenDef.mergeOptions = function(t) {
        var n = flock.ugenDefaults(t.ugen) || {};
        return n = fluid.copy(n), n.options = n.ugenOptions, delete n.ugenOptions, e.extend(!0, {}, n, t);
    }, flock.parse.ugensForDefs = function(e, t, n) {
        var o, r = [];
        for (o = 0; o < e.length; o++) r[o] = flock.parse.ugenForDef(e[o], t, n);
        return r;
    }, flock.parse.ugenForDef = function(t, n, o) {
        n = n || flock.environment;
        var r = o = e.extend(!0, {
            audioSettings: n.audioSystem.model,
            buses: n.busManager.buses,
            buffers: n.buffers
        }, o), a = r.visitors, i = r.audioSettings.rates;
        if (t = flock.parse.expandValueDef(t), flock.isIterable(t)) return flock.parse.ugensForDefs(t, n, o);
        t = flock.parse.expandInputs(t), flock.parse.expandRate(t, o);
        var l, u = (t = flock.parse.ugenDef.mergeOptions(t, o)).inputs, s = {};
        for (l in u) {
            var f = u[l];
            null !== f && (s[l] = flock.input.shouldExpand(l, t) ? flock.parse.ugenForDef(f, n, o) : f);
        }
        if (!t.ugen) throw new Error("Unit generator definition lacks a 'ugen' property; can't initialize the synth graph. Value: " + fluid.prettyPrintJSON(t));
        var c = flock.parse.makeUGen(t, s, n, o);
        if (t.id && (c.id = t.id), c.options.ugenDef = t, a) for (var d = 0; d < a.length; d++) a[d](c, t, i);
        return c;
    }, flock.parse.expandBufferDef = function(e) {
        return "string" == typeof e ? {
            id: e
        } : flock.isIterable(e) || e.data || e.format ? flock.bufferDesc(e) : e;
    }, flock.parse.bufferForDef = function(e, t, n) {
        (e = flock.parse.expandBufferDef(e)).data && e.data.channels ? (e = flock.bufferDesc(e), 
        flock.parse.bufferForDef.resolveBuffer(e, t, n)) : flock.parse.bufferForDef.resolveDef(e, t, n);
    }, flock.parse.bufferForDef.createBufferSource = function(e) {
        return flock.bufferSource({
            sampleRate: e.audioSystem.model.sampleRate
        });
    }, flock.parse.bufferForDef.findSource = function(e, t) {
        var n;
        return t && e.id ? (n = t.bufferSources[e.id]) || (n = flock.parse.bufferForDef.createBufferSource(t), 
        t.bufferSources[e.id] = n) : n = flock.parse.bufferForDef.createBufferSource(t), 
        n;
    }, flock.parse.bufferForDef.bindToPromise = function(e, t, n) {
        var o = function(e) {
            t.events.onBufferUpdated.addListener(o), n && n.setBuffer(e);
        };
        e.then(o, function(e) {
            throw !e && t.model.src && t.model.src.indexOf(".aif") && (e = "if this is an AIFF file, you might need to include flocking-audiofile-compatibility.js in some browsers."), 
            new Error("Error while resolving buffer " + t.model.src + ": " + e);
        });
    }, flock.parse.bufferForDef.resolveDef = function(e, t, n) {
        var o, r = flock.parse.bufferForDef.findSource(e, n);
        e.src = e.url || e.src, e.selector && "undefined" != typeof document && (e.src = document.querySelector(e.selector).files[0]), 
        o = r.get(e), flock.parse.bufferForDef.bindToPromise(o, r, t);
    }, flock.parse.bufferForDef.resolveBuffer = function(e, t, n) {
        var o = flock.parse.bufferForDef.findSource(e, n), r = o.set(e);
        flock.parse.bufferForDef.bindToPromise(r, o, t);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var e = "undefined" != typeof window ? window.atob : require("atob");
    flock.applyDeferred = function(e, t, n) {
        e && (n = void 0 === n ? 0 : n, setTimeout(function() {
            e.apply(null, t);
        }, n));
    }, fluid.registerNamespace("flock.net"), flock.net.readBufferFromUrl = function(e) {
        var t = e.src, n = new XMLHttpRequest();
        n.onreadystatechange = function() {
            if (4 === n.readyState) if (flock.net.isXHRSuccessful(n)) e.success(n.response, flock.file.parseFileExtension(t)); else {
                if (!e.error) throw new Error(n.statusText);
                e.error(n.statusText);
            }
        }, n.open(e.method || "GET", t, !0), n.responseType = e.responseType || "arraybuffer", 
        n.send(e.data);
    }, flock.net.isXHRSuccessful = function(e) {
        return 200 === e.status || 0 === e.responseURL.indexOf("file://") && 0 === e.status && e.response;
    }, fluid.registerNamespace("flock.file"), flock.file.mimeTypes = {
        "audio/wav": "wav",
        "audio/x-wav": "wav",
        "audio/wave": "wav",
        "audio/x-aiff": "aiff",
        "audio/aiff": "aiff",
        "sound/aiff": "aiff"
    }, flock.file.typeAliases = {
        aif: "aiff",
        wave: "wav"
    }, flock.file.parseFileExtension = function(e) {
        var t, n = e.lastIndexOf(".");
        if (!(n < 0)) return t = e.substring(n + 1), t = t.toLowerCase(), flock.file.typeAliases[t] || t;
    }, flock.file.parseMIMEType = function(e) {
        return flock.file.mimeTypes[e];
    }, flock.file.stringToBuffer = function(e) {
        var t, n = e.length, o = new ArrayBuffer(n), r = new Uint8Array(o);
        for (t = 0; t < n; t++) r[t] = e.charCodeAt(t);
        return r.buffer;
    }, flock.file.readBufferFromDataUrl = function(t) {
        var n = t.src, o = n.indexOf(","), r = n.substring(0, o), a = n.substring(o + 1), i = r.indexOf(";base64"), l = i > -1, u = n.indexOf("data:") + 5, s = l ? i : o, f = n.substring(u, s);
        l && (a = e(a)), flock.applyDeferred(function() {
            var e = flock.file.stringToBuffer(a);
            t.success(e, flock.file.parseMIMEType(f));
        });
    }, flock.file.readBufferFromFile = function(e) {
        var t = new FileReader();
        return t.onload = function(t) {
            e.success(t.target.result, flock.file.parseFileExtension(e.src.name));
        }, t.readAsArrayBuffer(e.src), t;
    }, fluid.registerNamespace("flock.audio"), flock.audio.loadBuffer = function(e) {
        var t = e.src || e.url;
        t && (t instanceof ArrayBuffer && flock.applyDeferred(e.success, [ t, e.type ]), 
        flock.audio.loadBuffer.readerForSource(t)(e));
    }, flock.audio.loadBuffer.readerForSource = function(e) {
        return "undefined" != typeof File && e instanceof File ? flock.file.readBufferFromFile : 0 === e.indexOf("data:") ? flock.file.readBufferFromDataUrl : flock.net.readBufferFromUrl;
    }, flock.audio.decode = function(e) {
        var t = e.success;
        e.success = function(n, o) {
            var r = flock.audio.decoderStrategies, a = r[o] || r.default;
            e.decoder && (a = "string" == typeof e.decoder ? fluid.getGlobalValue(e.decoder) : e.decoder), 
            a({
                rawData: n,
                type: o,
                success: t,
                error: e.error,
                sampleRate: e.sampleRate
            });
        }, flock.audio.loadBuffer(e);
    }, flock.audio.decode.webAudio = function(e) {
        flock.webAudio.audioSystem.audioContextSingleton.decodeAudioData(e.rawData, function(t) {
            var n = flock.bufferDesc.fromAudioBuffer(t);
            e.success(n);
        }, e.error);
    }, flock.audio.decoderStrategies = {
        default: flock.audio.decode.webAudio
    }, flock.audio.registerDecoderStrategy = function(e, t) {
        if (e) if ("object" != typeof e) "string" == typeof t && (t = fluid.getGlobalValue(t)), 
        flock.audio.decoderStrategies[e] = t; else for (var n in e) flock.audio.decoderStrategies[n] = e[n];
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
    fluid.registerNamespace("flock.audio.convert"), flock.audio.convert.maxFloatValue = function(e) {
        return 1 - 1 / e.scale;
    }, flock.audio.convert.pcm = {
        int8: {
            scale: 128,
            setter: "setInt8",
            width: 1
        },
        int16: {
            scale: 32768,
            setter: "setInt16",
            width: 2
        },
        int32: {
            scale: 2147483648,
            setter: "setInt32",
            width: 4
        },
        float32: {
            scale: 1,
            setter: "setFloat32",
            width: 4
        }
    };
    for (var t in flock.audio.convert.pcm) {
        var n = flock.audio.convert.pcm[t];
        n.maxFloatValue = flock.audio.convert.maxFloatValue(n);
    }
    flock.audio.convert.specForPCMType = function(e) {
        var t = "string" == typeof e ? flock.audio.convert.pcm[e] : e;
        return t || flock.fail("Flocking does not support " + e + " format PCM wave files."), 
        t;
    }, flock.audio.convert.floatToInt = function(e, t) {
        var n = Math.min(t.maxFloatValue, e);
        return n = Math.max(-1, n), n *= t.scale, n = Math.round(n);
    }, flock.audio.convert.floatsToInts = function(t, n) {
        if (t) {
            for (var o = "Int" + 8 * n.width + "Array", r = new e[o](t.length), a = 0; a < t.length; a++) {
                var i = t[a], l = flock.audio.convert.floatToInt(i, n);
                r[a] = l;
            }
            return r;
        }
    }, flock.audio.convert.intToFloat = function(e, t) {
        return e / t.scale;
    }, flock.audio.convert.intsToFloats = function(e, t) {
        if (e) {
            for (var n = new Float32Array(e.length), o = 0; o < e.length; o++) {
                var r = e[o], a = flock.audio.convert.intToFloat(r, t);
                n[o] = a;
            }
            return n;
        }
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.registerNamespace("flock.audio.encode"), flock.audio.interleave = function(e) {
    var t, n, o = e.format.numSampleFrames, r = e.data.channels, a = e.format.numChannels, i = o * a, l = new Float32Array(i), u = 0;
    for (t = 0; t < o; t++) for (n = 0; n < a; n++) l[u] = r[n][t], u++;
    return l;
}, flock.audio.encode = function(e, t, n) {
    return "wav" !== (t = t || "wav").toLowerCase() && flock.fail("Flocking currently only supports encoding WAVE files."), 
    flock.audio.encode.wav(e, n);
}, flock.audio.encode.writeFloat32Array = function(e, t, n) {
    for (var o = 0; o < n.length; o++) t.setFloat32(e, n[o], !0), e += 4;
    return t;
}, flock.audio.encode.setString = function(e, t, n) {
    for (var o = 0; o < n.length; o++) e.setUint8(t + o, n.charCodeAt(o));
}, flock.audio.encode.setBytes = function(e, t, n) {
    for (var o = 0; o < n.length; o++) e.setUint8(t + o, n[o]);
}, flock.audio.encode.writeAsPCM = function(e, t, n, o) {
    if ("setFloat32" === e.setter && o instanceof Float32Array) return flock.audio.encode.writeFloat32Array(t, n, o);
    for (var r = 0; r < o.length; r++) {
        var a = flock.audio.convert.floatToInt(o[r], e);
        n[e.setter](t, a, !0), t += e.width;
    }
    return n;
}, flock.audio.encode.wav = function(e, t) {
    t = t || flock.audio.convert.pcm.int16;
    var n = flock.audio.convert.specForPCMType(t), o = flock.audio.interleave(e), r = e.format.numChannels, a = e.format.sampleRate, i = "setFloat32" !== n.setter, l = 16, u = 1, s = o.length * n.width, f = 8 + s, c = n.width * r, d = 8 * n.width;
    if (r > 2 || !i) {
        l += 12, r > 2 ? (l += 24, u = 65534) : (l += 2, u = 3);
    }
    var m = 12 + l + f, h = 8 + m, p = new ArrayBuffer(h), k = new DataView(p);
    flock.audio.encode.setString(k, 0, "RIFF"), k.setUint32(4, m, !0), flock.audio.encode.setString(k, 8, "WAVE"), 
    flock.audio.encode.setString(k, 12, "fmt "), k.setUint32(16, l, !0), k.setUint16(20, u, !0), 
    k.setUint16(22, r, !0), k.setUint32(24, a, !0), k.setUint32(28, a * c, !0), k.setUint16(32, c, !0), 
    k.setUint16(34, d, !0);
    var g = 36;
    return 3 === u ? (k.setUint16(g, 0, !0), g += 2, g = flock.audio.encode.wav.writeFactChunk(k, g, e.format.numSampleFrames)) : 65534 === u && (k.setUint16(g, 22, !0), 
    g += 2, g = flock.audio.encode.wav.additionalFormat(g, k, d, i), g = flock.audio.encode.wav.writeFactChunk(k, g, e.format.numSampleFrames)), 
    flock.audio.encode.wav.writeDataChunk(n, g, k, o, s), k.buffer;
}, flock.audio.encode.wav.subformats = {
    pcm: new Uint8Array([ 1, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ]),
    float: new Uint8Array([ 3, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ])
}, flock.audio.encode.wav.additionalFormat = function(e, t, n, o) {
    t.setUint16(e, n, !0), e += 2, t.setUint32(e, 2147483648, !0), e += 4;
    var r = flock.audio.encode.wav.subformats[o ? "pcm" : "float"];
    return flock.audio.encode.setBytes(t, e, r), e += 16;
}, flock.audio.encode.wav.writeFactChunk = function(e, t, n) {
    return flock.audio.encode.setString(e, t, "fact"), t += 4, e.setUint32(t, 4, !0), 
    t += 4, e.setUint32(t, n, !0), t += 4;
}, flock.audio.encode.wav.writeDataChunk = function(e, t, n, o, r) {
    flock.audio.encode.setString(n, t, "data"), t += 4, n.setUint32(t, r, !0), t += 4, 
    flock.audio.encode.writeAsPCM(e, t, n, o);
};

var fluid = fluid || require("infusion");

(flock = fluid.registerNamespace("flock")).shim = {
    URL: "undefined" != typeof window ? window.URL || window.webkitURL || window.msURL : void 0
}, flock.worker = function(e) {
    var t, n, o = typeof e;
    if ("function" === o) e = "(" + e.toString() + ")();"; else if ("string" !== o) throw new Error("A flock.worker must be initialized with a String or a Function.");
    return window.Blob ? (n = new Blob([ e ], {
        type: "text/javascript"
    }), t = flock.shim.URL.createObjectURL(n)) : t = "data:text/javascript;base64," + window.btoa(e), 
    new Worker(t);
}, fluid.registerNamespace("flock.scheduler"), fluid.defaults("flock.scheduler.clock", {
    gradeNames: [ "fluid.component" ],
    invokers: {
        end: "fluid.mustBeOverridden"
    },
    events: {
        tick: null
    },
    listeners: {
        "onDestroy.end": "{that}.end()"
    }
}), fluid.defaults("flock.scheduler.intervalClock", {
    gradeNames: [ "flock.scheduler.clock" ],
    members: {
        scheduled: {}
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.intervalClock.schedule",
            args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.tick.fire", "{that}.events.onClear.fire" ]
        },
        clear: {
            funcName: "flock.scheduler.intervalClock.clear",
            args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        clearAll: {
            funcName: "flock.scheduler.intervalClock.clearAll",
            args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        end: "{that}.clearAll"
    }
}), flock.scheduler.intervalClock.schedule = function(e, t, n) {
    var o = setInterval(function() {
        n(e);
    }, e);
    t[e] = o;
}, flock.scheduler.intervalClock.clear = function(e, t) {
    var n = t[e];
    clearInterval(n), delete t[e];
}, flock.scheduler.intervalClock.clearAll = function(e, t) {
    for (var n in e) flock.scheduler.intervalClock.clear(n, e, t);
}, fluid.defaults("flock.scheduler.scheduleClock", {
    gradeNames: [ "flock.scheduler.clock" ],
    members: {
        scheduled: []
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.scheduleClock.schedule",
            args: [ "{arguments}.0", "{that}.scheduled", "{that}.events" ]
        },
        clear: {
            funcName: "flock.scheduler.scheduleClock.clear",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        clearAll: {
            funcName: "flock.scheduler.scheduleClock.clearAll",
            args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        end: "{that}.clearAll"
    }
}), flock.scheduler.scheduleClock.schedule = function(e, t, n) {
    var o;
    o = setTimeout(function() {
        clearTimeout(o), n.tick.fire(e);
    }, e), t.push(o);
}, flock.scheduler.scheduleClock.clear = function(e, t, n) {
    (t = void 0 === t ? n.indexOf(e) : t) > -1 && (n.splice(t, 1), clearTimeout(e));
}, flock.scheduler.scheduleClock.clearAll = function(e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        clearTimeout(n);
    }
    e.length = 0;
}, fluid.defaults("flock.scheduler.webWorkerClock", {
    gradeNames: [ "fluid.component" ],
    members: {
        worker: {
            expander: {
                funcName: "flock.worker",
                args: "@expand:fluid.getGlobalValue(flock.scheduler.webWorkerClock.workerImpl)"
            }
        }
    },
    invokers: {
        postToWorker: {
            funcName: "flock.scheduler.webWorkerClock.postToWorker",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.options.messages", "{that}.worker" ]
        },
        schedule: "{that}.postToWorker(schedule, {arguments}.0)",
        clear: "{that}.postToWorker(clear, {arguments}.0)",
        clearAll: "{that}.postToWorker(clearAll)",
        end: "{that}.postToWorker(end)"
    },
    events: {
        tick: null
    },
    listeners: {
        onCreate: {
            funcName: "flock.scheduler.webWorkerClock.init",
            args: [ "{that}" ]
        },
        "onDestroy.clearAllScheduled": "{that}.clearAll",
        "onDestroy.endWorker": {
            priority: "after:clearAllScheduled",
            func: "{that}.end"
        }
    },
    startMsg: {
        msg: "start",
        value: "{that}.options.clockType"
    },
    messages: {
        schedule: {
            msg: "schedule"
        },
        clear: {
            msg: "clear"
        },
        clearAll: {
            msg: "clearAll"
        },
        end: {
            msg: "end"
        }
    }
}), flock.scheduler.webWorkerClock.init = function(e) {
    e.worker.addEventListener("message", function(t) {
        e.events.tick.fire(t.data.value);
    }, !1), e.worker.postMessage(e.options.startMsg);
}, flock.scheduler.webWorkerClock.postToWorker = function(e, t, n, o) {
    var r = n[e];
    void 0 !== t && (r.value = t), o.postMessage(r);
}, flock.scheduler.webWorkerClock.workerImpl = function() {
    var e = e || {};
    e.worker = e.worker || {}, e.worker.clock = function() {
        var e = {};
        return e.tick = function(e) {
            self.postMessage({
                msg: "tick",
                value: e
            });
        }, e;
    }, e.worker.intervalClock = function() {
        var t = e.worker.clock();
        return t.scheduled = {}, t.schedule = function(e) {
            var n = setInterval(function() {
                t.tick(e);
            }, e);
            t.scheduled[e] = n;
        }, t.clear = function(e) {
            var n = t.scheduled[e];
            clearInterval(n), delete t.scheduled[e];
        }, t.clearAll = function() {
            for (var e in t.scheduled) t.clear(e);
        }, t;
    }, e.worker.scheduleClock = function() {
        var t = e.worker.clock();
        return t.scheduled = [], t.schedule = function(e) {
            var n;
            n = setTimeout(function() {
                t.clear(n), t.tick(e);
            }, e), t.scheduled.push(n);
        }, t.clear = function(e, n) {
            (n = void 0 === n ? t.scheduled.indexOf(e) : n) > -1 && t.scheduled.splice(n, 1), 
            clearTimeout(e);
        }, t.clearAll = function() {
            for (var e = 0; e < t.scheduled.length; e++) {
                var n = t.scheduled[e];
                clearTimeout(n);
            }
            t.scheduled.length = 0;
        }, t;
    }, self.addEventListener("message", function(t) {
        "start" === t.data.msg ? e.clock = e.worker[t.data.value]() : "end" === t.data.msg ? e.clock && (e.clock.clearAll(), 
        self.close()) : e.clock && e.clock[t.data.msg](t.data.value);
    }, !1);
}, fluid.defaults("flock.scheduler.webWorkerIntervalClock", {
    gradeNames: [ "flock.scheduler.webWorkerClock" ],
    clockType: "intervalClock"
}), fluid.defaults("flock.scheduler.webWorkerScheduleClock", {
    gradeNames: [ "flock.scheduler.webWorkerClock" ],
    clockType: "scheduleClock"
}), fluid.defaults("flock.scheduler", {
    gradeNames: [ "fluid.component" ],
    events: {
        onScheduled: null,
        onFinished: null,
        onClearAll: null
    },
    listeners: {
        "onClearAll.clearClock": [ "{that}.clock.clearAll()" ]
    }
}), flock.scheduler.addListener = function(e, t, n) {
    return t.push(e), n(e), e;
}, flock.scheduler.removeListener = function(e, t, n) {
    if (e) {
        var o = t.indexOf(e);
        o > -1 ? (t.splice(o, 1), n(e)) : e.wrappedListener && flock.scheduler.removeListener(e.wrappedListener, t, n);
    }
}, fluid.defaults("flock.scheduler.repeat", {
    gradeNames: [ "flock.scheduler" ],
    members: {
        listeners: {}
    },
    components: {
        clock: {
            type: "flock.scheduler.webWorkerIntervalClock"
        }
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.repeat.schedule",
            args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.listeners", "{that}.events.onScheduled.fire" ]
        },
        clear: "{that}.events.onFinished.fire",
        clearAll: {
            funcName: "flock.scheduler.repeat.clearAll",
            args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
        },
        clearInterval: {
            funcName: "flock.scheduler.repeat.clearInterval",
            args: [ "{arguments}.0", "{that}.listeners", "{that}.events.onFinished.fire" ]
        },
        addIntervalListener: {
            funcName: "flock.scheduler.repeat.addIntervalListener",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
        },
        removeIntervalListener: {
            funcName: "flock.scheduler.repeat.removeIntervalListener",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
        }
    },
    listeners: {
        onScheduled: [ "{that}.addIntervalListener({arguments}.0, {arguments}.1)", "{that}.clock.schedule({arguments}.0)" ],
        onFinished: [ "{that}.removeIntervalListener({arguments}.0, {arguments}.1)" ]
    }
}), flock.scheduler.repeat.intervalListeners = function(e, t) {
    return t[e];
}, flock.scheduler.repeat.addIntervalListener = function(e, t, n, o) {
    var r = flock.scheduler.repeat.intervalListeners(e, n);
    flock.scheduler.addListener(t, r, o);
}, flock.scheduler.repeat.removeIntervalListener = function(e, t, n, o) {
    var r = flock.scheduler.repeat.intervalListeners(e, n);
    flock.scheduler.removeListener(t, r, o);
}, flock.scheduler.repeat.schedule = function(e, t, n, o, r, a) {
    e = n.value(e), t = flock.scheduler.async.prepareListener(t, o);
    var i = flock.scheduler.repeat.wrapValueListener(e, t);
    return flock.scheduler.repeat.addInterval(e, r), a(e, i), i;
}, flock.scheduler.repeat.wrapValueListener = function(e, t) {
    var n = function(n) {
        n === e && t(n);
    };
    return n.wrappedListener = t, n;
}, flock.scheduler.repeat.addInterval = function(e, t) {
    var n = t[e];
    n || (n = t[e] = []);
}, flock.scheduler.repeat.clearAll = function(e, t, n) {
    for (var o in e) flock.scheduler.repeat.clearInterval(o, e, t);
    n();
}, flock.scheduler.repeat.clearInterval = function(e, t, n) {
    var o = t[e];
    if (o) for (var r = 0; r < o.length; r++) n(e, o[r]);
}, fluid.defaults("flock.scheduler.once", {
    gradeNames: [ "flock.scheduler" ],
    members: {
        listeners: []
    },
    components: {
        clock: {
            type: "flock.scheduler.webWorkerScheduleClock"
        }
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.once.schedule",
            args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.clear", "{that}.events.onScheduled.fire" ]
        },
        clear: "{that}.events.onFinished.fire",
        clearAll: {
            funcName: "flock.scheduler.once.clearAll",
            args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
        }
    },
    listeners: {
        onScheduled: [ {
            funcName: "flock.scheduler.addListener",
            args: [ "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
        }, {
            func: "{that}.clock.schedule",
            args: [ "{arguments}.0" ]
        } ],
        onFinished: {
            funcName: "flock.scheduler.removeListener",
            args: [ "{arguments}.0", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
        }
    }
}), flock.scheduler.once.wrapValueListener = function(e, t, n) {
    var o = function(r) {
        r === e && (t(r), n(o));
    };
    return o.wrappedListener = t, o;
}, flock.scheduler.once.schedule = function(e, t, n, o, r, a) {
    e = n.value(e), t = flock.scheduler.async.prepareListener(t, o);
    var i = flock.scheduler.once.wrapValueListener(e, t, r);
    return a(e, i), i;
}, flock.scheduler.once.clearAll = function(e, t, n) {
    for (var o = 0; o < e.length; o++) t(e[o]);
    n();
}, fluid.defaults("flock.scheduler.async", {
    gradeNames: [ "fluid.component" ],
    subSchedulerOptions: {
        components: {
            timeConverter: "{async}.timeConverter"
        },
        listeners: {
            "{async}.events.onClear": "{that}.clear()",
            "{async}.events.onClearAll": "{that}.clearAll()",
            "{async}.events.onEnd": "{that}.clock.end()"
        }
    },
    distributeOptions: {
        source: "{that}.options.subSchedulerOptions",
        removeSource: !0,
        target: "{that flock.scheduler}.options"
    },
    components: {
        timeConverter: {
            type: "flock.convert.seconds"
        },
        onceScheduler: {
            type: "flock.scheduler.once"
        },
        repeatScheduler: {
            type: "flock.scheduler.repeat"
        },
        synthContext: void 0
    },
    invokers: {
        repeat: {
            func: "{repeatScheduler}.schedule",
            args: [ "{arguments}.0", "{arguments}.1" ]
        },
        once: {
            func: "{onceScheduler}.schedule",
            args: [ "{arguments}.0", "{arguments}.1" ]
        },
        sequence: {
            funcName: "flock.scheduler.async.sequence",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.once" ]
        },
        schedule: {
            funcName: "flock.scheduler.async.schedule",
            args: [ "{arguments}.0", "{that}" ]
        },
        clear: "{that}.events.onClear.fire",
        clearAll: "{that}.events.onClearAll.fire",
        end: "{that}.events.onEnd.fire"
    },
    events: {
        onClear: null,
        onClearAll: null,
        onEnd: null
    },
    listeners: {
        onCreate: "{that}.schedule({that}.options.score)",
        onEnd: "{that}.clearAll"
    }
}), flock.scheduler.async.sequence = function(e, t, n) {
    for (var o = [], r = 0; r < e.length; r++) {
        var a = n(e[r], t);
        o.push(a);
    }
    return o;
}, flock.scheduler.async.schedule = function(e, t) {
    if (e) {
        e = flock.isIterable(e) ? e : [ e ];
        for (var n = 0; n < e.length; n++) {
            var o = e[n];
            flock.invoke(t, o.interval, [ o.time, o.change ]);
        }
    }
}, flock.scheduler.async.prepareListener = function(e, t) {
    return "function" == typeof e ? e : flock.scheduler.async.evaluateChangeSpec(e, t);
}, flock.scheduler.async.getTargetSynth = function(e, t) {
    var n = e.synth;
    return n ? "string" != typeof n ? n : fluid.get(t, n) : t;
}, flock.scheduler.async.makeSynthUpdater = function(e, t, n, o) {
    return function() {
        for (var r in e) {
            var a = e[r];
            n[r] = flock.evaluate.synthValue(a);
        }
        var i = flock.scheduler.async.getTargetSynth(t, o);
        i ? i.set(n) : flock.fail("A target synth named " + t.synth + " could not be found in the specified synthContext. Synth context was: " + o);
    };
}, flock.scheduler.async.evaluateChangeSpec = function(e, t) {
    var n = {}, o = {};
    for (var r in e.values) {
        var a = e.values[r];
        a.synthDef ? n[r] = flock.synth.value(a) : o[r] = a;
    }
    return flock.scheduler.async.makeSynthUpdater(n, e, o, t);
}, fluid.defaults("flock.scheduler.async.tempo", {
    gradeNames: [ "flock.scheduler.async" ],
    bpm: 60,
    components: {
        timeConverter: {
            type: "flock.convert.beats",
            options: {
                bpm: "{tempo}.options.bpm"
            }
        }
    }
}), fluid.registerNamespace("flock.convert"), fluid.defaults("flock.convert.ms", {
    gradeNames: [ "fluid.component" ],
    invokers: {
        value: "fluid.identity({arguments}.0)"
    }
}), fluid.defaults("flock.convert.seconds", {
    gradeNames: [ "fluid.component" ],
    invokers: {
        value: "flock.convert.seconds.toMillis({arguments}.0)"
    }
}), flock.convert.seconds.toMillis = function(e) {
    return 1e3 * e;
}, fluid.defaults("flock.convert.beats", {
    gradeNames: [ "fluid.component" ],
    bpm: 60,
    invokers: {
        value: "flock.convert.beats.toMillis({arguments}.0, {that}.options.bpm)"
    }
}), flock.convert.beats.toMillis = function(e, t) {
    return t <= 0 ? 0 : e / t * 6e4;
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.registerNamespace("flock.webAudio"), flock.webAudio.createNode = function(e, t) {
    var n = t.args ? fluid.makeArray(t.args) : void 0, o = "create" + t.node, r = o.indexOf("Node");
    r > -1 && (o = o.substring(0, r));
    var a = e[o].apply(e, n);
    return flock.webAudio.initNodeParams(e, a, t), flock.webAudio.initNodeProperties(a, t), 
    flock.webAudio.initNodeInputs(a, t), a;
}, flock.webAudio.setAudioParamValue = function(e, t, n, o) {
    o = o || 0;
    var r = e.currentTime + o;
    t.setValueAtTime(n, r);
}, flock.webAudio.initNodeParams = function(e, t, n) {
    var o = n.params;
    if (t && o) {
        for (var r in o) {
            var a = t[r], i = o[r];
            flock.webAudio.setAudioParamValue(e, a, i);
        }
        return t;
    }
}, flock.webAudio.safariPropertyProhibitions = [ "channelCount", "channelCountMode" ], 
flock.webAudio.shouldSetProperty = function(e) {
    return !flock.platform.browser.safari || flock.webAudio.safariPropertyProhibitions.indexOf(e) < 0;
}, flock.webAudio.initNodeProperties = function(e, t) {
    var n = t.props;
    if (n) {
        for (var o in n) {
            var r = n[o];
            flock.webAudio.shouldSetProperty(o) && (e[o] = r);
        }
        return e;
    }
}, flock.webAudio.connectInput = function(e, t, n, o) {
    n.connect(e, o, t);
}, flock.webAudio.initNodeInputs = function(e, t) {
    var n = t.inputs;
    for (var o in n) {
        var r = n[o], a = parseInt(o, 10);
        r = fluid.makeArray(r);
        for (var i = 0; i < r.length; i++) {
            var l = r[i];
            flock.webAudio.connectInput(e, a, l);
        }
    }
}, fluid.defaults("flock.webAudio.node", {
    gradeNames: [ "fluid.modelComponent" ],
    members: {
        node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
    },
    nodeSpec: {
        args: [],
        params: {},
        properties: {}
    }
}), fluid.defaults("flock.webAudio.gain", {
    gradeNames: [ "flock.webAudio.node" ],
    members: {
        node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
    },
    nodeSpec: {
        node: "Gain"
    }
}), fluid.defaults("flock.webAudio.scriptProcessor", {
    gradeNames: [ "flock.webAudio.node" ],
    nodeSpec: {
        node: "ScriptProcessor",
        args: [ "{audioSystem}.model.bufferSize", "{audioSystem}.model.numInputBuses", "{audioSystem}.model.chans" ],
        params: {},
        properties: {
            channelCountMode: "explicit"
        }
    }
}), fluid.defaults("flock.webAudio.channelMerger", {
    gradeNames: [ "flock.webAudio.node" ],
    nodeSpec: {
        node: "ChannelMerger",
        args: [ "{audioSystem}.model.numInputBuses" ],
        properties: {
            channelCountMode: "discrete"
        }
    }
}), fluid.defaults("flock.webAudio.outputFader", {
    gradeNames: [ "fluid.component" ],
    fadeDuration: .5,
    gainSpec: {
        node: "Gain",
        params: {
            gain: 0
        },
        properties: {
            channelCount: "{flock.enviro}.audioSystem.model.chans",
            channelCountMode: "explicit"
        }
    },
    members: {
        gainNode: "@expand:flock.webAudio.outputFader.createGainNode({flock.enviro}.audioSystem.nativeNodeManager, {that}.options.gainSpec)",
        context: "{flock.enviro}.audioSystem.context"
    },
    invokers: {
        fadeIn: {
            funcName: "flock.webAudio.outputFader.fadeIn",
            args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
        },
        fadeTo: {
            funcName: "flock.webAudio.outputFader.fadeTo",
            args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
        }
    }
}), flock.webAudio.outputFader.createGainNode = function(e, t) {
    return e.createOutputNode(t);
}, flock.webAudio.outputFader.fade = function(e, t, n, o, r) {
    r = r || 0;
    var a = e.currentTime + r;
    flock.webAudio.setAudioParamValue(e, t.gain, n), t.gain.linearRampToValueAtTime(o, a);
}, flock.webAudio.outputFader.fadeTo = function(e, t, n, o) {
    flock.webAudio.outputFader.fade(e, t, t.gain.value, n, o);
}, flock.webAudio.outputFader.fadeIn = function(e, t, n, o) {
    flock.webAudio.outputFader.fade(e, t, 0, n, o);
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.audioSystem", {
    gradeNames: [ "flock.audioSystem" ],
    channelRange: {
        min: "@expand:flock.webAudio.audioSystem.calcMinChannels()",
        max: "@expand:flock.webAudio.audioSystem.calcMaxChannels({that}.context.destination)"
    },
    members: {
        context: "@expand:flock.webAudio.audioSystem.createContext()"
    },
    model: {
        rates: {
            audio: "{that}.context.sampleRate"
        }
    },
    components: {
        outputManager: {
            type: "flock.webAudio.outputManager"
        },
        nativeNodeManager: {
            type: "flock.webAudio.nativeNodeManager"
        },
        inputDeviceManager: {
            type: "flock.webAudio.inputDeviceManager"
        },
        bufferWriter: {
            type: "flock.webAudio.bufferWriter"
        }
    },
    listeners: {
        onCreate: [ "flock.webAudio.audioSystem.configureDestination({that}.context, {that}.model.chans)" ]
    }
}), flock.webAudio.audioSystem.createContext = function() {
    var e = flock.webAudio.audioSystem;
    return e.audioContextSingleton || (e.audioContextSingleton = new flock.shim.AudioContext()), 
    e.audioContextSingleton;
}, flock.webAudio.audioSystem.calcMaxChannels = function(e) {
    return flock.platform.browser.safari ? e.channelCount : e.maxChannelCount;
}, flock.webAudio.audioSystem.calcMinChannels = function() {
    return flock.platform.browser.safari ? 2 : 1;
}, flock.webAudio.audioSystem.configureDestination = function(e, t) {
    flock.platform.browser.safari || (e.destination.channelCount = t, e.destination.channelCountMode = "explicit", 
    e.destination.channelInterpretation = "discrete");
}, fluid.defaults("flock.webAudio.enviroContextDistributor", {
    gradeNames: [ "fluid.component" ],
    distributeOptions: [ {
        target: "{/ flock.enviro > audioSystem}.options",
        record: {
            gradeNames: "flock.webAudio.audioSystem"
        }
    } ]
}), fluid.constructSingle([], {
    singleRootType: "flock.enviroContextDistributor",
    type: "flock.webAudio.enviroContextDistributor"
});

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.bufferWriter", {
    gradeNames: "fluid.component",
    invokers: {
        save: "flock.webAudio.bufferWriter.saveBuffer({arguments}.0)"
    }
}), flock.webAudio.bufferWriter.saveBuffer = function(e) {
    try {
        var t = flock.audio.encode.wav(e.buffer, e.format), n = new Blob([ t ], {
            type: "audio/wav"
        });
        return flock.webAudio.bufferWriter.download(e.path, n), e.success && e.success(t), 
        t;
    } catch (t) {
        e.error ? e.error(t) : flock.fail("There was an error while trying to download the buffer named " + e.buffer.id + ". Error: " + t);
    }
}, flock.webAudio.bufferWriter.download = function(e, t) {
    var n = flock.shim.URL.createObjectURL(t), o = window.document.createElement("a"), r = document.createEvent("Event");
    o.href = n, o.download = e, r.initEvent("click", !0, !0), o.dispatchEvent(r);
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    fluid.registerNamespace("flock.webAudio.chrome"), flock.webAudio.chrome.getSources = function(e) {
        return MediaStreamTrack.getSources(function(t) {
            var n = fluid.transform(t, function(e) {
                return e.deviceId = e.id, e;
            });
            e(n);
        });
    }, flock.webAudio.mediaStreamFailure = function() {
        flock.fail("Media Capture and Streams are not supported on this browser.");
    };
    var e = {
        AudioContext: window.AudioContext || window.webkitAudioContext,
        getUserMediaImpl: navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || flock.webAudio.mediaStreamFailure,
        getUserMedia: function() {
            flock.shim.getUserMediaImpl.apply(navigator, arguments);
        },
        getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices : void 0 !== window.MediaStreamTrack ? flock.webAudio.chrome.getSources : flock.webAudio.mediaStreamFailure,
        getMediaDevice: function() {
            flock.shim.getMediaDevicesImpl.apply(navigator, arguments);
        }
    };
    jQuery.extend(flock.shim, e), fluid.defaults("flock.webAudio.inputDeviceManager", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            openAudioDevice: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId", "{that}.openFirstAudioDeviceWithLabel", "{that}.openAudioDeviceWithConstraints" ]
            },
            openAudioDeviceWithConstraints: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                args: [ "{audioSystem}.context", "{enviro}", "{nativeNodeManager}.createMediaStreamInput", "{arguments}.0" ]
            },
            openAudioDeviceWithId: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithConstraints" ]
            },
            openFirstAudioDeviceWithLabel: {
                funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId" ]
            }
        }
    }), flock.webAudio.inputDeviceManager.openAudioDevice = function(e, t, n, o) {
        if (e) {
            if (e.id) return t(e.id);
            if (e.label) return n(e.label);
        }
        return o();
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithId = function(e, t) {
        t({
            audio: {
                optional: [ {
                    sourceId: e
                } ]
            }
        });
    }, flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function(e, t) {
        e && flock.shim.getMediaDevices(function(n) {
            var o = n.filter(function(t) {
                if (t.label.toLowerCase() === e.toLowerCase()) return !0;
            });
            o.length > 0 ? t(o[0].deviceId) : fluid.log(fluid.logLevel.IMPORTANT, "An audio device named '" + e + "' could not be found.");
        });
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function(e, t, n, o) {
        o = o || {
            audio: !0
        };
        var r = t.busManager.acquireNextBus("input");
        return flock.shim.getUserMedia(o, function(e) {
            n(e, r);
        }, function(e) {
            fluid.log(fluid.logLevel.IMPORTANT, "An error occurred while trying to access the user's microphone. " + e);
        }), r;
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.registerNamespace("flock.midi"), flock.midi.requestAccess = function(e, t, n) {
    if (!navigator.requestMIDIAccess) {
        var o = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
        return fluid.log(fluid.logLevel.WARN, o), void n(o);
    }
    navigator.requestMIDIAccess({
        sysex: e
    }).then(t, n);
}, flock.midi.getPorts = function(e) {
    var t = {}, n = "function" == typeof e.inputs ? flock.midi.collectPortsLegacy : flock.midi.collectPorts;
    return n("inputs", e, t), n("outputs", e, t), t;
}, flock.midi.requestPorts = function(e, t) {
    flock.midi.requestAccess(!1, function(t) {
        var n = flock.midi.getPorts(t);
        e(n);
    }, t);
}, flock.midi.createPortViews = function(e) {
    return fluid.transform(e, function(e) {
        return {
            id: e.id,
            name: e.name,
            manufacturer: e.manufacturer,
            state: e.state,
            connection: e.connection
        };
    });
}, flock.midi.prettyPrintPorts = function(e) {
    return fluid.prettyPrintJSON({
        inputs: flock.midi.createPortViews(e.inputs),
        outputs: flock.midi.createPortViews(e.outputs)
    });
}, flock.midi.logPorts = function() {
    flock.midi.requestPorts(function(e) {
        var t = flock.midi.prettyPrintPorts(e);
        console.log(t);
    }, function(e) {
        console.log(e);
    });
}, flock.midi.collectPorts = function(e, t, n) {
    for (var o = n[e] = n[e] || [], r = t[e].values(), a = r.next(); !a.done; ) o.push(a.value), 
    a = r.next();
    return n;
}, flock.midi.collectPortsLegacy = function(e, t, n) {
    return t[e] && (n[e] = t[e]()), n;
}, flock.midi.read = function(e) {
    var t, n = e[0], o = 15 & n;
    switch (n >> 4) {
      case 8:
        t = flock.midi.read.noteOff;
        break;

      case 9:
        t = e[2] > 0 ? flock.midi.read.noteOn : flock.midi.read.noteOff;
        break;

      case 10:
        t = flock.midi.read.polyAftertouch;
        break;

      case 11:
        t = flock.midi.read.controlChange;
        break;

      case 12:
        t = flock.midi.read.programChange;
        break;

      case 13:
        t = flock.midi.read.channelAftertouch;
        break;

      case 14:
        t = flock.midi.read.pitchbend;
        break;

      case 15:
        t = flock.midi.read.system;
        break;

      default:
        return flock.fail("Received an unrecognized MIDI message: " + fluid.prettyPrintJSON(e));
    }
    return t(o, e);
}, flock.midi.read.note = function(e, t, n) {
    return {
        type: e,
        chan: t,
        note: n[1],
        velocity: n[2]
    };
}, flock.midi.read.noteOn = function(e, t) {
    return flock.midi.read.note("noteOn", e, t);
}, flock.midi.read.noteOff = function(e, t) {
    return flock.midi.read.note("noteOff", e, t);
}, flock.midi.read.polyAftertouch = function(e, t) {
    return {
        type: "aftertouch",
        chan: e,
        note: t[1],
        pressure: t[2]
    };
}, flock.midi.read.controlChange = function(e, t) {
    return {
        type: "control",
        chan: e,
        number: t[1],
        value: t[2]
    };
}, flock.midi.read.programChange = function(e, t) {
    return {
        type: "program",
        chan: e,
        program: t[1]
    };
}, flock.midi.read.channelAftertouch = function(e, t) {
    return {
        type: "aftertouch",
        chan: e,
        pressure: t[1]
    };
}, flock.midi.read.twoByteValue = function(e) {
    return e[2] << 7 | e[1];
}, flock.midi.read.pitchbend = function(e, t) {
    return {
        type: "pitchbend",
        chan: e,
        value: flock.midi.read.twoByteValue(t)
    };
}, flock.midi.read.system = function(e, t) {
    if (1 === e) return flock.midi.messageFailure("quarter frame MTC");
    var n;
    switch (e) {
      case 0:
        n = flock.midi.read.sysex;
        break;

      case 2:
        n = flock.midi.read.songPointer;
        break;

      case 3:
        n = flock.midi.read.songSelect;
        break;

      case 6:
        n = flock.midi.read.tuneRequest;
        break;

      case 8:
        n = flock.midi.read.clock;
        break;

      case 10:
        n = flock.midi.read.start;
        break;

      case 11:
        n = flock.midi.read.continue;
        break;

      case 12:
        n = flock.midi.read.stop;
        break;

      case 14:
        n = flock.midi.read.activeSense;
        break;

      case 15:
        n = flock.midi.read.reset;
        break;

      default:
        return flock.fail("Received an unrecognized MIDI system message: " + fluid.prettyPrintJSON(t));
    }
    return n(t);
}, flock.midi.messageFailure = function(e) {
    flock.fail("Flocking does not currently support MIDI " + e + " messages.");
}, flock.midi.read.sysex = function(e) {
    return {
        type: "sysex",
        data: e
    };
}, flock.midi.read.valueMessage = function(e, t) {
    return {
        type: e,
        value: t
    };
}, flock.midi.read.songPointer = function(e) {
    var t = flock.midi.read.twoByteValue(e);
    return flock.midi.read.valueMessage("songPointer", t);
}, flock.midi.read.songSelect = function(e) {
    return flock.midi.read.valueMessage("songSelect", e[1]);
}, flock.midi.read.tuneRequest = function() {
    return {
        type: "tuneRequest"
    };
}, flock.midi.systemRealtimeMessages = [ "tuneRequest", "clock", "start", "continue", "stop", "activeSense", "reset" ], 
flock.midi.createSystemRealtimeMessageReaders = function(e) {
    fluid.each(e, function(e) {
        flock.midi.read[e] = function() {
            return {
                type: e
            };
        };
    });
}, flock.midi.createSystemRealtimeMessageReaders(flock.midi.systemRealtimeMessages), 
fluid.defaults("flock.midi.system", {
    gradeNames: [ "fluid.component" ],
    sysex: !1,
    members: {
        access: void 0,
        ports: void 0
    },
    invokers: {
        requestAccess: {
            funcName: "flock.midi.requestAccess",
            args: [ "{that}.options.sysex", "{that}.events.onAccessGranted.fire", "{that}.events.onAccessError.fire" ]
        },
        refreshPorts: {
            funcName: "flock.midi.system.refreshPorts",
            args: [ "{that}", "{that}.access", "{that}.events.onPortsAvailable.fire" ]
        }
    },
    events: {
        onAccessGranted: null,
        onAccessError: null,
        onReady: null,
        onPortsAvailable: null
    },
    listeners: {
        onCreate: {
            func: "{that}.requestAccess"
        },
        onAccessGranted: [ "flock.midi.system.setAccess({that}, {arguments}.0)", "{that}.refreshPorts()", "{that}.events.onReady.fire({that}.ports)" ],
        onAccessError: {
            funcName: "fluid.log",
            args: [ fluid.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0" ]
        }
    }
}), flock.midi.system.setAccess = function(e, t) {
    e.access = t;
}, flock.midi.system.refreshPorts = function(e, t, n) {
    e.ports = flock.midi.getPorts(t), n(e.ports);
}, fluid.defaults("flock.midi.receiver", {
    gradeNames: [ "fluid.component" ],
    events: {
        raw: null,
        message: null,
        note: null,
        noteOn: null,
        noteOff: null,
        control: null,
        program: null,
        aftertouch: null,
        pitchbend: null
    }
}), fluid.defaults("flock.midi.connection", {
    gradeNames: [ "flock.midi.receiver" ],
    openImmediately: !1,
    sysex: !1,
    distributeOptions: {
        source: "{that}.options.sysex",
        target: "{that > system}.options.sysex"
    },
    ports: 0,
    invokers: {
        sendRaw: {
            func: "{that}.events.onSendRaw.fire"
        },
        send: {
            funcName: "flock.midi.connection.send"
        },
        open: {
            funcName: "flock.midi.connection.bind",
            args: [ "{that}.system.ports", "{that}.options.ports", "{that}.events.onReady.fire", "{that}.events.raw.fire", "{that}.events.onSendRaw" ]
        },
        close: {
            funcName: "flock.midi.connection.close",
            args: [ "{that}.system.ports", "{that}.events.raw.fire" ]
        }
    },
    components: {
        system: {
            type: "flock.midi.system",
            options: {
                events: {
                    onReady: "{connection}.events.onPortsAvailable"
                }
            }
        }
    },
    events: {
        onPortsAvailable: null,
        onReady: null,
        onError: null,
        onSendRaw: null
    },
    listeners: {
        onPortsAvailable: {
            funcName: "flock.midi.connection.autoOpen",
            args: [ "{that}.options.openImmediately", "{that}.open" ]
        },
        onError: {
            funcName: "fluid.log",
            args: [ fluid.logLevel.WARN, "{arguments}.0" ]
        },
        raw: {
            funcName: "flock.midi.connection.fireEvent",
            args: [ "{arguments}.0", "{that}.events" ]
        },
        onDestroy: [ "{that}.close()" ]
    }
}), flock.midi.connection.send = function() {
    flock.fail("Sending MIDI messages is not currently supported.");
}, flock.midi.connection.autoOpen = function(e, t) {
    e && t();
}, flock.midi.findPorts = function(e, t) {
    t = fluid.makeArray(t);
    var n = [];
    return fluid.each(t, function(t) {
        var o = flock.midi.findPorts.portFinder(t)(e);
        n = n.concat(o);
    }), n;
}, flock.midi.findPorts.portFinder = function(e) {
    if ("number" == typeof e) return flock.midi.findPorts.byIndex(e);
    "string" == typeof e && (e = {
        name: e
    });
    var t = e.id ? flock.midi.findPorts.idMatcher(e.id) : e.manufacturer && e.name ? flock.midi.findPorts.bothMatcher(e.manufacturer, e.name) : e.manufacturer ? flock.midi.findPorts.manufacturerMatcher(e.manufacturer) : flock.midi.findPorts.nameMatcher(e.name);
    return function(e) {
        return e.filter(t);
    };
}, flock.midi.findPorts.byIndex = function(e) {
    return function(t) {
        var n = t[e];
        return n ? [ n ] : [];
    };
}, flock.midi.findPorts.lowerCaseContainsMatcher = function(e) {
    return function(t) {
        var n;
        for (var o in e) {
            var r = t[o], a = e[o];
            if (!(n = "*" === a || r && r.toLowerCase().indexOf(a.toLowerCase()) > -1)) break;
        }
        return n;
    };
}, flock.midi.findPorts.idMatcher = function(e) {
    return function(t) {
        return t.id === e;
    };
}, flock.midi.findPorts.bothMatcher = function(e, t) {
    return flock.midi.findPorts.lowerCaseContainsMatcher({
        manufacturer: e,
        name: t
    });
}, flock.midi.findPorts.manufacturerMatcher = function(e) {
    return flock.midi.findPorts.lowerCaseContainsMatcher({
        manufacturer: e
    });
}, flock.midi.findPorts.nameMatcher = function(e) {
    return flock.midi.findPorts.lowerCaseContainsMatcher({
        name: e
    });
}, flock.midi.findPorts.eachPortOfType = function(e, t, n) {
    var o = fluid.makeArray(e);
    fluid.each(o, function(e) {
        e.type === t && n(e);
    });
}, flock.midi.connection.openPort = function(e, t) {
    if (e.open) {
        var n = e.open();
        t.push(n);
    }
    return t;
}, flock.midi.connection.listen = function(e, t, n) {
    return flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
        flock.midi.connection.openPort(e, n), e.addEventListener("midimessage", t, !1);
    }), n;
}, flock.midi.connection.stopListening = function(e, t) {
    flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
        e.close(), e.removeEventListener("midimessage", t, !1);
    });
}, flock.midi.connection.bindSender = function(e, t, n) {
    var o = fluid.makeArray(e);
    return fluid.each(o, function(e) {
        flock.midi.connection.openPort(e, n), t.addListener(e.send.bind(e));
    }), n;
}, flock.midi.connection.fireReady = function(e, t) {
    !e || e.length < 1 || Promise.all(e).then(t);
}, flock.midi.connection.bind = function(e, t, n, o, r) {
    t = flock.midi.connection.expandPortSpec(t);
    var a = flock.midi.findPorts(e.inputs, t.input), i = flock.midi.findPorts(e.outputs, t.output), l = [];
    a && a.length > 0 ? flock.midi.connection.listen(a, o, l) : void 0 !== t.input && flock.midi.connection.logNoMatchedPorts("input", t), 
    i && i.length > 0 ? flock.midi.connection.bindSender(i, r, l) : void 0 !== t.output && flock.midi.connection.logNoMatchedPorts("output", t), 
    flock.midi.connection.fireReady(l, n);
}, flock.midi.connection.close = function(e, t) {
    flock.midi.connection.stopListening(e.inputs, t);
}, flock.midi.connection.logNoMatchedPorts = function(e, t) {
    fluid.log(fluid.logLevel.WARN, "No matching " + e + " ports were found for port specification: ", t[e]);
}, flock.midi.connection.expandPortSpec = function(e) {
    if (void 0 !== e.input || void 0 !== e.output) return e;
    var t = {
        input: {},
        output: {}
    };
    return "number" == typeof e ? t.input = t.output = e : (flock.midi.connection.expandPortSpecProperty("manufacturer", e, t), 
    flock.midi.connection.expandPortSpecProperty("name", e, t)), t;
}, flock.midi.connection.expandPortSpecProperty = function(e, t, n) {
    return n.input[e] = n.output[e] = t[e], n;
}, flock.midi.connection.fireEvent = function(e, t) {
    var n = flock.midi.read(e.data), o = n.type ? t[n.type] : void 0;
    t.message.fire(n, e), "noteOn" !== n.type && "noteOff" !== n.type || t.note.fire(n, e), 
    o && o.fire(n, e);
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.midi.controller", {
    gradeNames: [ "fluid.component" ],
    members: {
        controlMap: {
            expander: {
                funcName: "flock.midi.controller.optimizeMIDIMap",
                args: [ "{that}.options.controlMap" ]
            }
        },
        noteMap: {
            expander: {
                funcName: "flock.midi.controller.optimizeNoteMap",
                args: [ "{that}.options.noteMap" ]
            }
        }
    },
    controlMap: {},
    noteMap: {},
    components: {
        synthContext: {
            type: "flock.band"
        },
        connection: {
            type: "flock.midi.connection",
            options: {
                ports: {
                    input: "*"
                },
                openImmediately: !0
            }
        }
    },
    invokers: {
        mapControl: {
            funcName: "flock.midi.controller.mapControl",
            args: [ "{arguments}.0", "{that}.synthContext", "{that}.controlMap" ]
        },
        mapNote: {
            funcName: "flock.midi.controller.mapNote",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.synthContext", "{that}.noteMap" ]
        }
    },
    events: {
        control: "{that}.connection.events.control",
        note: "{that}.connection.events.note",
        noteOn: "{that}.connection.events.noteOn",
        noteOff: "{that}.connection.events.noteOff"
    },
    listeners: {
        control: "{that}.mapControl({arguments}.0)",
        note: "{that}.mapNote(note, {arguments}.0)",
        noteOn: "{that}.mapNote(noteOn, {arguments}.0)",
        noteOff: "{that}.mapNote(noteOff, {arguments}.0)"
    }
}), flock.midi.controller.optimizeMIDIMap = function(e) {
    var t = new Array(127);
    return fluid.each(e, function(e, n) {
        var o = Number(n);
        t[o] = fluid.makeArray(e);
    }), t;
}, flock.midi.controller.optimizeNoteMap = function(e) {
    return {
        note: fluid.makeArray(e.note),
        noteOn: fluid.makeArray(e.noteOn),
        noteOff: fluid.makeArray(e.noteOff),
        velocity: fluid.makeArray(e.velocity)
    };
}, flock.midi.controller.expandControlMapSpec = function(e, t) {
    return t.transform.id = e, t.valuePath = t.valuePath || "value", t.transform.ugen || (t.transform.ugen = "flock.ugen.value"), 
    t;
}, flock.midi.controller.makeValueSynth = function(e, t, n) {
    var o = (n = flock.midi.controller.expandControlMapSpec(t, n)).transform, r = n.valuePath;
    flock.set(o, r, e);
    var a = flock.synth.value({
        synthDef: o
    });
    return n.valuePath = t + "." + r, a;
}, flock.midi.controller.transformValue = function(e, t) {
    var n = t.transform;
    return "function" === typeof n ? n(e) : (t.transformSynth ? t.transformSynth.set(t.valuePath, e) : t.transformSynth = flock.midi.controller.makeValueSynth(e, "flock-midi-controller-in", t), 
    t.transformSynth.value());
}, flock.midi.controller.setMappedValue = function(e, t, n) {
    e = void 0 !== t.value ? t.value : t.transform ? flock.midi.controller.transformValue(e, t) : e, 
    (n[t.synth] || n).set(t.input, e);
}, flock.midi.controller.mapMIDIValue = function(e, t, n) {
    if (t && !(t.length < 1)) for (var o = 0; o < t.length; o++) {
        var r = t[o];
        flock.midi.controller.setMappedValue(e, r, n);
    }
}, flock.midi.controller.mapControl = function(e, t, n) {
    var o = n[e.number], r = e.value;
    flock.midi.controller.mapMIDIValue(r, o, t);
}, flock.midi.controller.mapNote = function(e, t, n, o) {
    var r = o[e], a = t.note, i = o.velocity, l = t.velocity;
    flock.midi.controller.mapMIDIValue(a, r, n), flock.midi.controller.mapMIDIValue(l, i, n);
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.nativeNodeManager", {
    gradeNames: [ "fluid.component" ],
    members: {
        outputNode: void 0,
        inputNodes: []
    },
    components: {
        scriptProcessor: {
            createOnEvent: "onCreateScriptProcessor",
            type: "flock.webAudio.scriptProcessor",
            options: {
                nodeSpec: {
                    inputs: {
                        "0": "{inputMerger}"
                    }
                }
            }
        },
        merger: {
            type: "flock.webAudio.channelMerger"
        }
    },
    invokers: {
        connect: "{that}.events.onConnect.fire",
        disconnect: "{that}.events.onDisconnect.fire",
        createNode: {
            funcName: "flock.webAudio.createNode",
            args: [ "{audioSystem}.context", "{arguments}.0" ]
        },
        createInputNode: {
            funcName: "flock.webAudio.nativeNodeManager.createInputNode",
            args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
        },
        createMediaStreamInput: {
            funcName: "flock.webAudio.nativeNodeManager.createInputNode",
            args: [ "{that}", {
                node: "MediaStreamSource",
                args: [ "{arguments}.0" ]
            }, "{arguments}.1" ]
        },
        createMediaElementInput: {
            funcName: "flock.webAudio.nativeNodeManager.createInputNode",
            args: [ "{that}", {
                node: "MediaElementSource",
                args: [ "{arguments}.0" ]
            }, "{arguments}.1" ]
        },
        createOutputNode: {
            funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
            args: [ "{that}", "{arguments}.0" ]
        },
        insertInput: {
            funcName: "flock.webAudio.nativeNodeManager.insertInput",
            args: [ "{that}", "{audioSystem}.model", "{enviro}", "{arguments}.0", "{arguments}.1" ]
        },
        removeInput: {
            funcName: "flock.webAudio.nativeNodeManager.removeInput",
            args: [ "{arguments}.0", "{that}.inputNodes" ]
        },
        removeAllInputs: {
            funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
            args: "{that}.inputNodes"
        },
        insertOutput: {
            funcName: "flock.webAudio.nativeNodeManager.insertOutput",
            args: [ "{that}", "{arguments}.0" ]
        },
        removeOutput: {
            funcName: "flock.webAudio.nativeNodeManager.removeOutput",
            args: [ "{scriptProcessor}.node" ]
        }
    },
    events: {
        onStart: "{enviro}.events.onStart",
        onStop: "{enviro}.events.onStop",
        onReset: "{enviro}.events.onReset",
        onCreateScriptProcessor: null,
        onConnect: null,
        onDisconnectNodes: null,
        onDisconnect: null
    },
    listeners: {
        onCreate: [ "{that}.events.onCreateScriptProcessor.fire()", {
            func: "{that}.insertOutput",
            args: "{scriptProcessor}.node"
        } ],
        onStart: [ "{that}.connect()" ],
        onConnect: [ {
            this: "{merger}.node",
            method: "connect",
            args: [ "{scriptProcessor}.node" ]
        }, {
            this: "{that}.outputNode",
            method: "connect",
            args: [ "{audioSystem}.context.destination" ]
        }, {
            funcName: "flock.webAudio.nativeNodeManager.connectOutput",
            args: [ "{scriptProcessor}.node", "{that}.outputNode" ]
        } ],
        onStop: [ "{that}.disconnect()" ],
        onDisconnectNodes: [ {
            this: "{merger}.node",
            method: "disconnect",
            args: [ 0 ]
        }, {
            this: "{scriptProcessor}.node",
            method: "disconnect",
            args: [ 0 ]
        }, {
            this: "{that}.outputNode",
            method: "disconnect",
            args: [ 0 ]
        } ],
        "onDisconnect.onDisconnectNodes": {
            func: "{that}.events.onDisconnectNodes.fire"
        },
        onReset: [ "{that}.removeAllInputs()", "{that}.events.onCreateScriptProcessor.fire()" ],
        onDestroy: [ "{that}.events.onDisconnectNodes.fire()", "{that}.removeAllInputs()", "flock.webAudio.nativeNodeManager.disconnectOutput({that})" ]
    }
}), flock.webAudio.nativeNodeManager.createInputNode = function(e, t, n) {
    var o = e.createNode(t);
    return e.insertInput(o, n);
}, flock.webAudio.nativeNodeManager.createOutputNode = function(e, t) {
    var n = e.createNode(t);
    return e.insertOutput(n);
}, flock.webAudio.nativeNodeManager.connectOutput = function(e, t) {
    e !== t && e.connect(t);
}, flock.webAudio.nativeNodeManager.disconnectOutput = function(e) {
    e.outputNode && e.outputNode.disconnect(0);
}, flock.webAudio.nativeNodeManager.removeAllInputs = function(e) {
    for (var t = 0; t < e.length; t++) e[t].disconnect(0);
    e.length = 0;
}, flock.webAudio.nativeNodeManager.insertInput = function(e, t, n, o, r) {
    var a = t.numInputBuses;
    {
        if (!(e.inputNodes.length >= a)) {
            var i = (r = void 0 === r ? n.busManager.acquireNextBus("input") : r) - t.chans;
            return e.inputNodes.push(o), o.connect(e.merger.node, 0, i), r;
        }
        flock.fail("There are too many input nodes connected to Flocking. The maximum number of input buses is currently set to " + a + ". Either remove an existing input node or increase Flockings numInputBuses option.");
    }
}, flock.webAudio.nativeNodeManager.removeInput = function(e, t) {
    var n = t.indexOf(e);
    n > -1 && t.splice(n, 1), e.disconnect(0);
}, flock.webAudio.nativeNodeManager.insertOutput = function(e, t) {
    return flock.webAudio.nativeNodeManager.disconnectOutput(e), e.outputNode = t, t;
}, flock.webAudio.nativeNodeManager.removeOutput = function(e) {
    flock.webAudio.nativeNodeManager.insertOutput(e);
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.outputManager", {
    gradeNames: [ "flock.outputManager" ],
    model: {
        isGenerating: !1,
        shouldInitIOS: flock.platform.isIOS,
        audioSettings: {}
    },
    invokers: {
        bindAudioProcess: {
            funcName: "flock.webAudio.outputManager.bindAudioProcess",
            args: [ "{enviro}.nodeList", "{busManager}.buses", "{nativeNodeManager}", "{that}.model" ]
        },
        unbindAudioProcess: {
            funcName: "flock.webAudio.outputManager.unbindAudioProcess",
            args: [ "{nativeNodeManager}" ]
        }
    },
    listeners: {
        "{nativeNodeManager}.events.onConnect": [ "{that}.bindAudioProcess()" ],
        "{nativeNodeManager}.events.onDisconnect": [ "{that}.unbindAudioProcess()" ],
        onStart: [ {
            func: "{that}.applier.change",
            args: [ "isGenerating", !0 ]
        }, {
            priority: "last",
            funcName: "flock.webAudio.outputManager.iOSStart",
            args: [ "{that}", "{audioSystem}.context", "{nativeNodeManager}.scriptProcessor.node" ]
        } ],
        onStop: [ {
            func: "{that}.applier.change",
            args: [ "isGenerating", !1 ]
        } ],
        "onDestroy.unbindAudioProcess": "{that}.unbindAudioProcess()"
    }
}), flock.webAudio.outputManager.bindAudioProcess = function(e, t, n, o) {
    var r = n.scriptProcessor.node;
    r.model = o, r.nodeList = e, r.buses = t, r.inputNodes = n.inputNodes, r.onaudioprocess = flock.webAudio.outputManager.writeSamples;
}, flock.webAudio.outputManager.unbindAudioProcess = function(e) {
    e.scriptProcessor.node.onaudioprocess = void 0;
}, flock.webAudio.outputManager.writeSamples = function(e) {
    var t, n, o, r = this.inputNodes ? this.inputNodes.length : 0, a = this.nodeList.nodes, i = this.model.audioSettings, l = e.inputBuffer, u = e.outputBuffer, s = i.numBlocks, f = this.buses, c = i.numBuses, d = i.blockSize, m = i.chans, h = l.numberOfChannels;
    if (a.length < 1) for (t = 0; t < m; t++) flock.clearBuffer(u.getChannelData(t)); else for (n = 0; n < s; n++) {
        var p = n * d;
        if (flock.evaluate.clearBuses(f, c, d), r > 0) for (t = 0; t < h; t++) {
            var k = l.getChannelData(t), g = f[m + t];
            for (o = 0; o < d; o++) g[o] = k[o + p];
        }
        for (flock.evaluate.synths(a), t = 0; t < m; t++) {
            var v = f[t], b = u.getChannelData(t);
            for (o = 0; o < d; o++) b[o + p] = v[o];
        }
    }
}, flock.webAudio.outputManager.iOSStart = function(e, t, n) {
    if (e.model.shouldInitIOS) {
        var o = t.createBufferSource();
        o.connect(n), o.start(0), o.disconnect(0), e.applier.change("shouldInitIOS", !1);
    }
};

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var e = fluid.registerNamespace("jQuery");
    flock.ugenDefaults = function(e, t) {
        return 1 === arguments.length ? flock.ugenDefaults.store[e] : (flock.ugenDefaults.store[e] = t, 
        t);
    }, flock.ugenDefaults.store = {}, flock.isUGen = function(e) {
        return e && e.tags && e.tags.indexOf("flock.ugen") > -1;
    }, flock.aliasUGen = function(t, n, o, r) {
        var a = flock.get(t);
        flock.set(a, n, function(t, n, o) {
            return o = e.extend(!0, {}, r, o), a(t, n, o);
        }), flock.ugenDefaults(t + "." + n, o);
    }, flock.aliasUGens = function(e, t) {
        var n, o;
        for (n in t) o = t[n], flock.aliasUGen(e, n, {
            inputs: o.inputDefaults
        }, o.options);
    }, flock.copyUGenDefinition = function(e, t) {
        var n = flock.ugenDefaults(e), o = fluid.getGlobalValue(e);
        fluid.setGlobalValue(t, o), flock.ugenDefaults(t, fluid.copy(n));
    }, flock.krMul = function(e, t, n) {
        var o, r = n.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] * r;
    }, flock.mul = function(e, t, n) {
        var o, r = n.output;
        for (o = 0; o < e; o++) t[o] = t[o] * r[o];
    }, flock.krAdd = function(e, t, n, o) {
        var r, a = o.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] + a;
    }, flock.add = function(e, t, n, o) {
        var r, a = o.output;
        for (r = 0; r < e; r++) t[r] = t[r] + a[r];
    }, flock.krMulAdd = function(e, t, n, o) {
        var r, a = n.output[0], i = o.output;
        for (r = 0; r < e; r++) t[r] = t[r] * a + i[r];
    }, flock.mulKrAdd = function(e, t, n, o) {
        var r, a = n.output, i = o.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] * a[r] + i;
    }, flock.krMulKrAdd = function(e, t, n, o) {
        var r, a = n.output[0], i = o.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] * a + i;
    }, flock.mulAdd = function(e, t, n, o) {
        var r, a = n.output, i = o.output;
        for (r = 0; r < e; r++) t[r] = t[r] * a[r] + i[r];
    }, flock.onMulAddInputChanged = function(e) {
        var t, n = e.inputs.mul, o = e.inputs.add;
        n || o ? (t = n ? o ? n.rate !== flock.rates.AUDIO ? o.rate !== flock.rates.AUDIO ? flock.krMulKrAdd : flock.krMulAdd : o.rate !== flock.rates.AUDIO ? flock.mulKrAdd : flock.mulAdd : n.rate !== flock.rates.AUDIO ? flock.krMul : flock.mul : o.rate !== flock.rates.AUDIO ? flock.krAdd : flock.add, 
        e.mulAddFn = t, e.mulAdd = function(t) {
            e.mulAddFn(t, e.output, e.inputs.mul, e.inputs.add);
        }) : e.mulAdd = e.mulAddFn = flock.noOp;
    }, flock.ugen = function(e, t, n) {
        var o = {
            enviro: (n = n || {}).enviro || flock.environment,
            rate: n.rate || flock.rates.AUDIO,
            inputs: e,
            output: t,
            options: n,
            model: n.model || {
                unscaledValue: 0,
                value: 0
            },
            multiInputs: {},
            tags: [ "flock.ugen" ]
        };
        return o.lastOutputIdx = o.output.length - 1, o.get = function(e) {
            return flock.input.get(o.inputs, e);
        }, o.set = function(e, t) {
            return flock.input.set(o.inputs, e, t, o, function(e) {
                if (null !== e && void 0 !== e) return flock.parse.ugenDef(e, o.enviro, {
                    audioSettings: o.options.audioSettings,
                    buses: o.buses,
                    buffers: o.buffers
                });
            });
        }, o.input = function(e, t) {
            return e ? "string" == typeof e ? arguments.length < 2 ? o.get(e) : o.set(e, t) : flock.isIterable(e) ? o.get(e) : o.set(e, t) : void 0;
        }, o.calculateStrides = function() {
            var e, t, n, r = o.model, a = o.options.strideInputs, i = o.inputs;
            if (r.strides = r.strides || {}, a) for (e = 0; e < a.length; e++) (n = i[t = a[e]]) ? r.strides[t] = n.rate === flock.rates.AUDIO ? 1 : 0 : fluid.log(fluid.logLevel.WARN, "An invalid input ('" + t + "') was found on a unit generator: " + o);
        }, o.collectMultiInputs = function() {
            var e, t, n, r, a = o.options.multiInputNames, i = o.multiInputs;
            for (e = 0; e < a.length; e++) (n = i[t = a[e]]) ? n.length = 0 : n = i[t] = [], 
            r = o.inputs[t], flock.ugen.collectMultiInputs(r, n);
        }, o.onInputChanged = function(e) {
            var t = o.options.multiInputNames;
            flock.onMulAddInputChanged(o), o.options.strideInputs && o.calculateStrides(), !t || e && !t.indexOf(e) || o.collectMultiInputs();
        }, o.init = function() {
            var e, t, n, r = fluid.makeArray(o.options.tags), a = o.model, i = o.options;
            for (e = 0; e < r.length; e++) o.tags.push(r[e]);
            if (t = i.audioSettings = i.audioSettings || o.enviro.audioSystem.model, a.sampleRate = i.sampleRate || t.rates[o.rate], 
            a.nyquistRate = a.sampleRate, a.blockSize = o.rate === flock.rates.AUDIO ? t.blockSize : 1, 
            a.sampleDur = 1 / a.sampleRate, o.interpolate = flock.interpolate.none, i.interpolation) {
                var l = flock.interpolate[i.interpolation];
                l ? o.interpolate = l : fluid.log(fluid.logLevel.IMPORTANT, "An invalid interpolation type of '" + i.interpolation + "' was specified. Defaulting to none.");
            }
            o.rate === flock.rates.DEMAND && o.inputs.freq && (n = flock.parse.ugenDefForConstantValue(1), 
            o.inputs.freq = flock.parse.ugenDef(n, o.enviro));
        }, o.init(), o;
    }, flock.ugen.collectMultiInputs = function(e, t) {
        flock.isIterable(e) || (e = e = fluid.makeArray(e));
        for (var n = 0; n < e.length; n++) {
            var o = e[n];
            flock.ugen.collectChannelsForInput(o, t);
        }
        return t;
    }, flock.ugen.collectChannelsForInput = function(e, t) {
        var n, o = flock.hasTag(e, "flock.ugen.multiChannelOutput") ? e.output : [ e.output ];
        for (n = 0; n < o.length; n++) t.push({
            rate: e.rate,
            output: o[n]
        });
        return t;
    }, flock.ugen.lastOutputValue = function(e, t) {
        return t[e - 1];
    }, flock.ugen.buffer = function(e) {
        e.onBufferInputChanged = function(t) {
            var n = e.model, o = e.inputs;
            n.bufDef === o.buffer && "buffer" !== t || (n.bufDef = o.buffer, flock.parse.bufferForDef(n.bufDef, e, e.enviro));
        }, e.setBuffer = function(t) {
            e.buffer = t, e.onBufferReady && e.onBufferReady(t);
        }, e.initBuffer = function() {
            e.buffer = e.model.bufDef = flock.bufferDesc({
                format: {
                    sampleRate: e.options.audioSettings.rates.audio
                },
                data: {
                    channels: [ new Float32Array(e.output.length) ]
                }
            });
        };
    }, flock.ugen.value = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.value = function() {
            return o.model.value;
        }, o.dynamicGen = function(e) {
            for (var t = o.output, n = o.model, r = 0; r < e; r++) t[r] = n.unscaledValue;
            o.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, t);
        }, o.onInputChanged = function() {
            var e = o.inputs;
            o.model.unscaledValue = e.value, "constant" !== o.rate ? o.gen = o.dynamicGen : o.gen = void 0, 
            flock.onMulAddInputChanged(o), o.dynamicGen(1);
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.value", {
        rate: "control",
        inputs: {
            value: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 1,
                value: 1
            },
            tags: [ "flock.ugen.valueType" ]
        }
    }), flock.ugen.silence = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.onInputChanged = function() {
            for (var e = 0; e < o.output.length; e++) o.output[e] = 0;
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.silence", {
        rate: "constant"
    }), flock.ugen.passThrough = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.gen = function(e) {
            var t, n, r = o.model, a = o.inputs.source.output, i = o.output;
            for (t = 0; t < a.length; t++) i[t] = n = a[t];
            for (;t < e; t++) i[t] = n = 0;
            r.unscaledValue = n, o.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, i);
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.passThrough", {
        rate: "audio",
        inputs: {
            source: null,
            mul: null,
            add: null
        }
    }), flock.ugen.out = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.gen = function(e) {
            var t, n, r, a, i, l, u, s, f, c, d = o.model, m = o.multiInputs.sources, h = o.options.buses, p = o.inputs.bus.output[0], k = o.inputs.expand.output[0];
            if (t = m.length, n = Math.max(k, t), !(t < 1)) {
                for (r = 0; r < n; r++) {
                    for (l = (i = m[r % t]).rate, u = h[p + r], s = l === flock.rates.AUDIO ? 1 : 0, 
                    f = 0, a = 0; a < e; a++, f += s) c = i.output[f], u[a] = u[a] + c;
                    o.mulAddFn(e, u, o.inputs.mul, o.inputs.add);
                }
                d.value = d.unscaledValue = c;
            }
        }, o.init = function() {
            o.sourceBuffers = [], o.onInputChanged();
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.out", {
        rate: "audio",
        inputs: {
            sources: null,
            bus: 0,
            expand: 2
        },
        ugenOptions: {
            tags: [ "flock.ugen.outputType" ],
            multiInputNames: [ "sources" ]
        }
    }), flock.ugen.valueOut = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.arraySourceGen = function() {
            var e, t = o.model, n = o.inputs.sources;
            for (e = 0; e < n.length; e++) t.value[e] = n[e].output[0];
        }, o.ugenSourceGen = function() {
            o.model.value = o.model.unscaledValue = o.inputs.sources.output[0];
        }, o.onInputChanged = function() {
            var e = o.model, t = o.inputs.sources;
            flock.isIterable(t) ? (o.gen = o.arraySourceGen, e.value = new Float32Array(t.length), 
            e.unscaledValue = e.value) : o.gen = o.ugenSourceGen;
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.valueOut", {
        rate: "control",
        inputs: {
            sources: null
        },
        ugenOptions: {
            model: {
                unscaledValue: null,
                value: null
            },
            tags: [ "flock.ugen.outputType", "flock.ugen.valueType" ]
        }
    }), flock.ugen.in = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.singleBusGen = function(e) {
            var t = o.model, n = o.output;
            flock.ugen.in.readBus(e, n, o.inputs.bus, o.options.buses), t.unscaledValue = flock.ugen.lastOutputValue(e, n), 
            o.mulAdd(e), t.value = flock.ugen.lastOutputValue(e, n);
        }, o.multiBusGen = function(e) {
            var t, n, r, a = o.model, i = o.inputs.bus, l = o.options.buses, u = o.output;
            for (t = 0; t < e; t++) {
                for (r = 0, n = 0; n < i.length; n++) r += l[0 | i[n].output[0]][t];
                u[t] = r;
            }
            a.unscaledValue = r, o.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, o.onInputChanged = function() {
            o.gen = flock.isIterable(o.inputs.bus) ? o.multiBusGen : o.singleBusGen, flock.onMulAddInputChanged(o);
        }, o.onInputChanged(), o;
    }, flock.ugen.in.readBus = function(e, t, n, o) {
        var r, a = o[0 | n.output[0]];
        for (r = 0; r < e; r++) t[r] = a[r];
    }, flock.ugenDefaults("flock.ugen.in", {
        rate: "audio",
        inputs: {
            bus: 0,
            mul: null,
            add: null
        }
    }), flock.ugen.audioIn = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.gen = function(e) {
            var t, n, r = o.model, a = o.output, i = o.bus;
            for (t = 0; t < e; t++) a[t] = n = i[t];
            r.unscaledValue = n, o.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, a);
        }, o.onInputChanged = function() {
            flock.onMulAddInputChanged(o);
        }, o.init = function() {
            var e = o.enviro.audioSystem.inputDeviceManager.openAudioDevice(n);
            o.bus = o.options.buses[e], o.onInputChanged();
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.audioIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    });
}();